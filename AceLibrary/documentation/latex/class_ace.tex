\section{Ace Class Reference}
\label{class_ace}\index{Ace@{Ace}}


{\ttfamily \#include $<$Ace.\+h$>$}

\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void $\ast$ {\bf \+\_\+\+Aligned\+\_\+\+Calloc} (size\+\_\+t size, size\+\_\+t alignment={\bf B\+Y\+T\+E\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT})
\begin{DoxyCompactList}\small\item\em Allocates a buffer of specified size and zeros it out. \end{DoxyCompactList}\item 
static double {\bf Absolute\+Value} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the absolute value of a number in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Absolute\+Value} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the absolute value of a number in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Absolute\+Value} (int num)
\begin{DoxyCompactList}\small\item\em Calculates the absolute value of a number in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Allocate\+And\+Copy\+String} (char $\ast$str\+To\+Copy)
\begin{DoxyCompactList}\small\item\em Allocates a buffer and copies a provided traditional string into the buffer. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Allocate\+And\+Copy\+String} (wchar\+\_\+t $\ast$wide\+Str\+To\+Copy)
\begin{DoxyCompactList}\small\item\em Allocates a buffer and copies a provided traditional wide string into the buffer. \end{DoxyCompactList}\item 
static double {\bf Arc\+Cos} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Cos in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+Cos} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Cos in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Arc\+Cos} (int num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Cos in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Arc\+CosH} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+CosH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+CosH} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+CosH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Arc\+CosH} (int num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+CosH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Arc\+Sin} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Sin in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+Sin} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Sin in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Arc\+Sin} (int num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Sin in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Arc\+SinH} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+SinH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+SinH} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+SinH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Arc\+SinH} (int num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+SinH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Arc\+Tan} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Tan in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+Tan} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Tan in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Arc\+Tan} (int num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Tan in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Arc\+TanH} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+TanH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+TanH} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+TanH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Arc\+TanH} (int num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+TanH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Arc\+Tan2} (double y\+In\+Radians, double x\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Tan2 in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+Tan2} (float y\+In\+Radians, float x\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Tan2 in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Arc\+Tan2} (int y\+In\+Radians, int x\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Tan2 in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static void {\bf Calculate\+Aspect\+Ratio} (int new\+Width, int new\+Height, int original\+Width, int original\+Height, int \&out\+Adjusted\+Width, int \&out\+Adjusted\+Height)
\begin{DoxyCompactList}\small\item\em Adjusts the resolution to the correct aspect ratio for the destination. \end{DoxyCompactList}\item 
static L\+O\+N\+G\+L\+O\+NG {\bf Calculate\+File\+Size} (char $\ast$the\+File\+Path)
\begin{DoxyCompactList}\small\item\em Uses fseek() to calculate the size of the file by moving the file pointer to the end. \end{DoxyCompactList}\item 
static L\+O\+N\+G\+L\+O\+NG {\bf Calculate\+File\+Size} (wchar\+\_\+t $\ast$the\+File\+Path)
\begin{DoxyCompactList}\small\item\em Gets the size of the file in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Calculate\+Num\+Length} (int num)
\begin{DoxyCompactList}\small\item\em Counts the number of digits of num. \end{DoxyCompactList}\item 
static long {\bf Calculate\+Num\+Length} (long num)
\begin{DoxyCompactList}\small\item\em Counts the number of digits of num. \end{DoxyCompactList}\item 
static double {\bf Ceiling} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the smallest integer value greater than or equal to num. \end{DoxyCompactList}\item 
static float {\bf Ceiling} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the smallest integer value greater than or equal to num. \end{DoxyCompactList}\item 
static int {\bf Ceiling} (int num)
\begin{DoxyCompactList}\small\item\em Calculates the smallest integer value greater than or equal to num. \end{DoxyCompactList}\item 
static char {\bf Char\+At} (char $\ast$str, int index)
\begin{DoxyCompactList}\small\item\em Returns a single character in str at a specified index. \end{DoxyCompactList}\item 
static wchar\+\_\+t {\bf Char\+At} (wchar\+\_\+t $\ast$str, int index)
\begin{DoxyCompactList}\small\item\em Returns a single character in str at a specified index. \end{DoxyCompactList}\item 
static double {\bf Complementary\+Error\+Function} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the Complementary Error Function integral from num to infinity in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Complementary\+Error\+Function} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the Complementary Error Function integral from num to infinity in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Complementary\+Error\+Function} (int num)
\begin{DoxyCompactList}\small\item\em Calculates the Complementary Error Function integral from num to infinity in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Concatenate\+Strings} (int num\+Strings, char $\ast$$\ast$string\+Array)
\begin{DoxyCompactList}\small\item\em Appends an array of strings together and returns the combined string. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Concatenate\+Strings} (int num\+Strings, wchar\+\_\+t $\ast$$\ast$string\+Array)
\begin{DoxyCompactList}\small\item\em Appends an array of strings together and returns the combined string. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Concatenate\+Strings} (vector$<$ char $\ast$ $>$ string\+Vector\+Array)
\begin{DoxyCompactList}\small\item\em Appends a vector array of strings together and returns the combined string. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Concatenate\+Strings} (vector$<$ wchar\+\_\+t $\ast$ $>$ string\+Vector\+Array)
\begin{DoxyCompactList}\small\item\em Appends a vector array of wide strings together and returns the combined wide string. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Concatenate} (int num\+Strings,...)
\begin{DoxyCompactList}\small\item\em Appends a series of strings together. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf ConcatenateW} (int num\+Wide\+Strings,...)
\begin{DoxyCompactList}\small\item\em Appends a series of strings together. \end{DoxyCompactList}\item 
static bool {\bf Contains} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns true if found. \end{DoxyCompactList}\item 
static bool {\bf Contains} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns true if found. \end{DoxyCompactList}\item 
static bool {\bf Contains\+Ignore\+Case} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns true if found. \end{DoxyCompactList}\item 
static bool {\bf Contains\+Ignore\+Case} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns true if found. \end{DoxyCompactList}\item 
static bool {\bf Convert\+Double\+To\+Bool} (double num)
\begin{DoxyCompactList}\small\item\em By definition, false is equal to 0 and true is equal to anything but 0. \end{DoxyCompactList}\item 
static bool {\bf Convert\+Float\+To\+Bool} (float num)
\begin{DoxyCompactList}\small\item\em By definition, false is equal to 0 and true is equal to anything but 0. \end{DoxyCompactList}\item 
static bool {\bf Convert\+Int\+To\+Bool} (int num)
\begin{DoxyCompactList}\small\item\em By definition, false is equal to 0 and true is equal to anything but 0. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Convert\+Int\+To\+String} (int integer\+To\+Convert)
\begin{DoxyCompactList}\small\item\em Returns a buffer containing the result of \+\_\+itoa\+\_\+s() using integer\+To\+Convert. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Convert\+Int\+To\+Wide\+String} (int integer\+To\+Convert)
\begin{DoxyCompactList}\small\item\em Returns a buffer containing the result of \+\_\+itow\+\_\+s() using integer\+To\+Convert. \end{DoxyCompactList}\item 
static vector$<$ char $\ast$ $>$ {\bf Convert\+String\+Array\+To\+String\+Vector\+Array} (char $\ast$$\ast$string\+Array)
\begin{DoxyCompactList}\small\item\em Converts a traditional string array to a vector string array. \end{DoxyCompactList}\item 
static vector$<$ wchar\+\_\+t $\ast$ $>$ {\bf Convert\+String\+Array\+To\+String\+Vector\+Array} (wchar\+\_\+t $\ast$$\ast$string\+Array)
\begin{DoxyCompactList}\small\item\em Converts a traditional wide string array to a vector wide string array. \end{DoxyCompactList}\item 
static bool {\bf Convert\+String\+To\+Bool} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a given string to a bool, If str is a string like \char`\"{}\+False\char`\"{}, \char`\"{}\+F\+A\+L\+S\+E\char`\"{}, or \char`\"{}t\+Ru\+E\char`\"{}, then the function will return false, false, true respectively. \end{DoxyCompactList}\item 
static bool {\bf Convert\+String\+To\+Bool} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a given wide string to a bool, If str is a wide string like \char`\"{}\+False\char`\"{}, \char`\"{}\+F\+A\+L\+S\+E\char`\"{}, or \char`\"{}t\+Ru\+E\char`\"{}, then the function will return false, false, true respectively. \end{DoxyCompactList}\item 
static float $\ast$ {\bf Convert\+String\+To\+Float\+Array} (char $\ast$str\+To\+Convert, char $\ast$delimiter, int \&out\+Num\+Items)
\begin{DoxyCompactList}\small\item\em Converts a tokenized string (a string with commas separating numbers for example) to an array of floats. \end{DoxyCompactList}\item 
static float $\ast$ {\bf Convert\+String\+To\+Float\+Array} (wchar\+\_\+t $\ast$str\+To\+Convert, wchar\+\_\+t $\ast$delimiter, int \&out\+Num\+Items)
\begin{DoxyCompactList}\small\item\em Converts a tokenized wide string (a string with commas separating numbers for example) to an array of floats. \end{DoxyCompactList}\item 
static unsigned int {\bf Convert\+String\+To\+Hex} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a string to its hex value. \end{DoxyCompactList}\item 
static unsigned int {\bf Convert\+String\+To\+Hex} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a string to its hex value. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Convert\+String\+To\+One\+Line} (char $\ast$str\+To\+Convert)
\begin{DoxyCompactList}\small\item\em Converts a traditional string to a traditional string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Convert\+String\+To\+One\+Line} (wchar\+\_\+t $\ast$str\+To\+Convert)
\begin{DoxyCompactList}\small\item\em Converts a traditional wide string to a traditional wide string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. \end{DoxyCompactList}\item 
static void {\bf Convert\+String\+To\+One\+Line\+In\+Place} (char $\ast$str\+To\+Convert)
\begin{DoxyCompactList}\small\item\em Converts a traditional string to a traditional string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. \end{DoxyCompactList}\item 
static void {\bf Convert\+String\+To\+One\+Line\+In\+Place} (wchar\+\_\+t $\ast$str\+To\+Convert)
\begin{DoxyCompactList}\small\item\em Converts a traditional wide string to a traditional wide string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Convert\+String\+To\+W\+Char\+String} (const char $\ast$str\+To\+Convert)
\begin{DoxyCompactList}\small\item\em Converts a traditional string to a wide string. \end{DoxyCompactList}\item 
static char $\ast$$\ast$ {\bf Convert\+String\+Vector\+Array\+To\+String\+Array} (vector$<$ char $\ast$ $>$ string\+Vector\+Array, int \&out\+String\+Array\+Length)
\begin{DoxyCompactList}\small\item\em Converts a string vector array to a traditional string array. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$$\ast$ {\bf Convert\+String\+Vector\+Array\+To\+String\+Array} (vector$<$ wchar\+\_\+t $\ast$ $>$ string\+Vector\+Array, int \&out\+String\+Array\+Length)
\begin{DoxyCompactList}\small\item\em Converts a wide string vector array to a traditional wide string array. \end{DoxyCompactList}\item 
static char {\bf Convert\+To\+Lower\+Case} (char character)
\begin{DoxyCompactList}\small\item\em Converts a character to lowercase. \end{DoxyCompactList}\item 
static wchar\+\_\+t {\bf Convert\+To\+Lower\+Case} (wchar\+\_\+t character)
\begin{DoxyCompactList}\small\item\em Converts a wide character to lowercase. \end{DoxyCompactList}\item 
static char {\bf Convert\+To\+Upper\+Case} (char character)
\begin{DoxyCompactList}\small\item\em Converts a character to uppercase. \end{DoxyCompactList}\item 
static wchar\+\_\+t {\bf Convert\+To\+Upper\+Case} (wchar\+\_\+t character)
\begin{DoxyCompactList}\small\item\em Converts a wide character to uppercase. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Convert\+To\+Lower\+Case} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a string to all lowercase letters. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Convert\+To\+Lower\+Case} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a wide string to all lowercase letters. \end{DoxyCompactList}\item 
static void {\bf Convert\+To\+Lower\+Case\+In\+Place} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Directly modifies str to have all its letters converted to lower case. \end{DoxyCompactList}\item 
static void {\bf Convert\+To\+Lower\+Case\+In\+Place} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Directly modifies str to have all its letters converted to lower case. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Convert\+To\+Upper\+Case} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a string to all uppercase letters. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Convert\+To\+Upper\+Case} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a string to all uppercase letters. \end{DoxyCompactList}\item 
static void {\bf Convert\+To\+Upper\+Case\+In\+Place} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Directly modifies str to have all its letters converted to upper case. \end{DoxyCompactList}\item 
static void {\bf Convert\+To\+Upper\+Case\+In\+Place} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Directly modifies str to have all its letters converted to upper case. \end{DoxyCompactList}\item 
static double {\bf Cos} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Cosine (cos) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Cos} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Cosine (cos) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Cos} (int num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Cosine (cos) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf CosH} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the CosH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf CosH} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the CosH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf CosH} (int num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the CosH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Count\+Num\+Occurrences} (char $\ast$str\+To\+Search, char char\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Counts the number of times char\+To\+Look\+For appears in str\+To\+Search. \end{DoxyCompactList}\item 
static int {\bf Count\+Num\+Occurrences} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t char\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Counts the number of times char\+To\+Look\+For appears in str\+To\+Search. \end{DoxyCompactList}\item 
static int {\bf Count\+Num\+Occurrences} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Counts the number of times str\+To\+Look\+For appears in str\+To\+Search. \end{DoxyCompactList}\item 
static int {\bf Count\+Num\+Occurrences} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Counts the number of times str\+To\+Look\+For appears in str\+To\+Search. \end{DoxyCompactList}\item 
static double {\bf Cube\+Root} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the Cube Root in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Cube\+Root} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the Cube Root in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Cube\+Root} (int num)
\begin{DoxyCompactList}\small\item\em Calculates the Cube Root in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Degrees\+To\+Radians} (double degrees)
\begin{DoxyCompactList}\small\item\em Converts a number from degrees to radians. \end{DoxyCompactList}\item 
static float {\bf Degrees\+To\+Radians} (float degrees)
\begin{DoxyCompactList}\small\item\em Converts a number from degrees to radians. \end{DoxyCompactList}\item 
static int {\bf Degrees\+To\+Radians} (int degrees)
\begin{DoxyCompactList}\small\item\em Converts a number from degrees to radians. \end{DoxyCompactList}\item 
static bool {\bf Does\+File\+Exist} (char $\ast$full\+File\+Path\+With\+Name\+And\+Ext)
\begin{DoxyCompactList}\small\item\em Returns true if the specified file exists, false otherwise. \end{DoxyCompactList}\item 
static bool {\bf Does\+File\+Exist} (wchar\+\_\+t $\ast$full\+File\+Path\+With\+Name\+And\+Ext)
\begin{DoxyCompactList}\small\item\em Returns true if the specified file exists, false otherwise. \end{DoxyCompactList}\item 
static double {\bf Error\+Function} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the Error Function integral from 0 to num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Error\+Function} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the Error Function integral from 0 to num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Error\+Function} (int num)
\begin{DoxyCompactList}\small\item\em Calculates the Error Function integral from 0 to num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static bool {\bf Equals} (char $\ast$str\+To\+Comp\+One, char $\ast$str\+To\+Comp\+Two)
\begin{DoxyCompactList}\small\item\em Compares two traditional strings together. \end{DoxyCompactList}\item 
static bool {\bf Equals} (wchar\+\_\+t $\ast$str\+To\+Comp\+One, wchar\+\_\+t $\ast$str\+To\+Comp\+Two)
\begin{DoxyCompactList}\small\item\em Compares two traditional wide strings together. \end{DoxyCompactList}\item 
static bool {\bf Equals\+Ignore\+Case} (char $\ast$str\+To\+Comp\+One, char $\ast$str\+To\+Comp\+Two)
\begin{DoxyCompactList}\small\item\em Compares two traditional strings together but ignores upper/lower case. \end{DoxyCompactList}\item 
static bool {\bf Equals\+Ignore\+Case} (wchar\+\_\+t $\ast$str\+To\+Comp\+One, wchar\+\_\+t $\ast$str\+To\+Comp\+Two)
\begin{DoxyCompactList}\small\item\em Compares two traditional wide strings together but ignores upper/lower case. \end{DoxyCompactList}\item 
static double {\bf E\+To\+The\+X\+Power} (double power)
\begin{DoxyCompactList}\small\item\em Calculates e$^\wedge$x in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf E\+To\+The\+X\+Power} (float power)
\begin{DoxyCompactList}\small\item\em Calculates e$^\wedge$x in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf E\+To\+The\+X\+Power} (int power)
\begin{DoxyCompactList}\small\item\em Calculates e$^\wedge$x in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf E\+To\+The\+X\+Power\+Minus\+One} (double power)
\begin{DoxyCompactList}\small\item\em Calculates (e$^\wedge$x) -\/ 1 in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf E\+To\+The\+X\+Power\+Minus\+One} (float power)
\begin{DoxyCompactList}\small\item\em Calculates (e$^\wedge$x) -\/ 1 in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf E\+To\+The\+X\+Power\+Minus\+One} (int power)
\begin{DoxyCompactList}\small\item\em Calculates (e$^\wedge$x) -\/ 1 in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static char {\bf First\+Char} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Returns the first character in str. \end{DoxyCompactList}\item 
static wchar\+\_\+t {\bf First\+Char} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Returns the first character in str. \end{DoxyCompactList}\item 
static double {\bf Floor} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the largest integer value not greater than num. \end{DoxyCompactList}\item 
static float {\bf Floor} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the largest integer value not greater than num. \end{DoxyCompactList}\item 
static int {\bf Floor} (int num)
\begin{DoxyCompactList}\small\item\em Calculates the largest integer value not greater than num. \end{DoxyCompactList}\item 
static double {\bf Gamma\+Function} (double num)
\begin{DoxyCompactList}\small\item\em Calculates The Gamma Function ( (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] ) in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Gamma\+Function} (float num)
\begin{DoxyCompactList}\small\item\em Calculates The Gamma Function ( (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] ) in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Gamma\+Function} (int num)
\begin{DoxyCompactList}\small\item\em Calculates The Gamma Function ( (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] ) in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Generate\+Random\+Num} (int min, int max)
\begin{DoxyCompactList}\small\item\em Some might think this is all unnecessary but I think it\textquotesingle{}s important to seed the Random\+Number\+Generator properly with a proper seed value. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Get\+H\+Result\+Description} (H\+R\+E\+S\+U\+LT result)
\begin{DoxyCompactList}\small\item\em Gets the corresponding detailed description of the H\+R\+E\+S\+U\+LT. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Get\+H\+Result\+DescriptionW} (H\+R\+E\+S\+U\+LT result)
\begin{DoxyCompactList}\small\item\em Gets the corresponding detailed description of the H\+R\+E\+S\+U\+LT. \end{DoxyCompactList}\item 
static void {\bf Get\+Image\+Size} (char $\ast$file\+Name, int $\ast$out\+Width, int $\ast$out\+Height)
\begin{DoxyCompactList}\small\item\em Gets the pixel dimensions of the provided image (file\+Path). \end{DoxyCompactList}\item 
static void {\bf Get\+Image\+SizeW} (wchar\+\_\+t $\ast$file\+Name, int $\ast$out\+Width, int $\ast$out\+Height)
\begin{DoxyCompactList}\small\item\em Gets the pixel dimensions of the provided image (file\+Path). \end{DoxyCompactList}\item 
static double {\bf Hypotenuse} (double x, double y)
\begin{DoxyCompactList}\small\item\em Solves for c in Pythagoras theorem (a$^\wedge$2 + b$^\wedge$2 = c$^\wedge$2); i.\+e square root of (x$^\wedge$2 + y$^\wedge$2). \end{DoxyCompactList}\item 
static float {\bf Hypotenuse} (float x, float y)
\begin{DoxyCompactList}\small\item\em Solves for c in Pythagoras theorem (a$^\wedge$2 + b$^\wedge$2 = c$^\wedge$2); i.\+e square root of (x$^\wedge$2 + y$^\wedge$2). \end{DoxyCompactList}\item 
static int {\bf Hypotenuse} (int x, int y)
\begin{DoxyCompactList}\small\item\em Solves for c in Pythagoras theorem (a$^\wedge$2 + b$^\wedge$2 = c$^\wedge$2); i.\+e square root of (x$^\wedge$2 + y$^\wedge$2). \end{DoxyCompactList}\item 
static int {\bf Index\+Of} (char $\ast$str\+To\+Search, char char\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of char\+To\+Look\+For and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static int {\bf Index\+Of} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t char\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of char\+To\+Look\+For and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static int {\bf Index\+Of} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static int {\bf Index\+Of} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static int {\bf Index\+Of\+First\+Letter} (char $\ast$str\+To\+Search)
\begin{DoxyCompactList}\small\item\em Returns the first index of a letter in a given string. \end{DoxyCompactList}\item 
static int {\bf Index\+Of\+First\+Letter} (wchar\+\_\+t $\ast$str\+To\+Search)
\begin{DoxyCompactList}\small\item\em Returns the first index of a letter in a given wide string. \end{DoxyCompactList}\item 
static int {\bf Index\+Of\+Ignore\+Case} (char $\ast$str\+To\+Search, char char\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of char\+To\+Look\+For (regardless of case) and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static int {\bf Index\+Of\+Ignore\+Case} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t char\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of char\+To\+Look\+For (regardless of case) and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static int {\bf Index\+Of\+Ignore\+Case} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static int {\bf Index\+Of\+Ignore\+Case} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Insert\+String} (char $\ast$str\+To\+Receive, char $\ast$str\+To\+Insert, int start\+Index)
\begin{DoxyCompactList}\small\item\em Inserts the string str\+To\+Insert into str\+To\+Revcive by \char`\"{}sandwiching\char`\"{} the two halves of str\+To\+Receive. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Insert\+String} (wchar\+\_\+t $\ast$str\+To\+Receive, wchar\+\_\+t $\ast$str\+To\+Insert, int start\+Index)
\begin{DoxyCompactList}\small\item\em Inserts the string str\+To\+Insert into str\+To\+Revcive by \char`\"{}sandwiching\char`\"{} the two halves of str\+To\+Receive. \end{DoxyCompactList}\item 
static bool {\bf Is\+Alphabetic} (char character)
\begin{DoxyCompactList}\small\item\em Returns true if a character is a letter from either a to z or A to Z. \end{DoxyCompactList}\item 
static bool {\bf Is\+Alphabetic} (wchar\+\_\+t character)
\begin{DoxyCompactList}\small\item\em Returns true if a wide character is not a digit. \end{DoxyCompactList}\item 
static bool {\bf Is\+Digit} (char character)
\begin{DoxyCompactList}\small\item\em Returns true if a character is a digit from 0-\/9. \end{DoxyCompactList}\item 
static bool {\bf Is\+Digit} (wchar\+\_\+t character)
\begin{DoxyCompactList}\small\item\em Returns true if a wide character is a digit. \end{DoxyCompactList}\item 
static bool {\bf Is\+Empty} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Searches a given string to see if it is all empty. \end{DoxyCompactList}\item 
static bool {\bf Is\+Empty} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Searches a given wide string to see if it is all empty. \end{DoxyCompactList}\item 
static bool {\bf Is\+Number} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Returns true if all characters are a digit. \end{DoxyCompactList}\item 
static bool {\bf Is\+Number} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Returns true if all characters are a digit. \end{DoxyCompactList}\item 
static bool {\bf Is\+Path\+A\+Device} (const char $\ast$path)
\begin{DoxyCompactList}\small\item\em Returns true if the provided path leads to a device rather than a file. \end{DoxyCompactList}\item 
static bool {\bf Is\+Path\+A\+Device} (const wchar\+\_\+t $\ast$path)
\begin{DoxyCompactList}\small\item\em Returns true if the provided path leads to a device rather than a file. \end{DoxyCompactList}\item 
static bool {\bf Is\+Whitespace} (char character)
\begin{DoxyCompactList}\small\item\em Returns true if a character is whitespace. \end{DoxyCompactList}\item 
static bool {\bf Is\+Whitespace} (wchar\+\_\+t character)
\begin{DoxyCompactList}\small\item\em Returns true if a wide character is whitespace. \end{DoxyCompactList}\item 
static double {\bf Largest} (double num1, double num2)
\begin{DoxyCompactList}\small\item\em Returns the larger of the two values. \end{DoxyCompactList}\item 
static float {\bf Largest} (float num1, float num2)
\begin{DoxyCompactList}\small\item\em Returns the larger of the two values. \end{DoxyCompactList}\item 
static int {\bf Largest} (int num1, int num2)
\begin{DoxyCompactList}\small\item\em Returns the larger of the two values. \end{DoxyCompactList}\item 
static char {\bf Last\+Char} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Returns the last character in str. \end{DoxyCompactList}\item 
static wchar\+\_\+t {\bf Last\+Char} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Returns the last character in str. \end{DoxyCompactList}\item 
static int {\bf Last\+Index\+Of} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the last occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static int {\bf Last\+Index\+Of} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the last occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static double {\bf Log\+Base\+Ten} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the logarithm (log) base 10 of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Log\+Base\+Ten} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the logarithm (log) base 10 of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Log\+Base\+Ten} (int num)
\begin{DoxyCompactList}\small\item\em Calculates the logarithm (log) base 10 of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Log\+Base\+Two} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the logarithm (log) base 2 of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Log\+Base\+Two} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the logarithm (log) base 2 of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Log\+Base\+Two} (int num)
\begin{DoxyCompactList}\small\item\em Calculates the logarithm (log) base 2 of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Mod} (double numerator, double denominator)
\begin{DoxyCompactList}\small\item\em Computes the floating-\/point remainder of the division operation numerator/denominator in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Mod} (float numerator, float denominator)
\begin{DoxyCompactList}\small\item\em Computes the floating-\/point remainder of the division operation numerator/denominator in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Mod} (int numerator, int denominator)
\begin{DoxyCompactList}\small\item\em Computes the floating-\/point remainder of the division operation numerator/denominator in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Multiply\+Then\+Add} (double mult\+One, double mult\+Two, double add)
\begin{DoxyCompactList}\small\item\em Calculates the product of mult\+One $\ast$ mult\+Two, then adds add to that product (i.\+e. \end{DoxyCompactList}\item 
static float {\bf Multiply\+Then\+Add} (float mult\+One, float mult\+Two, float add)
\begin{DoxyCompactList}\small\item\em Calculates the product of mult\+One $\ast$ mult\+Two, then adds add to that product (i.\+e. \end{DoxyCompactList}\item 
static int {\bf Multiply\+Then\+Add} (int mult\+One, int mult\+Two, int add)
\begin{DoxyCompactList}\small\item\em Calculates the product of mult\+One $\ast$ mult\+Two, then adds add to that product (i.\+e. \end{DoxyCompactList}\item 
static double {\bf Natural\+Log} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the Natural Logarithm (ln) of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Natural\+Log} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the Natural Logarithm (ln) of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Natural\+Log} (int num)
\begin{DoxyCompactList}\small\item\em Calculates the Natural Logarithm (ln) of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Natural\+Log\+Gamma\+Function} (double num)
\begin{DoxyCompactList}\small\item\em Calculates The Natural Log (ln) of The Gamma Function (ln $\vert$ (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] $\vert$). \end{DoxyCompactList}\item 
static float {\bf Natural\+Log\+Gamma\+Function} (float num)
\begin{DoxyCompactList}\small\item\em Calculates The Natural Log (ln) of The Gamma Function (ln $\vert$ (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] $\vert$). \end{DoxyCompactList}\item 
static int {\bf Natural\+Log\+Gamma\+Function} (int num)
\begin{DoxyCompactList}\small\item\em Calculates The Natural Log (ln) of The Gamma Function (ln $\vert$ (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] $\vert$). \end{DoxyCompactList}\item 
static int {\bf Next\+Index\+Of} (char $\ast$str\+To\+Search, char char\+To\+Look\+For, int start\+Index)
\begin{DoxyCompactList}\small\item\em Retrieves the first occurrence of char\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. \end{DoxyCompactList}\item 
static int {\bf Next\+Index\+Of} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t char\+To\+Look\+For, int start\+Index)
\begin{DoxyCompactList}\small\item\em Retrieves the first occurrence of char\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. \end{DoxyCompactList}\item 
static int {\bf Next\+Index\+Of} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For, int start\+Index)
\begin{DoxyCompactList}\small\item\em Retrieves the first occurrence of str\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. \end{DoxyCompactList}\item 
static int {\bf Next\+Index\+Of} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For, int start\+Index)
\begin{DoxyCompactList}\small\item\em Retrieves the first occurrence of str\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. \end{DoxyCompactList}\item 
static double {\bf Num\+Times\+Two\+To\+The\+X\+Power} (double num, double power)
\begin{DoxyCompactList}\small\item\em Calculates num $\ast$ 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Num\+Times\+Two\+To\+The\+X\+Power} (float num, float power)
\begin{DoxyCompactList}\small\item\em Calculates num $\ast$ 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Num\+Times\+Two\+To\+The\+X\+Power} (int num, int power)
\begin{DoxyCompactList}\small\item\em Calculates num $\ast$ 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Power} (double base, double exponent)
\begin{DoxyCompactList}\small\item\em Takes the provided base and raises it to the exponent (power). \end{DoxyCompactList}\item 
static float {\bf Power} (float base, float exponent)
\begin{DoxyCompactList}\small\item\em Takes the provided base and raises it to the exponent (power). \end{DoxyCompactList}\item 
static int {\bf Power} (int base, int exponent)
\begin{DoxyCompactList}\small\item\em Takes the provided base and raises it to the exponent (power). \end{DoxyCompactList}\item 
static double {\bf Positive\+Difference} (double num\+One, double num\+Two)
\begin{DoxyCompactList}\small\item\em Calculates the difference between num\+One and num\+Two only if num\+One $>$ num\+Two. \end{DoxyCompactList}\item 
static float {\bf Positive\+Difference} (float num\+One, float num\+Two)
\begin{DoxyCompactList}\small\item\em Calculates the difference between num\+One and num\+Two only if num\+One $>$ num\+Two. \end{DoxyCompactList}\item 
static int {\bf Positive\+Difference} (int num\+One, int num\+Two)
\begin{DoxyCompactList}\small\item\em Calculates the difference between num\+One and num\+Two only if num\+One $>$ num\+Two. \end{DoxyCompactList}\item 
static double {\bf Radians\+To\+Degrees} (double radians)
\begin{DoxyCompactList}\small\item\em Converts a number from radians to degrees. \end{DoxyCompactList}\item 
static float {\bf Radians\+To\+Degrees} (float radians)
\begin{DoxyCompactList}\small\item\em Converts a number from radians to degrees. \end{DoxyCompactList}\item 
static int {\bf Radians\+To\+Degrees} (int radians)
\begin{DoxyCompactList}\small\item\em Converts a number from radians to degrees. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Read\+Text\+File} (char $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size={\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}, const char $\ast$mode=\char`\"{}r\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for reading and returns a char buffer containing some or all of the data in the file. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Read\+Text\+FileW} (wchar\+\_\+t $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size={\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}, const wchar\+\_\+t $\ast$mode=L\char`\"{}r, ccs=U\+TF-\/8\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for reading and returns a wide char buffer containing some or all of the data in the file. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Read\+Binary\+File} (char $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size={\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}, const char $\ast$mode=\char`\"{}rb\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for reading and returns a char buffer containing some or all of the data in the file. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Read\+Binary\+FileW} (wchar\+\_\+t $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size={\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}, const wchar\+\_\+t $\ast$mode=L\char`\"{}rb, ccs=U\+TF-\/8\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for reading and returns a wide char buffer containing some or all of the data in the file. \end{DoxyCompactList}\item 
static vector$<$ char $\ast$ $>$ {\bf Retrieve\+File\+Names} (char $\ast$full\+File\+Path)
\begin{DoxyCompactList}\small\item\em Returns all the names of the files inside a folder, Ignores non files like folders. \end{DoxyCompactList}\item 
static double {\bf Remainder} (double numerator, double denominator)
\begin{DoxyCompactList}\small\item\em Calculates the Computes The I\+E\+EE remainder of the floating point division operation numerator/denominator. \end{DoxyCompactList}\item 
static float {\bf Remainder} (float numerator, float denominator)
\begin{DoxyCompactList}\small\item\em Calculates the Computes The I\+E\+EE remainder of the floating point division operation numerator/denominator. \end{DoxyCompactList}\item 
static int {\bf Remainder} (int numerator, int denominator)
\begin{DoxyCompactList}\small\item\em Calculates the Computes The I\+E\+EE remainder of the floating point division operation numerator/denominator. \end{DoxyCompactList}\item 
static double {\bf Remainder\+With\+Quadrant} (double numerator, double denominator, int $\ast$out\+Quadrant)
\begin{DoxyCompactList}\small\item\em Calculates the floating-\/point remainder of the division operation numerator/denominator the same way the \doxyref{Remainder()}{p.}{class_ace_a0f05443f499ce94d53c3a5e584460d52} function does. \end{DoxyCompactList}\item 
static float {\bf Remainder\+With\+Quadrant} (float numerator, float denominator, int $\ast$out\+Quadrant)
\begin{DoxyCompactList}\small\item\em Calculates the floating-\/point remainder of the division operation numerator/denominator the same way the \doxyref{Remainder()}{p.}{class_ace_a0f05443f499ce94d53c3a5e584460d52} function does. \end{DoxyCompactList}\item 
static int {\bf Remainder\+With\+Quadrant} (int numerator, int denominator, int $\ast$out\+Quadrant)
\begin{DoxyCompactList}\small\item\em Calculates the floating-\/point remainder of the division operation numerator/denominator the same way the \doxyref{Remainder()}{p.}{class_ace_a0f05443f499ce94d53c3a5e584460d52} function does. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Remove\+All\+Whitespace} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Removes all whitespace from a given string. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Remove\+All\+Whitespace} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Removes all whitespace from a given wide string. \end{DoxyCompactList}\item 
static void {\bf Remove\+All\+Whitespace\+In\+Place} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Removes all whitespace from a given string in place. \end{DoxyCompactList}\item 
static void {\bf Remove\+All\+Whitespace\+In\+Place} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Removes all whitespace from a given wide string in place. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Remove\+Characters\+From\+String} (char $\ast$str\+To\+Remove\+From, char char\+To\+Remove)
\begin{DoxyCompactList}\small\item\em Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Remove\+Characters\+From\+String} (wchar\+\_\+t $\ast$str\+To\+Remove\+From, wchar\+\_\+t char\+To\+Remove)
\begin{DoxyCompactList}\small\item\em Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. \end{DoxyCompactList}\item 
static void {\bf Remove\+Characters\+From\+String\+In\+Place} (char $\ast$str\+To\+Remove\+From, char char\+To\+Remove)
\begin{DoxyCompactList}\small\item\em Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. \end{DoxyCompactList}\item 
static void {\bf Remove\+Characters\+From\+String\+In\+Place} (wchar\+\_\+t $\ast$str\+To\+Remove\+From, wchar\+\_\+t char\+To\+Remove)
\begin{DoxyCompactList}\small\item\em Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Remove\+String\+From\+String} (char $\ast$str\+To\+Remove\+From, char $\ast$str\+To\+Remove, bool remove\+Only\+First\+Occurrence=false)
\begin{DoxyCompactList}\small\item\em Removes the specified string (str\+To\+Look\+For) from str\+To\+Search and returns a newly allocated buffer containing the result. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Remove\+String\+From\+String} (wchar\+\_\+t $\ast$str\+To\+Remove\+From, wchar\+\_\+t $\ast$str\+To\+Remove, bool remove\+Only\+First\+Occurrence=false)
\begin{DoxyCompactList}\small\item\em Removes the specified string (str\+To\+Look\+For) from str\+To\+Search and returns a newly allocated buffer containing the result. \end{DoxyCompactList}\item 
static void {\bf Remove\+String\+From\+String\+In\+Place} (char $\ast$\&str\+To\+Remove\+From, char $\ast$str\+To\+Remove, bool remove\+Only\+First\+Occurrence=false)
\begin{DoxyCompactList}\small\item\em Removes the specified string (str\+To\+Look\+For) by directly modifying str\+To\+Search. \end{DoxyCompactList}\item 
static void {\bf Remove\+String\+From\+String\+In\+Place} (wchar\+\_\+t $\ast$\&str\+To\+Remove\+From, wchar\+\_\+t $\ast$str\+To\+Remove, bool remove\+Only\+First\+Occurrence=false)
\begin{DoxyCompactList}\small\item\em Removes the specified string (str\+To\+Look\+For) by directly modifying str\+To\+Search. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Replace\+String} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For, char $\ast$str\+To\+Replace\+With, bool remove\+Only\+First\+Occurrence=false)
\begin{DoxyCompactList}\small\item\em Inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Replace\+String} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For, wchar\+\_\+t $\ast$str\+To\+Replace\+With, bool remove\+Only\+First\+Occurrence=false)
\begin{DoxyCompactList}\small\item\em Inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. \end{DoxyCompactList}\item 
static void {\bf Replace\+String\+In\+Place} (char $\ast$\&str\+To\+Search, char $\ast$str\+To\+Look\+For, char $\ast$str\+To\+Replace\+With, bool remove\+Only\+First\+Occurrence=false)
\begin{DoxyCompactList}\small\item\em Directly modifies and inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. \end{DoxyCompactList}\item 
static void {\bf Replace\+String\+In\+Place} (wchar\+\_\+t $\ast$\&str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For, wchar\+\_\+t $\ast$str\+To\+Replace\+With, bool remove\+Only\+First\+Occurrence=false)
\begin{DoxyCompactList}\small\item\em Directly modifies and inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Retrieve\+Data\+Between\+Tags} (char $\ast$file\+Data, char $\ast$start\+Tag, char $\ast$end\+Tag)
\begin{DoxyCompactList}\small\item\em Finds the X\+ML data between the start\+Tag and end\+Tag and returns it. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Retrieve\+Data\+Between\+Tags} (wchar\+\_\+t $\ast$file\+Data, wchar\+\_\+t $\ast$start\+Tag, wchar\+\_\+t $\ast$end\+Tag)
\begin{DoxyCompactList}\small\item\em Finds the X\+ML data between the start\+Tag and end\+Tag and returns it. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Retrieve\+Data\+Between\+Tags} (char $\ast$file\+Data, int start\+Tag\+Index, int end\+Tag\+Index)
\begin{DoxyCompactList}\small\item\em Finds the X\+ML data between the start\+Tag\+Index and end\+Tag\+Index and returns it. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Retrieve\+Data\+Between\+Tags} (wchar\+\_\+t $\ast$file\+Data, int start\+Tag\+Index, int end\+Tag\+Index)
\begin{DoxyCompactList}\small\item\em Finds the X\+ML data between the start\+Tag\+Index and end\+Tag\+Index and returns it. \end{DoxyCompactList}\item 
static char $\ast$$\ast$ {\bf Retrieve\+Data\+Chunks\+Between\+Tags} (char $\ast$file\+Data, char $\ast$start\+Tag, char $\ast$end\+Tag, int \&out\+Final\+Buffer\+Size)
\begin{DoxyCompactList}\small\item\em Finds a series of X\+ML data between start\+Tag and end\+Tag. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$$\ast$ {\bf Retrieve\+Data\+Chunks\+Between\+Tags} (wchar\+\_\+t $\ast$file\+Data, wchar\+\_\+t $\ast$start\+Tag, wchar\+\_\+t $\ast$end\+Tag, int \&out\+Final\+Buffer\+Size)
\begin{DoxyCompactList}\small\item\em Finds a series of X\+ML data between start\+Tag and end\+Tag. \end{DoxyCompactList}\item 
static vector$<$ wchar\+\_\+t $\ast$ $>$ {\bf Retrieve\+File\+Names} (wchar\+\_\+t $\ast$full\+File\+Path)
\begin{DoxyCompactList}\small\item\em Returns all the names of the files inside a folder, Ignores non files like folders. \end{DoxyCompactList}\item 
static vector$<$ char $\ast$ $>$ {\bf Retrieve\+Folder\+Names} (char $\ast$full\+File\+Path)
\begin{DoxyCompactList}\small\item\em Returns all the names of the sub-\/folder(s) in a folder. \end{DoxyCompactList}\item 
static vector$<$ wchar\+\_\+t $\ast$ $>$ {\bf Retrieve\+Folder\+Names} (wchar\+\_\+t $\ast$full\+File\+Path)
\begin{DoxyCompactList}\small\item\em Returns all the names of the sub-\/folder(s) in a folder. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Reverse\+String} (char $\ast$str\+To\+Reverse)
\begin{DoxyCompactList}\small\item\em Creates a new string containing all the characters from str\+To\+Reverse in reverse order. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Reverse\+String} (wchar\+\_\+t $\ast$str\+To\+Reverse)
\begin{DoxyCompactList}\small\item\em Creates a new wide string containing all the characters from str\+To\+Reverse in reverse order. \end{DoxyCompactList}\item 
static void {\bf Reverse\+String\+In\+Place} (char $\ast$str\+To\+Reverse)
\begin{DoxyCompactList}\small\item\em Directly modifies str\+To\+Reverse to have all its characters in reverse order. \end{DoxyCompactList}\item 
static void {\bf Reverse\+String\+In\+Place} (wchar\+\_\+t $\ast$str\+To\+Reverse)
\begin{DoxyCompactList}\small\item\em Directly modifies str\+To\+Reverse to have all its characters in reverse order. \end{DoxyCompactList}\item 
static long {\bf Round\+To\+Nearest\+Integer} (double num)
\begin{DoxyCompactList}\small\item\em Rounds the floating-\/point argument num to an integer value, using the current rounding mode. \end{DoxyCompactList}\item 
static long {\bf Round\+To\+Nearest\+Integer} (float num)
\begin{DoxyCompactList}\small\item\em Rounds the floating-\/point argument num to an integer value, using the current rounding mode. \end{DoxyCompactList}\item 
static long {\bf Round\+To\+Nearest\+Integer} (int num)
\begin{DoxyCompactList}\small\item\em Rounds the floating-\/point argument num to an integer value, using the current rounding mode. \end{DoxyCompactList}\item 
static long {\bf Round\+Up} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the nearest integer value to num (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode. \end{DoxyCompactList}\item 
static long {\bf Round\+Up} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the nearest integer value to num (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode. \end{DoxyCompactList}\item 
static long {\bf Round\+Up} (int num)
\begin{DoxyCompactList}\small\item\em Calculates the nearest integer value to num (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode. \end{DoxyCompactList}\item 
static void {\bf Show\+Message\+Box} (H\+W\+ND h\+Window, char $\ast$message, char $\ast$title=\char`\"{}Error\char`\"{})
\begin{DoxyCompactList}\small\item\em Displays a standard message box with a message, title, and an OK button. \end{DoxyCompactList}\item 
static void {\bf Show\+Message\+Box} (H\+W\+ND h\+Window, wchar\+\_\+t $\ast$message, wchar\+\_\+t $\ast$title=L\char`\"{}Error\char`\"{})
\begin{DoxyCompactList}\small\item\em Displays a standard message box with a message, title, and an OK button. \end{DoxyCompactList}\item 
static double {\bf Sin} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Sin in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Sin} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Sin in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Sin} (int num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Sin in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf SinH} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the SinH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf SinH} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the SinH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf SinH} (int num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the SinH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Smallest} (double num1, double num2)
\begin{DoxyCompactList}\small\item\em Calculates the smaller of the two values and returns the smaller one. \end{DoxyCompactList}\item 
static float {\bf Smallest} (float num1, float num2)
\begin{DoxyCompactList}\small\item\em Calculates the smaller of the two values and returns the smaller one. \end{DoxyCompactList}\item 
static int {\bf Smallest} (int num1, int num2)
\begin{DoxyCompactList}\small\item\em Calculates the smaller of the two values and returns the smaller one. \end{DoxyCompactList}\item 
static double {\bf Square\+Root} (double num)
\begin{DoxyCompactList}\small\item\em Returns the Square Root of the provided number. \end{DoxyCompactList}\item 
static float {\bf Square\+Root} (float num)
\begin{DoxyCompactList}\small\item\em Returns the Square Root of the provided number. \end{DoxyCompactList}\item 
static int {\bf Square\+Root} (int num)
\begin{DoxyCompactList}\small\item\em Returns the Square Root of the provided number. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Sub\+String} (char $\ast$str, int start\+Index, int up\+To\+But\+Not\+Including\+Index=I\+N\+T\+\_\+\+M\+AX)
\begin{DoxyCompactList}\small\item\em Returns a string containing the characters between start\+Index and up\+To\+But\+Not\+Including\+Index. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Sub\+String} (wchar\+\_\+t $\ast$str, int start\+Index, int up\+To\+But\+Not\+Including\+Index=I\+N\+T\+\_\+\+M\+AX)
\begin{DoxyCompactList}\small\item\em Returns a wide string containing the characters between start\+Index and up\+To\+But\+Not\+Including\+Index. \end{DoxyCompactList}\item 
static double {\bf Tan} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Tangent (Tan) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Tan} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Tangent (Tan) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Tan} (int num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Tangent (Tan) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf TanH} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates The Hyperbolic Tangent (TanH) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf TanH} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates The Hyperbolic Tangent (TanH) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf TanH} (int num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates The Hyperbolic Tangent (TanH) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static char $\ast$$\ast$ {\bf Tokenize} (char $\ast$str\+To\+Tokenize, char $\ast$delimiter, int \&out\+Num\+Tokens\+Found)
\begin{DoxyCompactList}\small\item\em Breaks up a string and returns an array of all the strings between each delimiter. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$$\ast$ {\bf Tokenize} (wchar\+\_\+t $\ast$str\+To\+Tokenize, wchar\+\_\+t $\ast$delimiter, int \&out\+Num\+Tokens\+Found)
\begin{DoxyCompactList}\small\item\em Breaks up a wide string and returns an array of all the wide strings between each delimiter. \end{DoxyCompactList}\item 
static double {\bf Truncate} (double num)
\begin{DoxyCompactList}\small\item\em Removes everything after the decimal point. \end{DoxyCompactList}\item 
static float {\bf Truncate} (float num)
\begin{DoxyCompactList}\small\item\em Removes everything after the decimal point. \end{DoxyCompactList}\item 
static double {\bf Two\+To\+The\+X\+Power} (double power)
\begin{DoxyCompactList}\small\item\em Calculates 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Two\+To\+The\+X\+Power} (float power)
\begin{DoxyCompactList}\small\item\em Calculates 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Two\+To\+The\+X\+Power} (int power)
\begin{DoxyCompactList}\small\item\em Calculates 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static bool {\bf Validate} (H\+W\+ND h\+Wnd, H\+R\+E\+S\+U\+LT result, char $\ast$message, char $\ast$title=\char`\"{}E\+R\+R\+OR\char`\"{})
\begin{DoxyCompactList}\small\item\em Returns false and displays an error window if result is an error (i.\+e. \end{DoxyCompactList}\item 
static bool {\bf Validate} (H\+W\+ND h\+Wnd, H\+R\+E\+S\+U\+LT result, wchar\+\_\+t $\ast$message, wchar\+\_\+t $\ast$title=L\char`\"{}E\+R\+R\+OR\char`\"{})
\begin{DoxyCompactList}\small\item\em Returns false and displays an error window if result is an error (i.\+e. \end{DoxyCompactList}\item 
static size\+\_\+t {\bf Write\+Text\+File} (char $\ast$file\+Path, char $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const char $\ast$mode=\char`\"{}w\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for writing and returns the number of items/elements written to the file. \end{DoxyCompactList}\item 
static size\+\_\+t {\bf Write\+Text\+FileW} (wchar\+\_\+t $\ast$file\+Path, wchar\+\_\+t $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const wchar\+\_\+t $\ast$mode=L\char`\"{}w, ccs=U\+TF-\/8\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for writing and returns the number of items/elements written to the file. \end{DoxyCompactList}\item 
static size\+\_\+t {\bf Write\+Binary\+File} (char $\ast$file\+Path, char $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const char $\ast$mode=\char`\"{}wb\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for writing and returns the number of items/elements written to the file. \end{DoxyCompactList}\item 
static size\+\_\+t {\bf Write\+Binary\+FileW} (wchar\+\_\+t $\ast$file\+Path, wchar\+\_\+t $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const wchar\+\_\+t $\ast$mode=L\char`\"{}wb, ccs=U\+TF-\/8\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for writing and returns the number of items/elements written to the file. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\index{Ace@{Ace}!\+\_\+\+Aligned\+\_\+\+Calloc@{\+\_\+\+Aligned\+\_\+\+Calloc}}
\index{\+\_\+\+Aligned\+\_\+\+Calloc@{\+\_\+\+Aligned\+\_\+\+Calloc}!Ace@{Ace}}
\subsubsection[{\+\_\+\+Aligned\+\_\+\+Calloc(size\+\_\+t size, size\+\_\+t alignment=\+B\+Y\+T\+E\+\_\+\+A\+L\+I\+G\+N\+M\+E\+N\+T)}]{\setlength{\rightskip}{0pt plus 5cm}void $\ast$ Ace\+::\+\_\+\+Aligned\+\_\+\+Calloc (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{size, }
\item[{size\+\_\+t}]{alignment = {\ttfamily {\bf B\+Y\+T\+E\+\_\+\+A\+L\+I\+G\+N\+M\+E\+NT}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac62e93783b52192c5f5649a389021d15}


Allocates a buffer of specified size and zeros it out. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
11/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* buffer = (\textcolor{keywordtype}{char}*)Ace::_Aligned_Calloc(1024);
    \textcolor{keywordflow}{if} (strcpy\_s(buffer, 1024, \textcolor{stringliteral}{"My name is Eddie and I like spaghetti."}) != 0)
    \{
        \textcolor{keywordflow}{throw} \textcolor{stringliteral}{"Error: Failed to copy string."};
    \}
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, buffer);
    \_aligned\_free(buffer);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:My name is Eddie and I like spaghetti.


\begin{DoxyParams}{Parameters}
{\em size} & The number of bytes to allocate. \\
\hline
{\em alignment} & The byte alignment of the buffer.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A zeroed out buffer of specified size. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Absolute\+Value@{Absolute\+Value}}
\index{Absolute\+Value@{Absolute\+Value}!Ace@{Ace}}
\subsubsection[{Absolute\+Value(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Absolute\+Value (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae1d25ce89a5152ac3dd591aa75c57764}


Calculates the absolute value of a number in compliance with C\+E\+RT Coding Standard. 

The absolute value is the positive version of value (example\+: $\vert$3-\/4$\vert$ = 1).

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} retVal = Ace::AbsoluteValue(-2.3);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+:2.\+300000


\begin{DoxyParams}{Parameters}
{\em num} & The number to use to determine the absolute value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The absolute value of num. 
\end{DoxyReturn}
\index{Ace@{Ace}!Absolute\+Value@{Absolute\+Value}}
\index{Absolute\+Value@{Absolute\+Value}!Ace@{Ace}}
\subsubsection[{Absolute\+Value(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Absolute\+Value (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae573ce4a06f6050b29e5c8ad3285b05c}


Calculates the absolute value of a number in compliance with C\+E\+RT Coding Standard. 

The absolute value is the positive version of value (example\+: $\vert$3-\/4$\vert$ = 1).

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} retVal = Ace::AbsoluteValue(-2.3f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+:2.\+300000


\begin{DoxyParams}{Parameters}
{\em num} & The number to use to determine the absolute value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The absolute value of num. 
\end{DoxyReturn}
\index{Ace@{Ace}!Absolute\+Value@{Absolute\+Value}}
\index{Absolute\+Value@{Absolute\+Value}!Ace@{Ace}}
\subsubsection[{Absolute\+Value(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Absolute\+Value (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a95446abd27b9b0dc33cc23e5f16ce80c}


Calculates the absolute value of a number in compliance with C\+E\+RT Coding Standard. 

The absolute value is the positive version of value (example\+: $\vert$3-\/4$\vert$ = 1).

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} retVal = Ace::AbsoluteValue(-2);
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+:2


\begin{DoxyParams}{Parameters}
{\em num} & The number to use to determine the absolute value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The absolute value of num. 
\end{DoxyReturn}
\index{Ace@{Ace}!Allocate\+And\+Copy\+String@{Allocate\+And\+Copy\+String}}
\index{Allocate\+And\+Copy\+String@{Allocate\+And\+Copy\+String}!Ace@{Ace}}
\subsubsection[{Allocate\+And\+Copy\+String(char $\ast$str\+To\+Copy)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Allocate\+And\+Copy\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae84033e0edc7822aa6a1cd3d6147dac8}


Allocates a buffer and copies a provided traditional string into the buffer. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
7/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* strToCopy = \textcolor{stringliteral}{"An eraser of love..."};
    \textcolor{keywordtype}{char}* buffer = Ace::AllocateAndCopyString(strToCopy);
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, buffer);
    \_aligned\_free(buffer);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:An eraser of love...


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Copy} & If non-\/null, to copy.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly allocated buffer containing str\+To\+Copy. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Allocate\+And\+Copy\+String@{Allocate\+And\+Copy\+String}}
\index{Allocate\+And\+Copy\+String@{Allocate\+And\+Copy\+String}!Ace@{Ace}}
\subsubsection[{Allocate\+And\+Copy\+String(wchar\+\_\+t $\ast$wide\+Str\+To\+Copy)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Allocate\+And\+Copy\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{wide\+Str\+To\+Copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7df3d37c864aaded3894cff9fcb72b71}


Allocates a buffer and copies a provided traditional wide string into the buffer. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
7/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* strToCopy = L\textcolor{stringliteral}{"An eraser of love..."};
    \textcolor{keywordtype}{wchar\_t}* buffer = Ace::AllocateAndCopyString(strToCopy);
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, buffer);
    \_aligned\_free(buffer);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:An eraser of love...


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em wide\+Str\+To\+Copy} & If non-\/null, the wide string to copy.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly allocated buffer containing wide\+Str\+To\+Copy. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Cos@{Arc\+Cos}}
\index{Arc\+Cos@{Arc\+Cos}!Ace@{Ace}}
\subsubsection[{Arc\+Cos(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+Cos (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aec125b75d04c5ae6b9ba3f77d9ae5303}


Calculates the Arc\+Cos in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/3/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
    \textcolor{keywordtype}{double} result = Ace::ArcCos(PI / 4.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+667457


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Cos for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Cos of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is not between -\/1 and 1, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Cos@{Arc\+Cos}}
\index{Arc\+Cos@{Arc\+Cos}!Ace@{Ace}}
\subsubsection[{Arc\+Cos(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+Cos (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa2cd7566162e0d739d730444a99b395a}


Calculates the Arc\+Cos in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{float} result = Ace::ArcCos(PI / 4.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+667457


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Cos for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Cos of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is not between -\/1 and 1, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Cos@{Arc\+Cos}}
\index{Arc\+Cos@{Arc\+Cos}!Ace@{Ace}}
\subsubsection[{Arc\+Cos(int num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Arc\+Cos (
\begin{DoxyParamCaption}
\item[{int}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a66666027006f17fc9c3f7e9dbcdca31c}


Calculates the Arc\+Cos in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{int} result = Ace::ArcCos((\textcolor{keywordtype}{int})(PI / 4));
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Cos for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Cos of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is not between -\/1 and 1, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+CosH@{Arc\+CosH}}
\index{Arc\+CosH@{Arc\+CosH}!Ace@{Ace}}
\subsubsection[{Arc\+Cos\+H(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+CosH (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6a6748b89eb74289306de8407d027865}


Calculates the Arc\+CosH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/3/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::ArcCosH(1.5);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+962424


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+CosH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+CosH of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is less than 1, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+CosH@{Arc\+CosH}}
\index{Arc\+CosH@{Arc\+CosH}!Ace@{Ace}}
\subsubsection[{Arc\+Cos\+H(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+CosH (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9dd265c30b097239527c32d37c6f268c}


Calculates the Arc\+CosH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::ArcCosH(1.5f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+962424


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+CosH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+CosH of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is less than 1, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+CosH@{Arc\+CosH}}
\index{Arc\+CosH@{Arc\+CosH}!Ace@{Ace}}
\subsubsection[{Arc\+Cos\+H(int num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Arc\+CosH (
\begin{DoxyParamCaption}
\item[{int}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac9ab8ad3ef4635e9e6fbdcece65d3ca3}


Calculates the Arc\+CosH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::ArcCosH(2);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+CosH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+CosH of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is less than 1, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Sin@{Arc\+Sin}}
\index{Arc\+Sin@{Arc\+Sin}!Ace@{Ace}}
\subsubsection[{Arc\+Sin(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+Sin (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6dda55fe05e7f2874f44e9347d64068a}


Calculates the Arc\+Sin in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
    \textcolor{keywordtype}{double} result = Ace::ArcSin(PI / 4.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+903339


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Sin for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Sin of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is less than or equal to -\/1 or num\+In\+Radians is greater then 1, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Sin@{Arc\+Sin}}
\index{Arc\+Sin@{Arc\+Sin}!Ace@{Ace}}
\subsubsection[{Arc\+Sin(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+Sin (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab254fa951c7846affad26371c3ff2a12}


Calculates the Arc\+Sin in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{float} result = Ace::ArcSin(PI / 4.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+903339


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Sin for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Sin of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is less than or equal to -\/1 or num\+In\+Radians is greater then 1, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Sin@{Arc\+Sin}}
\index{Arc\+Sin@{Arc\+Sin}!Ace@{Ace}}
\subsubsection[{Arc\+Sin(int num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Arc\+Sin (
\begin{DoxyParamCaption}
\item[{int}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac9949e901fb3b37f6a5ef715f64bedad}


Calculates the Arc\+Sin in compliance with C\+E\+RT Coding Standard. 

This function is useless but is provided for completeness.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{int} result = Ace::ArcSin((\textcolor{keywordtype}{int})(PI / 4));
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Sin for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Sin of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is less than or equal to -\/1 or num\+In\+Radians is greater then 1, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+SinH@{Arc\+SinH}}
\index{Arc\+SinH@{Arc\+SinH}!Ace@{Ace}}
\subsubsection[{Arc\+Sin\+H(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+SinH (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa4e43dbae9fc597031f96b6826077792}


Calculates the Arc\+SinH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
    \textcolor{keywordtype}{double} result = Ace::ArcSinH(PI / 4.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+721225


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+SinH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+SinH of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+SinH@{Arc\+SinH}}
\index{Arc\+SinH@{Arc\+SinH}!Ace@{Ace}}
\subsubsection[{Arc\+Sin\+H(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+SinH (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aff6eb5ec6b5bf00bc9dab3187c0e1a35}


Calculates the Arc\+SinH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{float} result = Ace::ArcSinH(PI / 4.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+721225


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+SinH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+SinH of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+SinH@{Arc\+SinH}}
\index{Arc\+SinH@{Arc\+SinH}!Ace@{Ace}}
\subsubsection[{Arc\+Sin\+H(int num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Arc\+SinH (
\begin{DoxyParamCaption}
\item[{int}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab7a0e8596cc49c67b49a7e4fbce347a1}


Calculates the Arc\+SinH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{int} result = Ace::ArcSinH((\textcolor{keywordtype}{int})(PI / 4.0f));
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+SinH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+SinH of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Tan@{Arc\+Tan}}
\index{Arc\+Tan@{Arc\+Tan}!Ace@{Ace}}
\subsubsection[{Arc\+Tan(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+Tan (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a34a530e5c9e7d179fa411cb182fd4b52}


Calculates the Arc\+Tan in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
    \textcolor{keywordtype}{double} result = Ace::ArcTan(PI / 4.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+665774


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Tan for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Tan of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Tan@{Arc\+Tan}}
\index{Arc\+Tan@{Arc\+Tan}!Ace@{Ace}}
\subsubsection[{Arc\+Tan(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+Tan (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2360cc88ef910ae6eff49033072e5273}


Calculates the Arc\+Tan in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{float} result = Ace::ArcTan(PI / 4.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+665774


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Tan for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Tan of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Tan@{Arc\+Tan}}
\index{Arc\+Tan@{Arc\+Tan}!Ace@{Ace}}
\subsubsection[{Arc\+Tan(int num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Arc\+Tan (
\begin{DoxyParamCaption}
\item[{int}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a04da515c1dc147c5a6141a5bab1c608d}


Calculates the Arc\+Tan in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{int} result = Ace::ArcTan((\textcolor{keywordtype}{int})(PI / 4));
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Tan for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Tan of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Tan2@{Arc\+Tan2}}
\index{Arc\+Tan2@{Arc\+Tan2}!Ace@{Ace}}
\subsubsection[{Arc\+Tan2(double y\+In\+Radians, double x\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+Tan2 (
\begin{DoxyParamCaption}
\item[{double}]{y, }
\item[{double}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ade721fa5fb6371e4ba4863413be468c2}


Calculates the Arc\+Tan2 in compliance with C\+E\+RT Coding Standard. 

To compute the value, the function takes into account the sign of both arguments in order to determine the quadrant.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::ArcTan2(-10.0, 5.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:-\/1.\+107149


\begin{DoxyParams}{Parameters}
{\em y} & Value representing the proportion of the y-\/coordinate. \\
\hline
{\em x} & Value representing the proportion of the x-\/coordinate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Arc Tangent of y/x, in radians. If y = 0 or x = 0, or a mathematical error occurs, an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Tan2@{Arc\+Tan2}}
\index{Arc\+Tan2@{Arc\+Tan2}!Ace@{Ace}}
\subsubsection[{Arc\+Tan2(float y\+In\+Radians, float x\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+Tan2 (
\begin{DoxyParamCaption}
\item[{float}]{y, }
\item[{float}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a212a9d7345151ebaa457c693b4f110c4}


Calculates the Arc\+Tan2 in compliance with C\+E\+RT Coding Standard. 

To compute the value, the function takes into account the sign of both arguments in order to determine the quadrant.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::ArcTan2(-10.0f, 5.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:-\/1.\+107149


\begin{DoxyParams}{Parameters}
{\em y} & Value representing the proportion of the y-\/coordinate. \\
\hline
{\em x} & Value representing the proportion of the x-\/coordinate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Arc Tangent of y/x, in radians. If y = 0 or x = 0, or a mathematical error occurs, an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Tan2@{Arc\+Tan2}}
\index{Arc\+Tan2@{Arc\+Tan2}!Ace@{Ace}}
\subsubsection[{Arc\+Tan2(int y\+In\+Radians, int x\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Arc\+Tan2 (
\begin{DoxyParamCaption}
\item[{int}]{y, }
\item[{int}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac1c5ca32711a1561fa374c42cd90e1eb}


Calculates the Arc\+Tan2 in compliance with C\+E\+RT Coding Standard. 

To compute the value, the function takes into account the sign of both arguments in order to determine the quadrant.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::ArcTan2(-10, 5);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0


\begin{DoxyParams}{Parameters}
{\em y} & Value representing the proportion of the y-\/coordinate. \\
\hline
{\em x} & Value representing the proportion of the x-\/coordinate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Arc Tangent of y/x, in radians. If y = 0 or x = 0, or a mathematical error occurs, an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+TanH@{Arc\+TanH}}
\index{Arc\+TanH@{Arc\+TanH}!Ace@{Ace}}
\subsubsection[{Arc\+Tan\+H(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+TanH (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab95c327492c783547e8c16c4dd9570d8}


Calculates the Arc\+TanH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/3/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
    \textcolor{keywordtype}{double} result = Ace::ArcTanH(PI / 4.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1.\+059306


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+TanH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+TanH of num\+In\+Radians. If a mathematical error occurs or if num\+In\+Radians is less than or equal to -\/1 or if num\+In\+Radians is greater than or equal to 1, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+TanH@{Arc\+TanH}}
\index{Arc\+TanH@{Arc\+TanH}!Ace@{Ace}}
\subsubsection[{Arc\+Tan\+H(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+TanH (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a3c43f19a4371770bbeacd76e8d8f5e24}


Calculates the Arc\+TanH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{float} result = Ace::ArcTanH(PI / 4.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1.\+059306


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+TanH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+TanH of num\+In\+Radians. If a mathematical error occurs or if num\+In\+Radians is less than or equal to -\/1 or if num\+In\+Radians is greater than or equal to 1, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+TanH@{Arc\+TanH}}
\index{Arc\+TanH@{Arc\+TanH}!Ace@{Ace}}
\subsubsection[{Arc\+Tan\+H(int num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Arc\+TanH (
\begin{DoxyParamCaption}
\item[{int}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_adc92293a6a095f73a8d7ec040f2a7c2c}


Calculates the Arc\+TanH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{int} result = Ace::ArcTanH((\textcolor{keywordtype}{int})(PI / 4));
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+TanH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+TanH of num\+In\+Radians. If a mathematical error occurs or if num\+In\+Radians is less than or equal to -\/1 or if num\+In\+Radians is greater than or equal to 1, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Calculate\+Aspect\+Ratio@{Calculate\+Aspect\+Ratio}}
\index{Calculate\+Aspect\+Ratio@{Calculate\+Aspect\+Ratio}!Ace@{Ace}}
\subsubsection[{Calculate\+Aspect\+Ratio(int new\+Width, int new\+Height, int original\+Width, int original\+Height, int \&out\+Adjusted\+Width, int \&out\+Adjusted\+Height)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Calculate\+Aspect\+Ratio (
\begin{DoxyParamCaption}
\item[{int}]{new\+Width, }
\item[{int}]{new\+Height, }
\item[{int}]{original\+Width, }
\item[{int}]{original\+Height, }
\item[{int \&}]{out\+Adjusted\+Width, }
\item[{int \&}]{out\+Adjusted\+Height}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a78d7a2c1c3c8da0fe6569d990375fc45}


Adjusts the resolution to the correct aspect ratio for the destination. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/18/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} outNewWidth;
    \textcolor{keywordtype}{int} outNewHeight;
    Ace::CalculateAspectRatio(1920, 1080, 1024, 768, outNewWidth, outNewHeight);
    printf(\textcolor{stringliteral}{"New Width:%d    New Height:%d\(\backslash\)n"}, outNewWidth, outNewHeight);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:New Width\+:1024 New Height\+:576


\begin{DoxyParams}[1]{Parameters}
 & {\em new\+Width} & The width for the image destination. \\
\hline
 & {\em new\+Height} & The height for the image destination. \\
\hline
 & {\em original\+Width} & The original width of the source. \\
\hline
 & {\em original\+Height} & The original height of the source. \\
\hline
\mbox{\tt out}  & {\em out\+Adjusted\+Width} & The calculated width. \\
\hline
\mbox{\tt out}  & {\em out\+Adjusted\+Height} & The calculated height.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if parameters are not in valid range. 
\end{DoxyReturn}
\index{Ace@{Ace}!Calculate\+File\+Size@{Calculate\+File\+Size}}
\index{Calculate\+File\+Size@{Calculate\+File\+Size}!Ace@{Ace}}
\subsubsection[{Calculate\+File\+Size(char $\ast$the\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}L\+O\+N\+G\+L\+O\+NG Ace\+::\+Calculate\+File\+Size (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{the\+File\+Path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a24687acdeab8af43507fea6467f29247}


Uses fseek() to calculate the size of the file by moving the file pointer to the end. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} fileSize = Ace::CalculateFileSize(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)dicks.txt"});
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, fileSize);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:37


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em the\+File} & A pointer to the File.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Size of the file in bytes. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Calculate\+File\+Size@{Calculate\+File\+Size}}
\index{Calculate\+File\+Size@{Calculate\+File\+Size}!Ace@{Ace}}
\subsubsection[{Calculate\+File\+Size(wchar\+\_\+t $\ast$the\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}L\+O\+N\+G\+L\+O\+NG Ace\+::\+Calculate\+File\+Size (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{the\+File\+Path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_adb5ff5f5dff024aa0d089bb2a018f8a7}


Gets the size of the file in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} fileSize = Ace::CalculateFileSize(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)dicks.txt"});
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, fileSize);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:37


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em the\+File\+Path} & The full file path.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Size of the file in bytes. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Calculate\+Num\+Length@{Calculate\+Num\+Length}}
\index{Calculate\+Num\+Length@{Calculate\+Num\+Length}!Ace@{Ace}}
\subsubsection[{Calculate\+Num\+Length(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Calculate\+Num\+Length (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0fb146fe350acee2d70c4357d1a3a5fc}


Counts the number of digits of num. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/23/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} numLength = Ace::CalculateNumLength(9999999);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, numLength);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:7


\begin{DoxyParams}{Parameters}
{\em num} & Number to count digits of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The length (number of digits) of a given num. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Calculate\+Num\+Length@{Calculate\+Num\+Length}}
\index{Calculate\+Num\+Length@{Calculate\+Num\+Length}!Ace@{Ace}}
\subsubsection[{Calculate\+Num\+Length(long num)}]{\setlength{\rightskip}{0pt plus 5cm}long Ace\+::\+Calculate\+Num\+Length (
\begin{DoxyParamCaption}
\item[{long}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad407659560b8f252d918f65548856ecf}


Counts the number of digits of num. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/23/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{long} num = 9999999;
    \textcolor{keywordtype}{long} numLength = Ace::CalculateNumLength(num);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, numLength);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:7


\begin{DoxyParams}{Parameters}
{\em num} & Number to count digits of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The length (number of digits) of a given num. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Ceiling@{Ceiling}}
\index{Ceiling@{Ceiling}!Ace@{Ace}}
\subsubsection[{Ceiling(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Ceiling (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab8cc0635c5777ced01f1cd35948bafa2}


Calculates the smallest integer value greater than or equal to num. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} retVal = Ace::Ceiling(1.01);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:2.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & The number to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The smallest integral value not less than num. Throws an exception if a mathematical error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Ceiling@{Ceiling}}
\index{Ceiling@{Ceiling}!Ace@{Ace}}
\subsubsection[{Ceiling(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Ceiling (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a00736bf27104bf30fa2f3c4a463657ab}


Calculates the smallest integer value greater than or equal to num. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} retVal = Ace::Ceiling(1.01f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:2.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & The number to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The smallest integral value not less than num. Throws an exception if a mathematical error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Ceiling@{Ceiling}}
\index{Ceiling@{Ceiling}!Ace@{Ace}}
\subsubsection[{Ceiling(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Ceiling (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aee38a314db9591a502a304c5548e7b33}


Calculates the smallest integer value greater than or equal to num. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} retVal = Ace::Ceiling(5);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:5


\begin{DoxyParams}{Parameters}
{\em num} & The number to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The smallest integral value not less than num. Throws an exception if a mathematical error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Char\+At@{Char\+At}}
\index{Char\+At@{Char\+At}!Ace@{Ace}}
\subsubsection[{Char\+At(char $\ast$str, int index)}]{\setlength{\rightskip}{0pt plus 5cm}char Ace\+::\+Char\+At (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str, }
\item[{int}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a63f81ff2236e723a0d84bd60dae9bb05}


Returns a single character in str at a specified index. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{char} temp = Ace::CharAt(data, 11);
    printf(\textcolor{stringliteral}{"%c"}, temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:e


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to search. \\
\hline
 & {\em index} & The (0 based) index of what character to get.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A single character from str. Throws an exception if str is N\+U\+LL or index is not in valid range. 
\end{DoxyReturn}
\index{Ace@{Ace}!Char\+At@{Char\+At}}
\index{Char\+At@{Char\+At}!Ace@{Ace}}
\subsubsection[{Char\+At(wchar\+\_\+t $\ast$str, int index)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t Ace\+::\+Char\+At (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str, }
\item[{int}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a10123c2253ad11233dfe03584aa279c5}


Returns a single character in str at a specified index. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{wchar\_t} temp = Ace::CharAt(data, 11);
    printf(\textcolor{stringliteral}{"%c"}, temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:e


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to search. \\
\hline
 & {\em index} & The (0 based) index of what character to get.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A single character from str. Throws an exception if str is N\+U\+LL or index is not in valid range. 
\end{DoxyReturn}
\index{Ace@{Ace}!Complementary\+Error\+Function@{Complementary\+Error\+Function}}
\index{Complementary\+Error\+Function@{Complementary\+Error\+Function}!Ace@{Ace}}
\subsubsection[{Complementary\+Error\+Function(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Complementary\+Error\+Function (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6905860b7a53563ab3c73b89e25160da}


Calculates the Complementary Error Function integral from num to infinity in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::ComplementaryErrorFunction(1.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+157299


\begin{DoxyParams}{Parameters}
{\em num} & The starting point for the integral.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of the Complementary Error Function integral. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Complementary\+Error\+Function@{Complementary\+Error\+Function}}
\index{Complementary\+Error\+Function@{Complementary\+Error\+Function}!Ace@{Ace}}
\subsubsection[{Complementary\+Error\+Function(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Complementary\+Error\+Function (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a611ec18e97b274af873f785a557808e7}


Calculates the Complementary Error Function integral from num to infinity in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::ComplementaryErrorFunction(1.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+157299


\begin{DoxyParams}{Parameters}
{\em num} & The starting point for the integral.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of the Complementary Error Function integral. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Complementary\+Error\+Function@{Complementary\+Error\+Function}}
\index{Complementary\+Error\+Function@{Complementary\+Error\+Function}!Ace@{Ace}}
\subsubsection[{Complementary\+Error\+Function(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Complementary\+Error\+Function (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af8879953b37dc809b179cc1f1db9f2a7}


Calculates the Complementary Error Function integral from num to infinity in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::ComplementaryErrorFunction(4);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0


\begin{DoxyParams}{Parameters}
{\em num} & The starting point for the integral.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of the Complementary Error Function integral. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Concatenate@{Concatenate}}
\index{Concatenate@{Concatenate}!Ace@{Ace}}
\subsubsection[{Concatenate(int num\+Strings,...)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Concatenate (
\begin{DoxyParamCaption}
\item[{int}]{num\+Strings, }
\item[{}]{...}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a54627c41eea2730839d98f33542a5492}


Appends a series of strings together. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* completeStr = Ace::Concatenate(3, \textcolor{stringliteral}{"Everything"}, \textcolor{stringliteral}{"Everything"}, \textcolor{stringliteral}{"Everything"});
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, completeStr);
    \_aligned\_free(completeStr);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Everything\+Everything\+Everything.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num\+Strings} & Number of strings to append. \\
\hline
\mbox{\tt in}  & {\em ...} & Variable arguments providing additional strings.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A combined string of all the strings in the arguments. Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Concatenate\+Strings@{Concatenate\+Strings}}
\index{Concatenate\+Strings@{Concatenate\+Strings}!Ace@{Ace}}
\subsubsection[{Concatenate\+Strings(int num\+Strings, char $\ast$$\ast$string\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Concatenate\+Strings (
\begin{DoxyParamCaption}
\item[{int}]{num\+Strings, }
\item[{char $\ast$$\ast$}]{string\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a940cef052ddd6f308129a20fa2489d03}


Appends an array of strings together and returns the combined string. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}** stringArray = (\textcolor{keywordtype}{char}**)\_aligned\_malloc(4 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}*), 16);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
    \{
        stringArray[currIndex] = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"Everything"});
    \}
    \textcolor{keywordtype}{char}* completeStr = Ace::ConcatenateStrings(4, stringArray);
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, completeStr);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
    \{
        \_aligned\_free(stringArray[currIndex]);
    \}
    \_aligned\_free(stringArray);
    \_aligned\_free(completeStr);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Everything\+Everything\+Everything\+Everything


\begin{DoxyParams}[1]{Parameters}
 & {\em num\+Strings} & Number of strings to append. \\
\hline
\mbox{\tt in}  & {\em string\+Array} & The array of strings to append.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A combined string of all the strings in the array. If an error occurs, an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Concatenate\+Strings@{Concatenate\+Strings}}
\index{Concatenate\+Strings@{Concatenate\+Strings}!Ace@{Ace}}
\subsubsection[{Concatenate\+Strings(int num\+Strings, wchar\+\_\+t $\ast$$\ast$string\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Concatenate\+Strings (
\begin{DoxyParamCaption}
\item[{int}]{num\+Strings, }
\item[{wchar\+\_\+t $\ast$$\ast$}]{string\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4d5ee021b1049844d690a884aa3beb31}


Appends an array of strings together and returns the combined string. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}** stringArray = (\textcolor{keywordtype}{wchar\_t}**)\_aligned\_malloc(4 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t}*), 16);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
    \{
        stringArray[currIndex] = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"Everything"});
    \}
    \textcolor{keywordtype}{wchar\_t}* completeStr = Ace::ConcatenateStrings(4, stringArray);
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, completeStr);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
    \{
        \_aligned\_free(stringArray[currIndex]);
    \}
    \_aligned\_free(stringArray);
    \_aligned\_free(completeStr);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Everything\+Everything\+Everything\+Everything


\begin{DoxyParams}[1]{Parameters}
 & {\em num\+Strings} & Number of strings to append. \\
\hline
\mbox{\tt in}  & {\em string\+Array} & The array of strings to append.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A combined string of all the strings in the array. If an error occurs, an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Concatenate\+Strings@{Concatenate\+Strings}}
\index{Concatenate\+Strings@{Concatenate\+Strings}!Ace@{Ace}}
\subsubsection[{Concatenate\+Strings(vector$<$ char $\ast$ $>$ string\+Vector\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Concatenate\+Strings (
\begin{DoxyParamCaption}
\item[{vector$<$ char $\ast$ $>$}]{string\+Vector\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8699d2d8921db243252650adde40c999}


Appends a vector array of strings together and returns the combined string. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    vector<char*> stringVectorArray;
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 1; currIndex <= 4; currIndex++)
    \{
        stringVectorArray.push\_back(\textcolor{stringliteral}{"Everything"});
    \}
    \textcolor{keywordtype}{char}* completeStr = Ace::ConcatenateStrings(stringVectorArray);
    printf(\textcolor{stringliteral}{"%s"}, completeStr);
    \_aligned\_free(completeStr);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Everything\+Everything\+Everything\+Everything.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em string\+Vector\+Array} & The vector array of strings to append.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A combined string of all the strings in the array. If an error occurs, an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Concatenate\+Strings@{Concatenate\+Strings}}
\index{Concatenate\+Strings@{Concatenate\+Strings}!Ace@{Ace}}
\subsubsection[{Concatenate\+Strings(vector$<$ wchar\+\_\+t $\ast$ $>$ string\+Vector\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Concatenate\+Strings (
\begin{DoxyParamCaption}
\item[{vector$<$ wchar\+\_\+t $\ast$ $>$}]{string\+Vector\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a061739b0be1e26fcf5fc84d09fa9bd5d}


Appends a vector array of wide strings together and returns the combined wide string. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    vector<wchar\_t*> stringVectorArray;
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 1; currIndex <= 4; currIndex++)
    \{
        stringVectorArray.push\_back(L\textcolor{stringliteral}{"Everything"});
    \}
    \textcolor{keywordtype}{wchar\_t}* completeStr = Ace::ConcatenateStrings(stringVectorArray);
    printf(\textcolor{stringliteral}{"%S"}, completeStr);
    \_aligned\_free(completeStr);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Everything\+Everything\+Everything\+Everything.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em string\+Vector\+Array} & The vector array of strings to append.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A combined string of all the strings in the array. If an error occurs, an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!ConcatenateW@{ConcatenateW}}
\index{ConcatenateW@{ConcatenateW}!Ace@{Ace}}
\subsubsection[{Concatenate\+W(int num\+Wide\+Strings,...)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+ConcatenateW (
\begin{DoxyParamCaption}
\item[{int}]{num\+Wide\+Strings, }
\item[{}]{...}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af0cd7dce3668bd1ee3e9f86b687caa5c}


Appends a series of strings together. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* completeStr = Ace::ConcatenateW(3, L\textcolor{stringliteral}{"Everything"}, L\textcolor{stringliteral}{"Everything"}, L\textcolor{stringliteral}{"Everything"});
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, completeStr);
    \_aligned\_free(completeStr);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Everything\+Everything\+Everything


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num\+Strings} & Number of strings to append. \\
\hline
\mbox{\tt in}  & {\em ...} & Variable arguments providing additional strings.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A combined string of all the strings in the arguments. Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Contains@{Contains}}
\index{Contains@{Contains}!Ace@{Ace}}
\subsubsection[{Contains(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Contains (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af8c652e46bc6729b5619d794101540a2}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns true if found. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/26/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{bool} result = Ace::Contains(\textcolor{stringliteral}{"My name is Eddie and I like cheese."}, \textcolor{stringliteral}{"Eddie"});
    \textcolor{keywordflow}{if} (result == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Contains the word."});
    \}
    \textcolor{keywordflow}{else}
    \{
        printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Does not contain the word."});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Contains the word.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str\+To\+Search contains str\+To\+Look\+For, false otherwise. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Contains@{Contains}}
\index{Contains@{Contains}!Ace@{Ace}}
\subsubsection[{Contains(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Contains (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac0c4f1f93bb980eaf627a1dde757765d}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns true if found. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{bool} result = Ace::Contains(L\textcolor{stringliteral}{"My name is Eddie and I like cheese."}, L\textcolor{stringliteral}{"Eddie"});
    \textcolor{keywordflow}{if} (result == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Contains the word."});
    \}
    \textcolor{keywordflow}{else}
    \{
        printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Does not contain the word."});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Contains the word.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & Wide String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & Wide String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str\+To\+Search contains str\+To\+Look\+For, false otherwise. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Contains\+Ignore\+Case@{Contains\+Ignore\+Case}}
\index{Contains\+Ignore\+Case@{Contains\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Contains\+Ignore\+Case(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Contains\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa1a0f98f4f52323b776c8da11d4af7f7}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns true if found. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/26/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{bool} result = Ace::ContainsIgnoreCase(\textcolor{stringliteral}{"My name is eddIe and I like cheese."}, \textcolor{stringliteral}{"EdDIe"});
    \textcolor{keywordflow}{if} (result == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Contains the word."});
    \}
    \textcolor{keywordflow}{else}
    \{
        printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Does not contain the word."});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Contains the word.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str\+To\+Search contains str\+To\+Look\+For, false otherwise. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Contains\+Ignore\+Case@{Contains\+Ignore\+Case}}
\index{Contains\+Ignore\+Case@{Contains\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Contains\+Ignore\+Case(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Contains\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a89a15437662eae89503cefc25e29a9f7}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns true if found. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{bool} result = Ace::ContainsIgnoreCase(L\textcolor{stringliteral}{"My name is eddIe and I like cheese."}, L\textcolor{stringliteral}{"EdDIe"});
    \textcolor{keywordflow}{if} (result == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Contains the word."});
    \}
    \textcolor{keywordflow}{else}
    \{
        printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Does not contain the word."});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Contains the word.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & Wide String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & Wide String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str\+To\+Search contains str\+To\+Look\+For, false otherwise. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+Double\+To\+Bool@{Convert\+Double\+To\+Bool}}
\index{Convert\+Double\+To\+Bool@{Convert\+Double\+To\+Bool}!Ace@{Ace}}
\subsubsection[{Convert\+Double\+To\+Bool(double num)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Convert\+Double\+To\+Bool (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac4b7f63b32227ae2c0313212e078946f}


By definition, false is equal to 0 and true is equal to anything but 0. 

In other words, any positive or negative number returns true, if num is 0 then false.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{bool} data = Ace::ConvertDoubleToBool(0.0);
\textcolor{keywordflow}{if} (data == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:false


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num} & The number to determine if true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true or false based on the value of num. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+Float\+To\+Bool@{Convert\+Float\+To\+Bool}}
\index{Convert\+Float\+To\+Bool@{Convert\+Float\+To\+Bool}!Ace@{Ace}}
\subsubsection[{Convert\+Float\+To\+Bool(float num)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Convert\+Float\+To\+Bool (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_add6c70c3e44ea2a474ac44db32a51227}


By definition, false is equal to 0 and true is equal to anything but 0. 

In other words, any positive or negative number returns true, if num is 0 then false.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{bool} data = Ace::ConvertFloatToBool(0.0f);
\textcolor{keywordflow}{if} (data == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:false


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num} & The number to determine if true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true or false based on the value of num. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+Int\+To\+Bool@{Convert\+Int\+To\+Bool}}
\index{Convert\+Int\+To\+Bool@{Convert\+Int\+To\+Bool}!Ace@{Ace}}
\subsubsection[{Convert\+Int\+To\+Bool(int num)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Convert\+Int\+To\+Bool (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aedf62dbbbeffecb146060a08a0fe07f7}


By definition, false is equal to 0 and true is equal to anything but 0. 

In other words, any positive or negative number returns true, if num is 0 then false.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{bool} data = Ace::ConvertIntToBool(0);
\textcolor{keywordflow}{if} (data == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:false


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num} & The number to determine if true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true or false based on the value of num. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+Int\+To\+String@{Convert\+Int\+To\+String}}
\index{Convert\+Int\+To\+String@{Convert\+Int\+To\+String}!Ace@{Ace}}
\subsubsection[{Convert\+Int\+To\+String(int integer\+To\+Convert)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Convert\+Int\+To\+String (
\begin{DoxyParamCaption}
\item[{int}]{integer\+To\+Convert}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a026d615c1e1dbbb977c66daae7e5d61e}


Returns a buffer containing the result of \+\_\+itoa\+\_\+s() using integer\+To\+Convert. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* str = Ace::ConvertIntToString(989969);
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, str);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:989969


\begin{DoxyParams}{Parameters}
{\em integer\+To\+Convert} & The integer to pass to \+\_\+itoa\+\_\+s().\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A buffer containing the converted integer\+To\+Convert. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+Int\+To\+Wide\+String@{Convert\+Int\+To\+Wide\+String}}
\index{Convert\+Int\+To\+Wide\+String@{Convert\+Int\+To\+Wide\+String}!Ace@{Ace}}
\subsubsection[{Convert\+Int\+To\+Wide\+String(int integer\+To\+Convert)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Convert\+Int\+To\+Wide\+String (
\begin{DoxyParamCaption}
\item[{int}]{integer\+To\+Convert}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a77c0f5efc3c9453e62d1fed8350970d1}


Returns a buffer containing the result of \+\_\+itow\+\_\+s() using integer\+To\+Convert. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* str = Ace::ConvertIntToWideString(989969);
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, str);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:989969


\begin{DoxyParams}{Parameters}
{\em integer\+To\+Convert} & The integer to pass to \+\_\+itow\+\_\+s().\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A buffer containing the converted integer\+To\+Convert. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+Array\+To\+String\+Vector\+Array@{Convert\+String\+Array\+To\+String\+Vector\+Array}}
\index{Convert\+String\+Array\+To\+String\+Vector\+Array@{Convert\+String\+Array\+To\+String\+Vector\+Array}!Ace@{Ace}}
\subsubsection[{Convert\+String\+Array\+To\+String\+Vector\+Array(char $\ast$$\ast$string\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ char $\ast$ $>$ Ace\+::\+Convert\+String\+Array\+To\+String\+Vector\+Array (
\begin{DoxyParamCaption}
\item[{char $\ast$$\ast$}]{string\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ace7ef8961e95078c69f2058025960c09}


Converts a traditional string array to a vector string array. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}** strArray = (\textcolor{keywordtype}{char}**)\_aligned\_malloc(4 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}*), 16);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
    \{
        strArray[currIndex] = (\textcolor{keywordtype}{char}*)\_aligned\_malloc(32 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}), 16);
        memset(strArray[currIndex], 0, 32 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}));
        \_itoa\_s(currIndex, strArray[currIndex], 32, 10);
    \}
    vector<char*> stringVectorArray = Ace::ConvertStringArrayToStringVectorArray(strArray);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
    \{
        printf(\textcolor{stringliteral}{"strVectorArray[%d]:%s\(\backslash\)n"}, currIndex, stringVectorArray[currIndex]);
        \_aligned\_free(strArray[currIndex]);
    \}
    \_aligned\_free(strArray);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:str\+Vector\+Array[0]\+:0 str\+Vector\+Array[1]\+:1 str\+Vector\+Array[2]\+:2 str\+Vector\+Array[3]\+:3


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em string\+Array} & The string array to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A string vector array. If string\+Array is N\+U\+LL, an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+Array\+To\+String\+Vector\+Array@{Convert\+String\+Array\+To\+String\+Vector\+Array}}
\index{Convert\+String\+Array\+To\+String\+Vector\+Array@{Convert\+String\+Array\+To\+String\+Vector\+Array}!Ace@{Ace}}
\subsubsection[{Convert\+String\+Array\+To\+String\+Vector\+Array(wchar\+\_\+t $\ast$$\ast$string\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ wchar\+\_\+t $\ast$ $>$ Ace\+::\+Convert\+String\+Array\+To\+String\+Vector\+Array (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$$\ast$}]{string\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_afdfed76bad657496dd0b9d18e887048b}


Converts a traditional wide string array to a vector wide string array. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}** strArray = (\textcolor{keywordtype}{wchar\_t}**)\_aligned\_malloc(4 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t}*), 16);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
    \{
        strArray[currIndex] = (\textcolor{keywordtype}{wchar\_t}*)\_aligned\_malloc(32 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t}), 16);
        memset(strArray[currIndex], 0, 32 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t}));
        \_itow\_s(currIndex, strArray[currIndex], 32, 10);
    \}
    vector<wchar\_t*> stringVectorArray = 
      Ace::ConvertStringArrayToStringVectorArray(strArray);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
    \{
        printf(\textcolor{stringliteral}{"strVectorArray[%d]:%S\(\backslash\)n"}, currIndex, stringVectorArray[currIndex]);
        \_aligned\_free(strArray[currIndex]);
    \}
    \_aligned\_free(strArray);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:str\+Vector\+Array[0]\+:0 str\+Vector\+Array[1]\+:1 str\+Vector\+Array[2]\+:2 str\+Vector\+Array[3]\+:3


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em string\+Array} & The wide string array to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A wide string vector array. If string\+Array is N\+U\+LL, an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+Bool@{Convert\+String\+To\+Bool}}
\index{Convert\+String\+To\+Bool@{Convert\+String\+To\+Bool}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+Bool(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Convert\+String\+To\+Bool (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9399ba5c75c6aa92dac1a8d1d9f4af61}


Converts a given string to a bool, If str is a string like \char`\"{}\+False\char`\"{}, \char`\"{}\+F\+A\+L\+S\+E\char`\"{}, or \char`\"{}t\+Ru\+E\char`\"{}, then the function will return false, false, true respectively. 

If str is an integer for example; \char`\"{}0\char`\"{} will return false and any other number will return true.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{bool} data = Ace::ConvertStringToBool(\textcolor{stringliteral}{"tRuE"});
    \textcolor{keywordflow}{if} (data == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
    \}
    \textcolor{keywordflow}{else}
    \{
        printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str is equal to \char`\"{}true\char`\"{} (any case combination) or if str is an integer not equal to 0; false otherwise. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+Bool@{Convert\+String\+To\+Bool}}
\index{Convert\+String\+To\+Bool@{Convert\+String\+To\+Bool}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+Bool(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Convert\+String\+To\+Bool (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7b8a182a0d284265930026487405653a}


Converts a given wide string to a bool, If str is a wide string like \char`\"{}\+False\char`\"{}, \char`\"{}\+F\+A\+L\+S\+E\char`\"{}, or \char`\"{}t\+Ru\+E\char`\"{}, then the function will return false, false, true respectively. 

If str is an integer for example; \char`\"{}0\char`\"{} will return false and any other number will return true.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{bool} data = Ace::ConvertStringToBool(\textcolor{stringliteral}{"tRuE"});
    \textcolor{keywordflow}{if} (data == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%S"}, \textcolor{stringliteral}{"true"});
    \}
    \textcolor{keywordflow}{else}
    \{
        printf(\textcolor{stringliteral}{"%S"}, \textcolor{stringliteral}{"false"});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & Wide String to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str is equal to \char`\"{}true\char`\"{} (any case combination) or if str is an integer not equal to 0; false otherwise. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+Float\+Array@{Convert\+String\+To\+Float\+Array}}
\index{Convert\+String\+To\+Float\+Array@{Convert\+String\+To\+Float\+Array}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+Float\+Array(char $\ast$str\+To\+Convert, char $\ast$delimiter, int \&out\+Num\+Items)}]{\setlength{\rightskip}{0pt plus 5cm}float $\ast$ Ace\+::\+Convert\+String\+To\+Float\+Array (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Convert, }
\item[{char $\ast$}]{delimiter, }
\item[{int \&}]{out\+Num\+Items}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2dd19dedc9fa4b83a8db2115fc3b65bb}


Converts a tokenized string (a string with commas separating numbers for example) to an array of floats. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/26/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} numItems = 0;
    \textcolor{keywordtype}{char}* strPosition = \textcolor{stringliteral}{"0.0, 1.0f, 2.0"};
    \textcolor{keywordtype}{float}* floatArray = Ace::ConvertStringToFloatArray(strPosition, \textcolor{stringliteral}{","}, numItems);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < numItems; currIndex++)
    \{
        printf(\textcolor{stringliteral}{"floatArray[%d]: %f\(\backslash\)n"}, currIndex, floatArray[currIndex]);
    \}
    \_aligned\_free(floatArray);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:float\+Array[0]\+: 0.\+000000 float\+Array[1]\+: 1.\+000000 float\+Array[2]\+: 2.\+000000


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Convert} & String to convert. \\
\hline
\mbox{\tt in}  & {\em delimiter} & String that separates each number. \\
\hline
\mbox{\tt out}  & {\em out\+Num\+Items} & Size of the array.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly allocated array of floats. Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+Float\+Array@{Convert\+String\+To\+Float\+Array}}
\index{Convert\+String\+To\+Float\+Array@{Convert\+String\+To\+Float\+Array}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+Float\+Array(wchar\+\_\+t $\ast$str\+To\+Convert, wchar\+\_\+t $\ast$delimiter, int \&out\+Num\+Items)}]{\setlength{\rightskip}{0pt plus 5cm}float $\ast$ Ace\+::\+Convert\+String\+To\+Float\+Array (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Convert, }
\item[{wchar\+\_\+t $\ast$}]{delimiter, }
\item[{int \&}]{out\+Num\+Items}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a561b5633460e1f395b6e6fd12ab455f5}


Converts a tokenized wide string (a string with commas separating numbers for example) to an array of floats. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} numItems = 0;
    \textcolor{keywordtype}{wchar\_t}* strPosition = L\textcolor{stringliteral}{"0.0, 1.0f, 2.0"};
    \textcolor{keywordtype}{float}* floatArray = Ace::ConvertStringToFloatArray(strPosition, L\textcolor{stringliteral}{","}, numItems);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < numItems; currIndex++)
    \{
        printf(\textcolor{stringliteral}{"floatArray[%d]: %f\(\backslash\)n"}, currIndex, floatArray[currIndex]);
    \}
    \_aligned\_free(floatArray);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:float\+Array[0]\+: 0.\+000000 float\+Array[1]\+: 1.\+000000 float\+Array[2]\+: 2.\+000000


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Convert} & String to convert. \\
\hline
\mbox{\tt in}  & {\em delimiter} & String that separates each number. \\
\hline
\mbox{\tt out}  & {\em out\+Num\+Items} & Size of the array.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly allocated array of floats. Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+Hex@{Convert\+String\+To\+Hex}}
\index{Convert\+String\+To\+Hex@{Convert\+String\+To\+Hex}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+Hex(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int Ace\+::\+Convert\+String\+To\+Hex (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9735962c53182de52caffda3b7dd091f}


Converts a string to its hex value. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} data = Ace::ConvertStringToHex(\textcolor{stringliteral}{"0xDEADBEEF"});
printf(\textcolor{stringliteral}{"Hex Value: %x\(\backslash\)n"}, data);
printf(\textcolor{stringliteral}{"Integer Value: %u\(\backslash\)n"}, data);
\end{DoxyCode}
 Output\+:Hex Value\+: deadbeef Integer Value\+: 305419896.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to convert to hex.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The hex value of the string. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+Hex@{Convert\+String\+To\+Hex}}
\index{Convert\+String\+To\+Hex@{Convert\+String\+To\+Hex}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+Hex(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int Ace\+::\+Convert\+String\+To\+Hex (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa575665aa3bc6f2366fabd3bdec04e25}


Converts a string to its hex value. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} data = Ace::ConvertStringToHex(L\textcolor{stringliteral}{"0xDEADBEEF"});
printf(\textcolor{stringliteral}{"Hex Value: %x\(\backslash\)n"}, data);
printf(\textcolor{stringliteral}{"Integer Value: %u\(\backslash\)n"}, data);
\end{DoxyCode}
 Output\+:Hex Value\+: deadbeef Integer Value\+: 305419896.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to convert to hex.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The hex value of the string. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+One\+Line@{Convert\+String\+To\+One\+Line}}
\index{Convert\+String\+To\+One\+Line@{Convert\+String\+To\+One\+Line}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+One\+Line(char $\ast$str\+To\+Convert)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Convert\+String\+To\+One\+Line (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Convert}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a27a4d4bc0cfe1b489582bf937e27d0e1}


Converts a traditional string to a traditional string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/12/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Krusty\(\backslash\)nKrab\(\backslash\)nUn-Fair\(\backslash\)n!"};
    \textcolor{keywordtype}{char}* oneLineData = Ace::ConvertStringToOneLine(data);
    printf(\textcolor{stringliteral}{"%s"}, oneLineData);
    \_aligned\_free(oneLineData);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Krusty\+Krab\+Un-\/\+Fair!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Convert} & The string to convert to one line.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A string with every occurrence of ~\newline
 removed. Throws an exception if str\+To\+Convert is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+One\+Line@{Convert\+String\+To\+One\+Line}}
\index{Convert\+String\+To\+One\+Line@{Convert\+String\+To\+One\+Line}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+One\+Line(wchar\+\_\+t $\ast$str\+To\+Convert)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Convert\+String\+To\+One\+Line (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Convert}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a41c562a99b2eae02bed5d5c76b5ab8d9}


Converts a traditional wide string to a traditional wide string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Krusty\(\backslash\)nKrab\(\backslash\)nUn-Fair\(\backslash\)n!"};
    \textcolor{keywordtype}{wchar\_t}* oneLineData = Ace::ConvertStringToOneLine(data);
    printf(\textcolor{stringliteral}{"%S"}, oneLineData);
    \_aligned\_free(oneLineData);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Krusty\+Krab\+Un-\/\+Fair!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Convert} & The wide string to convert to one line.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A wide string with every occurrence of ~\newline
 removed. Throws an exception if str\+To\+Convert is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+One\+Line\+In\+Place@{Convert\+String\+To\+One\+Line\+In\+Place}}
\index{Convert\+String\+To\+One\+Line\+In\+Place@{Convert\+String\+To\+One\+Line\+In\+Place}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+One\+Line\+In\+Place(char $\ast$str\+To\+Convert)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Convert\+String\+To\+One\+Line\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Convert}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4ad8d96d9b8bad51a4364ae67fce4b73}


Converts a traditional string to a traditional string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. 

str\+To\+Convert must be an allocated string since this function works directly on it.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/12/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* oneLineData = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"Krusty\(\backslash\)nKrab\(\backslash\)nUn-Fair\(\backslash\)n!"});
    Ace::ConvertStringToOneLineInPlace(oneLineData);
    printf(\textcolor{stringliteral}{"%s"}, oneLineData);
    \_aligned\_free(oneLineData);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Krusty\+Krab\+Un-\/\+Fair!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Convert} & The string to directly convert to one line. Throws an exception if str\+To\+Convert is N\+U\+LL. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Convert\+String\+To\+One\+Line\+In\+Place@{Convert\+String\+To\+One\+Line\+In\+Place}}
\index{Convert\+String\+To\+One\+Line\+In\+Place@{Convert\+String\+To\+One\+Line\+In\+Place}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+One\+Line\+In\+Place(wchar\+\_\+t $\ast$str\+To\+Convert)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Convert\+String\+To\+One\+Line\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Convert}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6ab37e5c15b1cc6595fb2865c7fc12b1}


Converts a traditional wide string to a traditional wide string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. 

str\+To\+Convert must be an allocated wide string since this function works directly on it.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* oneLineData = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"Krusty\(\backslash\)nKrab\(\backslash\)nUn-Fair\(\backslash\)n!"});
    Ace::ConvertStringToOneLineInPlace(oneLineData);
    printf(\textcolor{stringliteral}{"%S"}, oneLineData);
    \_aligned\_free(oneLineData);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Krusty\+Krab\+Un-\/\+Fair!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Convert} & The wide string to directly convert to one line. Throws an exception if str\+To\+Convert is N\+U\+LL. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Convert\+String\+To\+W\+Char\+String@{Convert\+String\+To\+W\+Char\+String}}
\index{Convert\+String\+To\+W\+Char\+String@{Convert\+String\+To\+W\+Char\+String}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+W\+Char\+String(const char $\ast$str\+To\+Convert)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Convert\+String\+To\+W\+Char\+String (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{str\+To\+Convert}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_adebec5fecf3c418346f7e7233cac91f7}


Converts a traditional string to a wide string. 

A wide string is a string containing Unicode characters (non English).

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/25/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* normalString = \textcolor{stringliteral}{"The ceiling is right Squidward."};
    \textcolor{keywordtype}{wchar\_t}* wideString = Ace::ConvertStringToWCharString(normalString);
    printf(\textcolor{stringliteral}{"Wide string: %S\(\backslash\)n"}, wideString);
    \_aligned\_free(wideString);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Wide string\+: The ceiling is right Squidward.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Convert} & The string to convert to a wide string.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The string converted to wide character string. Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+Vector\+Array\+To\+String\+Array@{Convert\+String\+Vector\+Array\+To\+String\+Array}}
\index{Convert\+String\+Vector\+Array\+To\+String\+Array@{Convert\+String\+Vector\+Array\+To\+String\+Array}!Ace@{Ace}}
\subsubsection[{Convert\+String\+Vector\+Array\+To\+String\+Array(vector$<$ char $\ast$ $>$ string\+Vector\+Array, int \&out\+String\+Array\+Length)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$$\ast$ Ace\+::\+Convert\+String\+Vector\+Array\+To\+String\+Array (
\begin{DoxyParamCaption}
\item[{vector$<$ char $\ast$ $>$}]{string\+Vector\+Array, }
\item[{int \&}]{out\+String\+Array\+Length}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a3e82ab0d2c6c04e8bea91b0b7dbaae57}


Converts a string vector array to a traditional string array. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    vector<char*> strVectorArray;
    strVectorArray.push\_back(\textcolor{stringliteral}{"My"});
    strVectorArray.push\_back(\textcolor{stringliteral}{"name"});
    strVectorArray.push\_back(\textcolor{stringliteral}{"is"});
    strVectorArray.push\_back(\textcolor{stringliteral}{"Eddie."});
    \textcolor{keywordtype}{int} numStrs = strVectorArray.size();
    \textcolor{keywordtype}{char}** strArray = Ace::ConvertStringVectorArrayToStringArray(strVectorArray, numStrs);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < numStrs; currIndex++)
    \{
        printf(\textcolor{stringliteral}{"Array[%d]:%s\(\backslash\)n"}, currIndex, strArray[currIndex]);
        \_aligned\_free(strArray[currIndex]);
    \}
    \_aligned\_free(strArray);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Array[0]\+:My Array[1]\+:name Array[2]\+:is Array[3]\+:Eddie.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em string\+Vector\+Array} & The string vector array to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created traditional string array. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+Vector\+Array\+To\+String\+Array@{Convert\+String\+Vector\+Array\+To\+String\+Array}}
\index{Convert\+String\+Vector\+Array\+To\+String\+Array@{Convert\+String\+Vector\+Array\+To\+String\+Array}!Ace@{Ace}}
\subsubsection[{Convert\+String\+Vector\+Array\+To\+String\+Array(vector$<$ wchar\+\_\+t $\ast$ $>$ string\+Vector\+Array, int \&out\+String\+Array\+Length)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$$\ast$ Ace\+::\+Convert\+String\+Vector\+Array\+To\+String\+Array (
\begin{DoxyParamCaption}
\item[{vector$<$ wchar\+\_\+t $\ast$ $>$}]{string\+Vector\+Array, }
\item[{int \&}]{out\+String\+Array\+Length}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a32782e08dab2e556214a2506ca11be6b}


Converts a wide string vector array to a traditional wide string array. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    vector<wchar\_t*> strVectorArray;
    strVectorArray.push\_back(L\textcolor{stringliteral}{"My"});
    strVectorArray.push\_back(L\textcolor{stringliteral}{"name"});
    strVectorArray.push\_back(L\textcolor{stringliteral}{"is"});
    strVectorArray.push\_back(L\textcolor{stringliteral}{"Eddie."});
    \textcolor{keywordtype}{int} numStrs = strVectorArray.size();
    \textcolor{keywordtype}{wchar\_t}** strArray = Ace::ConvertStringVectorArrayToStringArray(strVectorArray, numStrs);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < numStrs; currIndex++)
    \{
        printf(\textcolor{stringliteral}{"Array[%d]:%S\(\backslash\)n"}, currIndex, strArray[currIndex]);
        \_aligned\_free(strArray[currIndex]);
    \}
    \_aligned\_free(strArray);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Array[0]\+:My Array[1]\+:name Array[2]\+:is Array[3]\+:Eddie.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em string\+Vector\+Array} & The string vector array to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created traditional string array. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Lower\+Case@{Convert\+To\+Lower\+Case}}
\index{Convert\+To\+Lower\+Case@{Convert\+To\+Lower\+Case}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Lower\+Case(char character)}]{\setlength{\rightskip}{0pt plus 5cm}char Ace\+::\+Convert\+To\+Lower\+Case (
\begin{DoxyParamCaption}
\item[{char}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a860b03a8bd162798dbc1dbeabbb785e1}


Converts a character to lowercase. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char} retVal = Ace::ConvertToLowerCase(\textcolor{charliteral}{'A'});
printf(\textcolor{stringliteral}{"%c"}, retVal);
\end{DoxyCode}
 Output\+:a


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & The character to convert to lowercase.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted character. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Lower\+Case@{Convert\+To\+Lower\+Case}}
\index{Convert\+To\+Lower\+Case@{Convert\+To\+Lower\+Case}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Lower\+Case(wchar\+\_\+t character)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t Ace\+::\+Convert\+To\+Lower\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a08800460d6c21d535902410e0daf44ad}


Converts a wide character to lowercase. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t} retVal = Ace::ConvertToLowerCase(L\textcolor{charliteral}{'A'});
printf(\textcolor{stringliteral}{"%c"}, retVal);
\end{DoxyCode}
 Output\+:a


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & The wide character to convert to lowercase.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted character. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Lower\+Case@{Convert\+To\+Lower\+Case}}
\index{Convert\+To\+Lower\+Case@{Convert\+To\+Lower\+Case}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Lower\+Case(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Convert\+To\+Lower\+Case (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a28cad743308ecbc46147e0203e2b14f3}


Converts a string to all lowercase letters. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = Ace::ConvertToLowerCase(\textcolor{stringliteral}{"ABCDEF"});
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:abcdef


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to determine if true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true or false based on the value of str. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Lower\+Case@{Convert\+To\+Lower\+Case}}
\index{Convert\+To\+Lower\+Case@{Convert\+To\+Lower\+Case}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Lower\+Case(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Convert\+To\+Lower\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aebe68e4280058616f63de68936cee206}


Converts a wide string to all lowercase letters. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = Ace::ConvertToLowerCase(L\textcolor{stringliteral}{"ABCDEF"});
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:abcdef


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to determine if true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true or false based on the value of str. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Lower\+Case\+In\+Place@{Convert\+To\+Lower\+Case\+In\+Place}}
\index{Convert\+To\+Lower\+Case\+In\+Place@{Convert\+To\+Lower\+Case\+In\+Place}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Lower\+Case\+In\+Place(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Convert\+To\+Lower\+Case\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a040b39d22ec0282b5a4185aba3e37633}


Directly modifies str to have all its letters converted to lower case. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"ABCDEF"});
    Ace::ConvertToLowerCaseInPlace(data);
    printf(\textcolor{stringliteral}{"%s"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:abcdef


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str} & The string to determine if true or false. Throws an exception if str is N\+U\+LL. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Convert\+To\+Lower\+Case\+In\+Place@{Convert\+To\+Lower\+Case\+In\+Place}}
\index{Convert\+To\+Lower\+Case\+In\+Place@{Convert\+To\+Lower\+Case\+In\+Place}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Lower\+Case\+In\+Place(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Convert\+To\+Lower\+Case\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a756a560a676102e318b403f4cd12a750}


Directly modifies str to have all its letters converted to lower case. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"ABCDEF"});
    Ace::ConvertToLowerCaseInPlace(data);
    printf(\textcolor{stringliteral}{"%S"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:abcdef


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str} & The wide string to determine if true or false. Throws an exception if str is N\+U\+LL. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Convert\+To\+Upper\+Case@{Convert\+To\+Upper\+Case}}
\index{Convert\+To\+Upper\+Case@{Convert\+To\+Upper\+Case}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Upper\+Case(char character)}]{\setlength{\rightskip}{0pt plus 5cm}char Ace\+::\+Convert\+To\+Upper\+Case (
\begin{DoxyParamCaption}
\item[{char}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a658e886d648a545b26d684545ad81146}


Converts a character to uppercase. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char} retVal = Ace::ConvertToUpperCase(\textcolor{charliteral}{'a'});
printf(\textcolor{stringliteral}{"%c"}, retVal);
\end{DoxyCode}
 Output\+:A


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & The character to convert to uppercase.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted character. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Upper\+Case@{Convert\+To\+Upper\+Case}}
\index{Convert\+To\+Upper\+Case@{Convert\+To\+Upper\+Case}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Upper\+Case(wchar\+\_\+t character)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t Ace\+::\+Convert\+To\+Upper\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af15839dea3c42e2b18987078149ce4e1}


Converts a wide character to uppercase. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t} retVal = Ace::ConvertToUpperCase(\textcolor{charliteral}{'a'});
printf(\textcolor{stringliteral}{"%c"}, retVal);
\end{DoxyCode}
 Output\+:A


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & The wide character to convert to uppercase.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The converted character. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Upper\+Case@{Convert\+To\+Upper\+Case}}
\index{Convert\+To\+Upper\+Case@{Convert\+To\+Upper\+Case}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Upper\+Case(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Convert\+To\+Upper\+Case (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a06f1154d2ce1775f53931aaf94c93f99}


Converts a string to all uppercase letters. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = Ace::ConvertToUpperCase(\textcolor{stringliteral}{"abcdef"});
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:A\+B\+C\+D\+EF


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to determine if true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string containing all the letters in str in uppercase. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Upper\+Case@{Convert\+To\+Upper\+Case}}
\index{Convert\+To\+Upper\+Case@{Convert\+To\+Upper\+Case}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Upper\+Case(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Convert\+To\+Upper\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a1fc45db42de7183ab5ec93a90a3f8cc7}


Converts a string to all uppercase letters. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = Ace::ConvertToUpperCase(L\textcolor{stringliteral}{"abcdef"});
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:A\+B\+C\+D\+EF


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to determine if true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string containing all the letters in str in uppercase. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Upper\+Case\+In\+Place@{Convert\+To\+Upper\+Case\+In\+Place}}
\index{Convert\+To\+Upper\+Case\+In\+Place@{Convert\+To\+Upper\+Case\+In\+Place}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Upper\+Case\+In\+Place(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Convert\+To\+Upper\+Case\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4ce18b5ec8b3acce9219938b2d07af0b}


Directly modifies str to have all its letters converted to upper case. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"abcdef"});
    Ace::ConvertToUpperCaseInPlace(data);
    printf(\textcolor{stringliteral}{"%s"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:A\+B\+C\+D\+EF


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to convert to all uppercase letters. Throws an exception if str is N\+U\+LL. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Convert\+To\+Upper\+Case\+In\+Place@{Convert\+To\+Upper\+Case\+In\+Place}}
\index{Convert\+To\+Upper\+Case\+In\+Place@{Convert\+To\+Upper\+Case\+In\+Place}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Upper\+Case\+In\+Place(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Convert\+To\+Upper\+Case\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab11cca7bc0da989b9bf6bd1158601fdd}


Directly modifies str to have all its letters converted to upper case. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"abcdef"});
    Ace::ConvertToUpperCaseInPlace(data);
    printf(\textcolor{stringliteral}{"%S"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:A\+B\+C\+D\+EF


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to convert to all uppercase letters. Throws an exception if str is N\+U\+LL. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Cos@{Cos}}
\index{Cos@{Cos}!Ace@{Ace}}
\subsubsection[{Cos(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Cos (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a59f079afef33f0a7bed749afbf777c36}


Calculates the Cosine (cos) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265358979;
    \textcolor{keywordtype}{double} retVal = Ace::Cos(PI / 4.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+707107


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & The number in radians to take the cosine of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The cosine of the num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Cos@{Cos}}
\index{Cos@{Cos}!Ace@{Ace}}
\subsubsection[{Cos(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Cos (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a55bebe92cca4c2a94f2cb30431475dea}


Calculates the Cosine (cos) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{float} retVal = Ace::Cos(PI / 4.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+707107


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & The number in radians to take the cosine of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The cosine of the num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Cos@{Cos}}
\index{Cos@{Cos}!Ace@{Ace}}
\subsubsection[{Cos(int num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Cos (
\begin{DoxyParamCaption}
\item[{int}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae4b36926f4c9c139490aee29a573aab1}


Calculates the Cosine (cos) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{int} retVal = Ace::Cos((\textcolor{keywordtype}{int})(PI / 4));
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & The number in radians to take the cosine of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The cosine of the num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!CosH@{CosH}}
\index{CosH@{CosH}!Ace@{Ace}}
\subsubsection[{Cos\+H(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+CosH (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2a3e08791d5a9e794a02c118daca3402}


Calculates the CosH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
    \textcolor{keywordtype}{double} result = Ace::CosH(PI / 4.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1.\+324609


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate CosH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The CosH of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!CosH@{CosH}}
\index{CosH@{CosH}!Ace@{Ace}}
\subsubsection[{Cos\+H(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+CosH (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a428056578b18e534a419d4fde48c1fef}


Calculates the CosH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{float} result = Ace::CosH(PI / 4.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1.\+324609


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate CosH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The CosH of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!CosH@{CosH}}
\index{CosH@{CosH}!Ace@{Ace}}
\subsubsection[{Cos\+H(int num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+CosH (
\begin{DoxyParamCaption}
\item[{int}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a3b2785b43c3dece0e026b6afe7815ab1}


Calculates the CosH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{int} result = Ace::CosH((\textcolor{keywordtype}{int})(PI / 4));
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate CosH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The CosH of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Count\+Num\+Occurrences@{Count\+Num\+Occurrences}}
\index{Count\+Num\+Occurrences@{Count\+Num\+Occurrences}!Ace@{Ace}}
\subsubsection[{Count\+Num\+Occurrences(char $\ast$str\+To\+Search, char char\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Count\+Num\+Occurrences (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char}]{char\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4202759241426cfbbc2c15b5ea218ec8}


Counts the number of times char\+To\+Look\+For appears in str\+To\+Search. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/11/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{int} numOccurences = Ace::CountNumOccurrences(data, \textcolor{charliteral}{'e'});
    printf(\textcolor{stringliteral}{"Number of occurrences of %c: %d\(\backslash\)n"}, \textcolor{charliteral}{'e'}, numOccurences);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Number of occurrences of e\+: 13


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & A string containing the data to be searched. \\
\hline
\mbox{\tt in}  & {\em char\+To\+Look\+For} & A string character to look for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of times char\+To\+Look\+For occurred in str\+To\+Search. Throws an exception if str\+To\+Search is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Count\+Num\+Occurrences@{Count\+Num\+Occurrences}}
\index{Count\+Num\+Occurrences@{Count\+Num\+Occurrences}!Ace@{Ace}}
\subsubsection[{Count\+Num\+Occurrences(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t char\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Count\+Num\+Occurrences (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t}]{char\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad46096b28cff4e653243e0a0a3656f59}


Counts the number of times char\+To\+Look\+For appears in str\+To\+Search. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{int} numOccurences = Ace::CountNumOccurrences(data, L\textcolor{charliteral}{'e'});
    printf(\textcolor{stringliteral}{"Number of occurrences of %c: %d\(\backslash\)n"}, L\textcolor{charliteral}{'e'}, numOccurences);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Number of occurrences of e\+: 13


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & A wide string containing the data to be searched. \\
\hline
\mbox{\tt in}  & {\em char\+To\+Look\+For} & A wide character to look for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of times char\+To\+Look\+For occurred in str\+To\+Search. Throws an exception if str\+To\+Search is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Count\+Num\+Occurrences@{Count\+Num\+Occurrences}}
\index{Count\+Num\+Occurrences@{Count\+Num\+Occurrences}!Ace@{Ace}}
\subsubsection[{Count\+Num\+Occurrences(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Count\+Num\+Occurrences (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad9d6a9afe8007466f657522d9492dc89}


Counts the number of times str\+To\+Look\+For appears in str\+To\+Search. 

Assumes item\+To\+Look\+For is always smaller than word.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{int} numOccurences = Ace::CountNumOccurrences(data, \textcolor{stringliteral}{"as"});
    printf(\textcolor{stringliteral}{"Number of occurrences of %s: %d"}, \textcolor{stringliteral}{"as"}, numOccurences);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Number of occurrences of as\+: 3


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & A string containing the data to be searched. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & A string representing the substring to look for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of times str\+To\+Look\+For occurred in str\+To\+Search. Throws an exception if str\+To\+Search or str\+To\+Look\+For is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Count\+Num\+Occurrences@{Count\+Num\+Occurrences}}
\index{Count\+Num\+Occurrences@{Count\+Num\+Occurrences}!Ace@{Ace}}
\subsubsection[{Count\+Num\+Occurrences(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Count\+Num\+Occurrences (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aafbcb7320a4d903a15ef1039c78bd131}


Counts the number of times str\+To\+Look\+For appears in str\+To\+Search. 

Assumes item\+To\+Look\+For is always smaller than word.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{int} numOccurences = Ace::CountNumOccurrences(data, L\textcolor{stringliteral}{"as"});
    printf(\textcolor{stringliteral}{"Number of occurrences of %S: %d"}, L\textcolor{stringliteral}{"as"}, numOccurences);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Number of occurrences of as\+: 3


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & A wide string containing the data to be searched. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & A wide string representing the substring to look for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of times str\+To\+Look\+For occurred in str\+To\+Search. Throws an exception if str\+To\+Search or str\+To\+Look\+For is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Cube\+Root@{Cube\+Root}}
\index{Cube\+Root@{Cube\+Root}!Ace@{Ace}}
\subsubsection[{Cube\+Root(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Cube\+Root (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abf907ab5be1efd6f81532d2cb9f2a809}


Calculates the Cube Root in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} retVal = Ace::CubeRoot(1728.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:12.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & The number to take the Cube Root of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Cube Root of num. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Cube\+Root@{Cube\+Root}}
\index{Cube\+Root@{Cube\+Root}!Ace@{Ace}}
\subsubsection[{Cube\+Root(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Cube\+Root (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aace71b982b1bdb3ed617b32e01335140}


Calculates the Cube Root in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} retVal = Ace::CubeRoot(1728.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:12.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & The number to take the Cube Root of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Cube Root of num. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Cube\+Root@{Cube\+Root}}
\index{Cube\+Root@{Cube\+Root}!Ace@{Ace}}
\subsubsection[{Cube\+Root(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Cube\+Root (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a3abd524fb119a83cca02a19448b57a69}


Calculates the Cube Root in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} retVal = Ace::CubeRoot(1728);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:12


\begin{DoxyParams}{Parameters}
{\em num} & The number to take the Cube Root of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Cube Root of num. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Degrees\+To\+Radians@{Degrees\+To\+Radians}}
\index{Degrees\+To\+Radians@{Degrees\+To\+Radians}!Ace@{Ace}}
\subsubsection[{Degrees\+To\+Radians(double degrees)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Degrees\+To\+Radians (
\begin{DoxyParamCaption}
\item[{double}]{degrees}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad4386a90f9491cc97945787e15e7554c}


Converts a number from degrees to radians. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/16/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} deg = 90.0;
\textcolor{keywordtype}{double} rad = Ace::DegreesToRadians(deg);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, rad);
\end{DoxyCode}
 Output\+:1.\+570796


\begin{DoxyParams}{Parameters}
{\em degrees} & Degrees to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
degrees converted to radians. 
\end{DoxyReturn}
\index{Ace@{Ace}!Degrees\+To\+Radians@{Degrees\+To\+Radians}}
\index{Degrees\+To\+Radians@{Degrees\+To\+Radians}!Ace@{Ace}}
\subsubsection[{Degrees\+To\+Radians(float degrees)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Degrees\+To\+Radians (
\begin{DoxyParamCaption}
\item[{float}]{degrees}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a30d2e65624fcc7f6143bf16955f9fabd}


Converts a number from degrees to radians. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} deg = 90.0f;
\textcolor{keywordtype}{float} rad = Ace::DegreesToRadians(deg);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, rad);
\end{DoxyCode}
 Output\+:1.\+570796


\begin{DoxyParams}{Parameters}
{\em degrees} & Degrees to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
degrees converted to radians. 
\end{DoxyReturn}
\index{Ace@{Ace}!Degrees\+To\+Radians@{Degrees\+To\+Radians}}
\index{Degrees\+To\+Radians@{Degrees\+To\+Radians}!Ace@{Ace}}
\subsubsection[{Degrees\+To\+Radians(int degrees)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Degrees\+To\+Radians (
\begin{DoxyParamCaption}
\item[{int}]{degrees}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a063da5637a3ce14700482ff43349636c}


Converts a number from degrees to radians. 

This function is somewhat useless but provided for completeness.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} deg = 90;
\textcolor{keywordtype}{int} rad = Ace::DegreesToRadians(deg);
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, rad);
\end{DoxyCode}
 Output\+:1


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em degrees} & Degrees to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Radians. 
\end{DoxyReturn}
\index{Ace@{Ace}!Does\+File\+Exist@{Does\+File\+Exist}}
\index{Does\+File\+Exist@{Does\+File\+Exist}!Ace@{Ace}}
\subsubsection[{Does\+File\+Exist(char $\ast$full\+File\+Path\+With\+Name\+And\+Ext)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Does\+File\+Exist (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{full\+File\+Path\+With\+Name\+And\+Ext}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a63153a0d492cb0cbe3a4cd69fee74684}


Returns true if the specified file exists, false otherwise. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordflow}{if} (Ace::DoesFileExist(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Images\(\backslash\)\(\backslash\)dickbutt.png"}) == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"File exists."});
    \}
    \textcolor{keywordflow}{else}
    \{
        printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"File does NOT exist."});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:File does N\+OT exist.


\begin{DoxyParams}{Parameters}
{\em full\+File\+Path\+With\+Name\+And\+Ext} & File to check.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if the specified file exists, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Does\+File\+Exist@{Does\+File\+Exist}}
\index{Does\+File\+Exist@{Does\+File\+Exist}!Ace@{Ace}}
\subsubsection[{Does\+File\+Exist(wchar\+\_\+t $\ast$full\+File\+Path\+With\+Name\+And\+Ext)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Does\+File\+Exist (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{full\+File\+Path\+With\+Name\+And\+Ext}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8391ff72632a4406b4cf1b8936bd908d}


Returns true if the specified file exists, false otherwise. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordflow}{if} (Ace::DoesFileExist(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Images\(\backslash\)\(\backslash\)dickbutt.png"}) == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"File exists."});
    \}
    \textcolor{keywordflow}{else}
    \{
        printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"File does NOT exist."});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:File does N\+OT exist.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em full\+File\+Path\+With\+Name\+And\+Ext} & File to check.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if the specified file exists, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Equals@{Equals}}
\index{Equals@{Equals}!Ace@{Ace}}
\subsubsection[{Equals(char $\ast$str\+To\+Comp\+One, char $\ast$str\+To\+Comp\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Equals (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Comp\+One, }
\item[{char $\ast$}]{str\+To\+Comp\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a986a84d68783456d3c97b467cece5635}


Compares two traditional strings together. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/16/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* strOne = \textcolor{stringliteral}{"Eddie"};
\textcolor{keywordtype}{char}* strTwo = \textcolor{stringliteral}{"Katianie"};
\textcolor{keywordflow}{if} (Ace::Equals(strOne, strTwo) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Strings are equal."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Strings are NOT equal."});
\}
\end{DoxyCode}
 Output\+:Strings are N\+OT equal.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Comp\+One} & First string to compare. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Comp\+Two} & Second string to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the strings are equal, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Equals@{Equals}}
\index{Equals@{Equals}!Ace@{Ace}}
\subsubsection[{Equals(wchar\+\_\+t $\ast$str\+To\+Comp\+One, wchar\+\_\+t $\ast$str\+To\+Comp\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Equals (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Comp\+One, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Comp\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a613fd5b028d5ba0ac5c7de30ab744266}


Compares two traditional wide strings together. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* strOne = L\textcolor{stringliteral}{"Eddie"};
\textcolor{keywordtype}{wchar\_t}* strTwo = L\textcolor{stringliteral}{"Katianie"};
\textcolor{keywordflow}{if} (Ace::Equals(strOne, strTwo) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Strings are equal."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Strings are NOT equal."});
\}
\end{DoxyCode}
 Output\+:Strings are N\+OT equal.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Comp\+One} & First wide string to compare. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Comp\+Two} & Second wide string to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the wide strings are equal, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Equals\+Ignore\+Case@{Equals\+Ignore\+Case}}
\index{Equals\+Ignore\+Case@{Equals\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Equals\+Ignore\+Case(char $\ast$str\+To\+Comp\+One, char $\ast$str\+To\+Comp\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Equals\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Comp\+One, }
\item[{char $\ast$}]{str\+To\+Comp\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5310b61a074383bf2ee4df005c6784e1}


Compares two traditional strings together but ignores upper/lower case. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/16/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* strOne = \textcolor{stringliteral}{"Katianie"};
\textcolor{keywordtype}{char}* strTwo = \textcolor{stringliteral}{"kATIaNiE"};
\textcolor{keywordflow}{if} (Ace::EqualsIgnoreCase(strOne, strTwo) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Strings are equal."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Strings are NOT equal."});
\}
\end{DoxyCode}
 Output\+:Strings are equal.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Comp\+One} & First string to compare. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Comp\+Two} & Second string to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the strings are equal, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Equals\+Ignore\+Case@{Equals\+Ignore\+Case}}
\index{Equals\+Ignore\+Case@{Equals\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Equals\+Ignore\+Case(wchar\+\_\+t $\ast$str\+To\+Comp\+One, wchar\+\_\+t $\ast$str\+To\+Comp\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Equals\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Comp\+One, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Comp\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abef72240bed5aa10df9b9f8bceec3bb9}


Compares two traditional wide strings together but ignores upper/lower case. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* strOne = L\textcolor{stringliteral}{"Katianie"};
\textcolor{keywordtype}{wchar\_t}* strTwo = L\textcolor{stringliteral}{"kATIaNiE"};
\textcolor{keywordflow}{if} (Ace::EqualsIgnoreCase(strOne, strTwo) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Strings are equal."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Strings are NOT equal."});
\}
\end{DoxyCode}
 Output\+:Strings are equal.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Comp\+One} & First wide string to compare. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Comp\+Two} & Second wide string to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the strings are equal, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Error\+Function@{Error\+Function}}
\index{Error\+Function@{Error\+Function}!Ace@{Ace}}
\subsubsection[{Error\+Function(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Error\+Function (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa522bbdb8b2d83603bf89f64714f4d89}


Calculates the Error Function integral from 0 to num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::ErrorFunction(1.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+842701


\begin{DoxyParams}{Parameters}
{\em num} & End point for the integral.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of the Error Function from 0 to num. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Error\+Function@{Error\+Function}}
\index{Error\+Function@{Error\+Function}!Ace@{Ace}}
\subsubsection[{Error\+Function(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Error\+Function (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a93a5ce3eee3f3fabb6fa3a0ac9b2c8c4}


Calculates the Error Function integral from 0 to num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::ErrorFunction(1.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+842701


\begin{DoxyParams}{Parameters}
{\em num} & End point for the integral.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of the Error Function from 0 to num. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Error\+Function@{Error\+Function}}
\index{Error\+Function@{Error\+Function}!Ace@{Ace}}
\subsubsection[{Error\+Function(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Error\+Function (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_acda5a03f6e4659e3973a452afed97fa7}


Calculates the Error Function integral from 0 to num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::ErrorFunction(5);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0


\begin{DoxyParams}{Parameters}
{\em num} & End point for the integral.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of the Error Function from 0 to num. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!E\+To\+The\+X\+Power@{E\+To\+The\+X\+Power}}
\index{E\+To\+The\+X\+Power@{E\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{E\+To\+The\+X\+Power(double power)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+E\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{double}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae51ded8e8e681b85ee397e381068dbca}


Calculates e$^\wedge$x in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::EToTheXPower(5.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:148.\+413159


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise e to (i.\+e. power = x in e$^\wedge$x).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of raising e to power. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!E\+To\+The\+X\+Power@{E\+To\+The\+X\+Power}}
\index{E\+To\+The\+X\+Power@{E\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{E\+To\+The\+X\+Power(float power)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+E\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{float}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a263f99643d5a480447b556856b016b37}


Calculates e$^\wedge$x in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::EToTheXPower(5.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:148.\+413159


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise e to (i.\+e. power = x in e$^\wedge$x).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of raising e to power. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!E\+To\+The\+X\+Power@{E\+To\+The\+X\+Power}}
\index{E\+To\+The\+X\+Power@{E\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{E\+To\+The\+X\+Power(int power)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+E\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{int}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae7c92b001dd647e14e7efe5817b10dfe}


Calculates e$^\wedge$x in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::EToTheXPower(5);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:148


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise e to (i.\+e. power = x in e$^\wedge$x).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of raising e to power. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!E\+To\+The\+X\+Power\+Minus\+One@{E\+To\+The\+X\+Power\+Minus\+One}}
\index{E\+To\+The\+X\+Power\+Minus\+One@{E\+To\+The\+X\+Power\+Minus\+One}!Ace@{Ace}}
\subsubsection[{E\+To\+The\+X\+Power\+Minus\+One(double power)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+E\+To\+The\+X\+Power\+Minus\+One (
\begin{DoxyParamCaption}
\item[{double}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a50cb517fc19d73e44bb9c3cc1141d7bc}


Calculates (e$^\wedge$x) -\/ 1 in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::EToTheXPowerMinusOne(5.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:147.\+413159


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise e to (i.\+e. power = x in e$^\wedge$x).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of raising e to power then subtracting 1. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!E\+To\+The\+X\+Power\+Minus\+One@{E\+To\+The\+X\+Power\+Minus\+One}}
\index{E\+To\+The\+X\+Power\+Minus\+One@{E\+To\+The\+X\+Power\+Minus\+One}!Ace@{Ace}}
\subsubsection[{E\+To\+The\+X\+Power\+Minus\+One(float power)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+E\+To\+The\+X\+Power\+Minus\+One (
\begin{DoxyParamCaption}
\item[{float}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a544ff3061a586b5cdedddbf21287ae22}


Calculates (e$^\wedge$x) -\/ 1 in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::EToTheXPowerMinusOne(5.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:147.\+413159


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise e to (i.\+e. power = x in e$^\wedge$x).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of raising e to power then subtracting 1. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!E\+To\+The\+X\+Power\+Minus\+One@{E\+To\+The\+X\+Power\+Minus\+One}}
\index{E\+To\+The\+X\+Power\+Minus\+One@{E\+To\+The\+X\+Power\+Minus\+One}!Ace@{Ace}}
\subsubsection[{E\+To\+The\+X\+Power\+Minus\+One(int power)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+E\+To\+The\+X\+Power\+Minus\+One (
\begin{DoxyParamCaption}
\item[{int}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac6667ff808b95a501a8a43f95f77b424}


Calculates (e$^\wedge$x) -\/ 1 in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::EToTheXPowerMinusOne(5);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:147


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise e to (i.\+e. power = x in e$^\wedge$x).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of raising e to power then subtracting 1. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!First\+Char@{First\+Char}}
\index{First\+Char@{First\+Char}!Ace@{Ace}}
\subsubsection[{First\+Char(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}char Ace\+::\+First\+Char (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aca1a612de325a7636ef40c95b676795d}


Returns the first character in str. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{char} temp = Ace::FirstChar(data);
    printf(\textcolor{stringliteral}{"%c"}, temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:H


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The first character in str. If str is N\+U\+LL then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!First\+Char@{First\+Char}}
\index{First\+Char@{First\+Char}!Ace@{Ace}}
\subsubsection[{First\+Char(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t Ace\+::\+First\+Char (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0e34aae1025e81ad4684b34940a70959}


Returns the first character in str. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{wchar\_t} temp = Ace::FirstChar(data);
    printf(\textcolor{stringliteral}{"%c"}, temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:H


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & Wide String to search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The first character in str. If str is N\+U\+LL then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Floor@{Floor}}
\index{Floor@{Floor}!Ace@{Ace}}
\subsubsection[{Floor(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Floor (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a509e6fda4da886680951615f2ac2d421}


Calculates the largest integer value not greater than num. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} retVal = Ace::Floor(2.9);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:2.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & The number to use to calculate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The largest integer value not greater than num. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Floor@{Floor}}
\index{Floor@{Floor}!Ace@{Ace}}
\subsubsection[{Floor(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Floor (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae821a3392f3637b82112c010f060026b}


Calculates the largest integer value not greater than num. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} retVal = Ace::Floor(2.9f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:2.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & The number to use to calculate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The largest integer value not greater than num. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Floor@{Floor}}
\index{Floor@{Floor}!Ace@{Ace}}
\subsubsection[{Floor(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Floor (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abd20c4cb5d7f0f2bdf93623f0c58e223}


Calculates the largest integer value not greater than num. 

This function is somewhat useless but provided for completeness. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} retVal = Ace::Floor(2);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:2


\begin{DoxyParams}{Parameters}
{\em num} & The number to use to calculate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The largest integer value not greater than num. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Gamma\+Function@{Gamma\+Function}}
\index{Gamma\+Function@{Gamma\+Function}!Ace@{Ace}}
\subsubsection[{Gamma\+Function(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Gamma\+Function (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a06b87693241afd13cfe45e052e6196f0}


Calculates The Gamma Function ( (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] ) in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::GammaFunction(5.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:24.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & Number to use for t$^\wedge$num-\/1 in the equation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of calculating The Gamma Function for t$^\wedge$num-\/1. If a mathematical error occurs or if num is less than or equal to 0.\+0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Gamma\+Function@{Gamma\+Function}}
\index{Gamma\+Function@{Gamma\+Function}!Ace@{Ace}}
\subsubsection[{Gamma\+Function(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Gamma\+Function (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_afe867fa9d28bd8f4233fd488b5e533ee}


Calculates The Gamma Function ( (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] ) in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::GammaFunction(5.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:24.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & Number to use for t$^\wedge$num-\/1 in the equation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of calculating The Gamma Function for t$^\wedge$num-\/1. If a mathematical error occurs or if num is less than or equal to 0.\+0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Gamma\+Function@{Gamma\+Function}}
\index{Gamma\+Function@{Gamma\+Function}!Ace@{Ace}}
\subsubsection[{Gamma\+Function(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Gamma\+Function (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5a20066ca9ae4cd53ca78a5da4236cf8}


Calculates The Gamma Function ( (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] ) in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::GammaFunction(5);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:24


\begin{DoxyParams}{Parameters}
{\em num} & Number to use for t$^\wedge$num-\/1 in the equation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of calculating The Gamma Function for t$^\wedge$num-\/1. If a mathematical error occurs or if num is less than or equal to 0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Generate\+Random\+Num@{Generate\+Random\+Num}}
\index{Generate\+Random\+Num@{Generate\+Random\+Num}!Ace@{Ace}}
\subsubsection[{Generate\+Random\+Num(int min, int max)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Generate\+Random\+Num (
\begin{DoxyParamCaption}
\item[{int}]{min, }
\item[{int}]{max}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af052dd5bee7f50a8f80f3af4375a874a}


Some might think this is all unnecessary but I think it\textquotesingle{}s important to seed the Random\+Number\+Generator properly with a proper seed value. 

Too often are games plagued with predictable outcomes all leading back to not seeding the R\+NG properly. Generates a \char`\"{}super\char`\"{} random number using a random seed at launch.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} randomNum = -1;
\textcolor{comment}{//Generate 10 random numbers.}
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 1; currIndex <= 10; currIndex++)
\{
    randomNum = Ace::GenerateRandomNum(1, 100);
    printf(\textcolor{stringliteral}{"%d "}, randomNum);
\}
\end{DoxyCode}
 Output\+:35 82 10 52 10 34 56 21 37 14


\begin{DoxyParams}{Parameters}
{\em min} & Lowest number to generate. \\
\hline
{\em max} & Highest number to generate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A random number between the given range. 
\end{DoxyReturn}
\index{Ace@{Ace}!Get\+H\+Result\+Description@{Get\+H\+Result\+Description}}
\index{Get\+H\+Result\+Description@{Get\+H\+Result\+Description}!Ace@{Ace}}
\subsubsection[{Get\+H\+Result\+Description(\+H\+R\+E\+S\+U\+L\+T result)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Get\+H\+Result\+Description (
\begin{DoxyParamCaption}
\item[{H\+R\+E\+S\+U\+LT}]{result}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a1c97e15879456b16fa7322fd2e0db19a}


Gets the corresponding detailed description of the H\+R\+E\+S\+U\+LT. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* result = Ace::GetHResultDescription((HRESULT)69);
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:The network B\+I\+OS session limit was exceeded.


\begin{DoxyParams}{Parameters}
{\em result} & The H\+R\+E\+S\+U\+LT description.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The corresponding detailed description of the H\+R\+E\+S\+U\+LT. An exception is thrown if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Get\+H\+Result\+DescriptionW@{Get\+H\+Result\+DescriptionW}}
\index{Get\+H\+Result\+DescriptionW@{Get\+H\+Result\+DescriptionW}!Ace@{Ace}}
\subsubsection[{Get\+H\+Result\+Description\+W(\+H\+R\+E\+S\+U\+L\+T result)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Get\+H\+Result\+DescriptionW (
\begin{DoxyParamCaption}
\item[{H\+R\+E\+S\+U\+LT}]{result}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a61fd06ba0cf3ccb1382445c9a556c181}


Gets the corresponding detailed description of the H\+R\+E\+S\+U\+LT. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* result = Ace::GetHResultDescriptionW((HRESULT)69);
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:The network B\+I\+OS session limit was exceeded.


\begin{DoxyParams}{Parameters}
{\em result} & The H\+R\+E\+S\+U\+LT description.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The corresponding detailed description of the H\+R\+E\+S\+U\+LT. Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Get\+Image\+Size@{Get\+Image\+Size}}
\index{Get\+Image\+Size@{Get\+Image\+Size}!Ace@{Ace}}
\subsubsection[{Get\+Image\+Size(char $\ast$file\+Name, int $\ast$out\+Width, int $\ast$out\+Height)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Get\+Image\+Size (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Path, }
\item[{int $\ast$}]{out\+Width, }
\item[{int $\ast$}]{out\+Height}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a126f129969e4e0cf86a746ae1968695e}


Gets the pixel dimensions of the provided image (file\+Path). 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
11/2/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} width;
    \textcolor{keywordtype}{int} height;
    Ace::GetImageSize(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Cockmongler.jpg"}, &width, &height);
    printf(\textcolor{stringliteral}{"Width:%d Height:%d\(\backslash\)n"}, width, height);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:\+Width\+:600 Height\+:791


\begin{DoxyParams}{Parameters}
{\em file\+Path} & [in] The full file path of the image. \\
\hline
{\em out\+Width} & [out] The width of the image. \\
\hline
{\em out\+Height} & [out] The height of the image\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Get\+Image\+SizeW@{Get\+Image\+SizeW}}
\index{Get\+Image\+SizeW@{Get\+Image\+SizeW}!Ace@{Ace}}
\subsubsection[{Get\+Image\+Size\+W(wchar\+\_\+t $\ast$file\+Name, int $\ast$out\+Width, int $\ast$out\+Height)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Get\+Image\+SizeW (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Path, }
\item[{int $\ast$}]{out\+Width, }
\item[{int $\ast$}]{out\+Height}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af903d70401f7dea9c59d980a56846028}


Gets the pixel dimensions of the provided image (file\+Path). 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
11/2/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} width;
    \textcolor{keywordtype}{int} height;
    Ace::GetImageSizeW(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Cockmongler.jpg"}, &width, &height);
    printf(\textcolor{stringliteral}{"Width:%d Height:%d\(\backslash\)n"}, width, height);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:\+Width\+:600 Height\+:791


\begin{DoxyParams}{Parameters}
{\em file\+Path} & [in] The full file path of the image. \\
\hline
{\em out\+Width} & [out] The width of the image. \\
\hline
{\em out\+Height} & [out] The height of the image\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Hypotenuse@{Hypotenuse}}
\index{Hypotenuse@{Hypotenuse}!Ace@{Ace}}
\subsubsection[{Hypotenuse(double x, double y)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Hypotenuse (
\begin{DoxyParamCaption}
\item[{double}]{x, }
\item[{double}]{y}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a913e668440d1c00f00d340519bf95a7c}


Solves for c in Pythagoras theorem (a$^\wedge$2 + b$^\wedge$2 = c$^\wedge$2); i.\+e square root of (x$^\wedge$2 + y$^\wedge$2). 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::Hypotenuse(3.0, 4.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:5.\+000000


\begin{DoxyParams}{Parameters}
{\em x} & Value of one of the sides of the triangle. \\
\hline
{\em y} & Value of the other side of the triangle.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Hypotenuse (the longest side) of the triangle. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Hypotenuse@{Hypotenuse}}
\index{Hypotenuse@{Hypotenuse}!Ace@{Ace}}
\subsubsection[{Hypotenuse(float x, float y)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Hypotenuse (
\begin{DoxyParamCaption}
\item[{float}]{x, }
\item[{float}]{y}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aaa3ee98b16b39b101f3258803bc1e03d}


Solves for c in Pythagoras theorem (a$^\wedge$2 + b$^\wedge$2 = c$^\wedge$2); i.\+e square root of (x$^\wedge$2 + y$^\wedge$2). 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::Hypotenuse(3.0f, 4.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:5.\+000000


\begin{DoxyParams}{Parameters}
{\em x} & Value of one of the sides of the triangle. \\
\hline
{\em y} & Value of the other side of the triangle.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Hypotenuse (the longest side) of the triangle. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Hypotenuse@{Hypotenuse}}
\index{Hypotenuse@{Hypotenuse}!Ace@{Ace}}
\subsubsection[{Hypotenuse(int x, int y)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Hypotenuse (
\begin{DoxyParamCaption}
\item[{int}]{x, }
\item[{int}]{y}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a77a8b95a7d1f6c1c015ed1bed34b29ce}


Solves for c in Pythagoras theorem (a$^\wedge$2 + b$^\wedge$2 = c$^\wedge$2); i.\+e square root of (x$^\wedge$2 + y$^\wedge$2). 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::Hypotenuse(3, 4);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:5


\begin{DoxyParams}{Parameters}
{\em x} & Value of one of the sides of the triangle. \\
\hline
{\em y} & Value of the other side of the triangle.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Hypotenuse (the longest side) of the triangle. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of@{Index\+Of}}
\index{Index\+Of@{Index\+Of}!Ace@{Ace}}
\subsubsection[{Index\+Of(char $\ast$str\+To\+Search, char char\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char}]{char\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a512efdbdf0e7413ae2e0d0abc8dff890}


Searches str\+To\+Search for the first occurrence of char\+To\+Look\+For and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/31/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{int} temp = Ace::IndexOf(data, \textcolor{charliteral}{'b'});
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:16


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from left to right. \\
\hline
 & {\em char\+To\+Look\+For} & Character to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where char\+To\+Look\+For is located. Returns -\/1 if not found. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of@{Index\+Of}}
\index{Index\+Of@{Index\+Of}!Ace@{Ace}}
\subsubsection[{Index\+Of(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t char\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t}]{char\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aee38df2a411360ccb644af1da98ad553}


Searches str\+To\+Search for the first occurrence of char\+To\+Look\+For and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/31/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{int} temp = Ace::IndexOf(data, L\textcolor{charliteral}{'b'});
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:16


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from left to right. \\
\hline
 & {\em char\+To\+Look\+For} & Character to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where char\+To\+Look\+For is located. Returns -\/1 if not found. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of@{Index\+Of}}
\index{Index\+Of@{Index\+Of}!Ace@{Ace}}
\subsubsection[{Index\+Of(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a50a722b64f2f7a54b297cb5beae7330b}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{int} temp = Ace::IndexOf(data, \textcolor{stringliteral}{"been"});
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:16


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. Returns -\/1 if not found. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of@{Index\+Of}}
\index{Index\+Of@{Index\+Of}!Ace@{Ace}}
\subsubsection[{Index\+Of(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_acf9bd88f509f374f6020dc19c7a77252}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{int} temp = Ace::IndexOf(data, L\textcolor{stringliteral}{"been"});
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:16


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & Wide String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & Wide String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. Returns -\/1 if not found. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of\+First\+Letter@{Index\+Of\+First\+Letter}}
\index{Index\+Of\+First\+Letter@{Index\+Of\+First\+Letter}!Ace@{Ace}}
\subsubsection[{Index\+Of\+First\+Letter(char $\ast$str\+To\+Search)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of\+First\+Letter (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a273501ca36610e1631ff37b2dd93cddf}


Returns the first index of a letter in a given string. 

For Example\+: \char`\"{}23584\+Anus\char`\"{} would return 5.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* str = \textcolor{stringliteral}{"23584Anus"};
    \textcolor{keywordtype}{int} retVal = Ace::IndexOfFirstLetter(str);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:5


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search for the first occurrence of a alphabetical character.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where in str\+To\+Search the first alphabetical character was found. Returns -\/1 if not found. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of\+First\+Letter@{Index\+Of\+First\+Letter}}
\index{Index\+Of\+First\+Letter@{Index\+Of\+First\+Letter}!Ace@{Ace}}
\subsubsection[{Index\+Of\+First\+Letter(wchar\+\_\+t $\ast$str\+To\+Search)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of\+First\+Letter (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae0ec852c9eea044d4a1dcb0d03462166}


Returns the first index of a letter in a given wide string. 

For Example\+: \char`\"{}23584\+Anus\char`\"{} would return 5.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    wchar\_s* str = L\textcolor{stringliteral}{"23584Anus"};
    \textcolor{keywordtype}{int} retVal = Ace::IndexOfFirstLetter(str);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:5


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & Wide String to search for the first occurrence of a alphabetical character.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where in str\+To\+Search the first alphabetical character was found. Returns -\/1 if not found. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of\+Ignore\+Case@{Index\+Of\+Ignore\+Case}}
\index{Index\+Of\+Ignore\+Case@{Index\+Of\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Index\+Of\+Ignore\+Case(char $\ast$str\+To\+Search, char char\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char}]{char\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6d107bd58a740eb1fbdf8c39b9269b24}


Searches str\+To\+Search for the first occurrence of char\+To\+Look\+For (regardless of case) and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/26/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::IndexOfIgnoreCase(\textcolor{stringliteral}{"My name is eddIe and I like cheese."}, \textcolor{charliteral}{'I'});
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:8


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from left to right. \\
\hline
 & {\em char\+To\+Look\+For} & Character to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. Returns -\/1 if not found. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of\+Ignore\+Case@{Index\+Of\+Ignore\+Case}}
\index{Index\+Of\+Ignore\+Case@{Index\+Of\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Index\+Of\+Ignore\+Case(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t char\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t}]{char\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a760ef99aae1ea1f2648891663d26a5ee}


Searches str\+To\+Search for the first occurrence of char\+To\+Look\+For (regardless of case) and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/26/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::IndexOfIgnoreCase(L\textcolor{stringliteral}{"My name is eddIe and I like cheese."}, L\textcolor{charliteral}{'I'});
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:8


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from left to right. \\
\hline
 & {\em char\+To\+Look\+For} & Character to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. Returns -\/1 if not found. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of\+Ignore\+Case@{Index\+Of\+Ignore\+Case}}
\index{Index\+Of\+Ignore\+Case@{Index\+Of\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Index\+Of\+Ignore\+Case(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5e24b813ba1540fc92502435e4d817ce}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/26/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::IndexOfIgnoreCase(\textcolor{stringliteral}{"My name is eddIe and I like cheese."}, \textcolor{stringliteral}{"EdDIe"});
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:11


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. Returns -\/1 if not found. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of\+Ignore\+Case@{Index\+Of\+Ignore\+Case}}
\index{Index\+Of\+Ignore\+Case@{Index\+Of\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Index\+Of\+Ignore\+Case(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0827c26650755411f44c94920142c421}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::IndexOfIgnoreCase(L\textcolor{stringliteral}{"My name is eddIe and I like cheese."}, L\textcolor{stringliteral}{"EdDIe"});
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:11


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & Wide String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & Wide String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. Returns -\/1 if not found. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Insert\+String@{Insert\+String}}
\index{Insert\+String@{Insert\+String}!Ace@{Ace}}
\subsubsection[{Insert\+String(char $\ast$str\+To\+Receive, char $\ast$str\+To\+Insert, int start\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Insert\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Receive, }
\item[{char $\ast$}]{str\+To\+Insert, }
\item[{int}]{start\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a488c9ea590fdf14919ad90ee1dc377ad}


Inserts the string str\+To\+Insert into str\+To\+Revcive by \char`\"{}sandwiching\char`\"{} the two halves of str\+To\+Receive. 

The first half is from 0 to start\+Index-\/1, the last half is from start\+Index to the end of str\+To\+Receive.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/10/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* retVal = Ace::InsertString(\textcolor{stringliteral}{"Eddie is a Computer Scientist."}, \textcolor{stringliteral}{" O\(\backslash\)'Hagan"}, 5);
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, retVal);
    \_aligned\_free(retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie O\textquotesingle{}Hagan is a Computer Scientist.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Receive} & The string to receive str\+To\+Insert. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Insert} & The string to sandwich/insert into str\+To\+Receive. \\
\hline
 & {\em start\+Index} & The index in str\+To\+Receive to insert at str\+To\+Insert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The newly created string with str\+To\+Insert inserted into str\+To\+Receive. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Insert\+String@{Insert\+String}}
\index{Insert\+String@{Insert\+String}!Ace@{Ace}}
\subsubsection[{Insert\+String(wchar\+\_\+t $\ast$str\+To\+Receive, wchar\+\_\+t $\ast$str\+To\+Insert, int start\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Insert\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Receive, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Insert, }
\item[{int}]{start\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac4a643953262f0837db5074a66286787}


Inserts the string str\+To\+Insert into str\+To\+Revcive by \char`\"{}sandwiching\char`\"{} the two halves of str\+To\+Receive. 

The first half is from 0 to start\+Index-\/1, the last half is from start\+Index to the end of str\+To\+Receive.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/10/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* retVal = Ace::InsertString(L\textcolor{stringliteral}{"Eddie is a Computer Scientist."}, L\textcolor{stringliteral}{" O\(\backslash\)'Hagan"}, 5);
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, retVal);
    \_aligned\_free(retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie O\textquotesingle{}Hagan is a Computer Scientist.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Receive} & The wide string to receive str\+To\+Insert. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Insert} & The wide string to sandwich/insert into str\+To\+Receive. \\
\hline
 & {\em start\+Index} & The index in str\+To\+Receive to insert at str\+To\+Insert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The newly created wide string with str\+To\+Insert inserted into str\+To\+Receive. Throws an exception if there is an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Alphabetic@{Is\+Alphabetic}}
\index{Is\+Alphabetic@{Is\+Alphabetic}!Ace@{Ace}}
\subsubsection[{Is\+Alphabetic(char character)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Alphabetic (
\begin{DoxyParamCaption}
\item[{char}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aebb4f615642b84d54134e02e3fc8c083}


Returns true if a character is a letter from either a to z or A to Z. 

Letters fall into a range on the A\+S\+C\+II chart which makes this an simple test.

A\+S\+C\+II chart\+: {\tt http\+://www.\+asciitable.\+com/index/asciifull.\+gif}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsAlphabetic(\textcolor{charliteral}{'E'}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & A single character to test if it\textquotesingle{}s either a-\/z or A-\/Z.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the character is between ranges a-\/z or A-\/Z; false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Alphabetic@{Is\+Alphabetic}}
\index{Is\+Alphabetic@{Is\+Alphabetic}!Ace@{Ace}}
\subsubsection[{Is\+Alphabetic(wchar\+\_\+t character)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Alphabetic (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a658aece7e64b90e57ac08f8b79b8ed0c}


Returns true if a wide character is not a digit. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsAlphabetic(L\textcolor{charliteral}{'E'}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & A single wide character to test.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the character is not a digit. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Digit@{Is\+Digit}}
\index{Is\+Digit@{Is\+Digit}!Ace@{Ace}}
\subsubsection[{Is\+Digit(char character)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Digit (
\begin{DoxyParamCaption}
\item[{char}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab5bdc2fab29cf22bd6c06e62a5eab593}


Returns true if a character is a digit from 0-\/9. 

Digits fall into a range on the A\+S\+C\+II chart which makes this an simple test.

A\+S\+C\+II chart\+: {\tt http\+://www.\+asciitable.\+com/index/asciifull.\+gif}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsDigit(\textcolor{charliteral}{'7'}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & A single character to test if it\textquotesingle{}s between 0-\/9.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the character is between 0-\/9; false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Digit@{Is\+Digit}}
\index{Is\+Digit@{Is\+Digit}!Ace@{Ace}}
\subsubsection[{Is\+Digit(wchar\+\_\+t character)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Digit (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2e41b7c6ba214c7088e723a9027cf197}


Returns true if a wide character is a digit. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsDigit(L\textcolor{charliteral}{'7'}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & A single wide character to test if it\textquotesingle{}s between 0-\/9.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the wide character is a digit; false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Empty@{Is\+Empty}}
\index{Is\+Empty@{Is\+Empty}!Ace@{Ace}}
\subsubsection[{Is\+Empty(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Empty (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2f5cb4c89dff665ea2c0e1fd16fefd90}


Searches a given string to see if it is all empty. 

In other words, is the string provided all whitespace.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsEmpty(\textcolor{stringliteral}{"    "}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if every character in str is whitespace; false otherwise. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Empty@{Is\+Empty}}
\index{Is\+Empty@{Is\+Empty}!Ace@{Ace}}
\subsubsection[{Is\+Empty(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Empty (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abdfef27ea8065e456ad40cc31df5d66a}


Searches a given wide string to see if it is all empty. 

In other words, is the string provided all whitespace.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsEmpty(L\textcolor{stringliteral}{"    "}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & Wide String to search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if every wide character in str is whitespace; false otherwise. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Number@{Is\+Number}}
\index{Is\+Number@{Is\+Number}!Ace@{Ace}}
\subsubsection[{Is\+Number(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Number (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abf209e3f71042eefd2091b990f0fc6f6}


Returns true if all characters are a digit. 

A\+S\+C\+II chart\+: {\tt http\+://www.\+asciitable.\+com/index/asciifull.\+gif}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* str = \textcolor{stringliteral}{"01234"};
    \textcolor{keywordflow}{if} (Ace::IsNumber(str) == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
    \}
    \textcolor{keywordflow}{else}
    \{
        printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & A string to test if all characters are digits.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the string is all digits, false otherwise. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Number@{Is\+Number}}
\index{Is\+Number@{Is\+Number}!Ace@{Ace}}
\subsubsection[{Is\+Number(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Number (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a78e3339b16bfe5d33d54e8a1f8961016}


Returns true if all characters are a digit. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* str = L\textcolor{stringliteral}{"01234"};
    \textcolor{keywordflow}{if} (Ace::IsNumber(str) == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"true"});
    \}
    \textcolor{keywordflow}{else}
    \{
        printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"false"});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & A wide string to test if all characters are digits.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the wide string is all digits, false otherwise. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Path\+A\+Device@{Is\+Path\+A\+Device}}
\index{Is\+Path\+A\+Device@{Is\+Path\+A\+Device}!Ace@{Ace}}
\subsubsection[{Is\+Path\+A\+Device(const char $\ast$path)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Path\+A\+Device (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a14d72992e536c2a370f5c779cc3b1f5a}


Returns true if the provided path leads to a device rather than a file. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/14/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{bool} retVal = Ace::IsPathADevice(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)dicks.txt"});
    \textcolor{keywordflow}{if} (retVal == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"true"});
    \}
    \textcolor{keywordflow}{else}
    \{
        printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"false"});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:false


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & The file path to test.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the path leads to a device, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Path\+A\+Device@{Is\+Path\+A\+Device}}
\index{Is\+Path\+A\+Device@{Is\+Path\+A\+Device}!Ace@{Ace}}
\subsubsection[{Is\+Path\+A\+Device(const wchar\+\_\+t $\ast$path)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Path\+A\+Device (
\begin{DoxyParamCaption}
\item[{const wchar\+\_\+t $\ast$}]{path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2428e78c087c5582b690452ff0ace6e3}


Returns true if the provided path leads to a device rather than a file. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/14/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{bool} retVal = Ace::IsPathADevice(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)dicks.txt"});
    \textcolor{keywordflow}{if} (retVal == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"true"});
    \}
    \textcolor{keywordflow}{else}
    \{
        printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"false"});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:false


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & The file path to test.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the path leads to a device, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Whitespace@{Is\+Whitespace}}
\index{Is\+Whitespace@{Is\+Whitespace}!Ace@{Ace}}
\subsubsection[{Is\+Whitespace(char character)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Whitespace (
\begin{DoxyParamCaption}
\item[{char}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a66a594470f47320362a57ae4a4a556aa}


Returns true if a character is whitespace. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsWhitespace(\textcolor{charliteral}{' '}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & Character to test to see if it is whitespace.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the character is a space, tab or newline; false otherwise. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Whitespace@{Is\+Whitespace}}
\index{Is\+Whitespace@{Is\+Whitespace}!Ace@{Ace}}
\subsubsection[{Is\+Whitespace(wchar\+\_\+t character)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Whitespace (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7923870bcd0a10fedf5d809421eabcd2}


Returns true if a wide character is whitespace. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsWhitespace(L\textcolor{charliteral}{' '}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & Character to test to see if it is whitespace.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the wide character is a space, tab or newline; false otherwise. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Largest@{Largest}}
\index{Largest@{Largest}!Ace@{Ace}}
\subsubsection[{Largest(double num1, double num2)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Largest (
\begin{DoxyParamCaption}
\item[{double}]{num1, }
\item[{double}]{num2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8eae4684d32fec1d237da49b0ad57da9}


Returns the larger of the two values. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} retVal = Ace::Largest(2.0, 2.01);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+:2.\+010000


\begin{DoxyParams}{Parameters}
{\em num1} & number to compare against. \\
\hline
{\em num1} & other number to compare against.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The larger of the two values. 
\end{DoxyReturn}
\index{Ace@{Ace}!Largest@{Largest}}
\index{Largest@{Largest}!Ace@{Ace}}
\subsubsection[{Largest(float num1, float num2)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Largest (
\begin{DoxyParamCaption}
\item[{float}]{num1, }
\item[{float}]{num2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a02b6e67c430dd5750862a6ed3356c8ed}


Returns the larger of the two values. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} retVal = Ace::Largest(2.0f, 2.01f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+:2.\+010000


\begin{DoxyParams}{Parameters}
{\em num1} & number to compare against. \\
\hline
{\em num1} & other number to compare against.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The larger of the two values. 
\end{DoxyReturn}
\index{Ace@{Ace}!Largest@{Largest}}
\index{Largest@{Largest}!Ace@{Ace}}
\subsubsection[{Largest(int num1, int num2)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Largest (
\begin{DoxyParamCaption}
\item[{int}]{num1, }
\item[{int}]{num2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae72f33e4387286a378b7815ae109ecc9}


Returns the larger of the two values. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} retVal = Ace::Largest(2, 3);
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+:3


\begin{DoxyParams}{Parameters}
{\em num1} & number to compare against. \\
\hline
{\em num1} & other number to compare against.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The larger of the two values. 
\end{DoxyReturn}
\index{Ace@{Ace}!Last\+Char@{Last\+Char}}
\index{Last\+Char@{Last\+Char}!Ace@{Ace}}
\subsubsection[{Last\+Char(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}char Ace\+::\+Last\+Char (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae0d85e7e3e82f46a0227b85f7112458c}


Returns the last character in str. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{char} temp = Ace::LastChar(data);
    printf(\textcolor{stringliteral}{"%c"}, temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:?


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str} & String to search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The last character in str. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Last\+Char@{Last\+Char}}
\index{Last\+Char@{Last\+Char}!Ace@{Ace}}
\subsubsection[{Last\+Char(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t Ace\+::\+Last\+Char (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad265da6c7c28b05d19489da9398302aa}


Returns the last character in str. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{wchar\_t} temp = Ace::LastChar(data);
    printf(\textcolor{stringliteral}{"%c"}, temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:?


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str} & Wide String to search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The last character in str. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Last\+Index\+Of@{Last\+Index\+Of}}
\index{Last\+Index\+Of@{Last\+Index\+Of}!Ace@{Ace}}
\subsubsection[{Last\+Index\+Of(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Last\+Index\+Of (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_acf5ed5e07611ea7cc31b21d808b20e4d}


Searches str\+To\+Search for the last occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{int} temp = Ace::LastIndexOf(data, \textcolor{stringliteral}{"th"});
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:55


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from right to left. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. Returns -\/1 if not found. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Last\+Index\+Of@{Last\+Index\+Of}}
\index{Last\+Index\+Of@{Last\+Index\+Of}!Ace@{Ace}}
\subsubsection[{Last\+Index\+Of(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Last\+Index\+Of (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae0a414c4d05e32a3a1a93fdd9e2faf64}


Searches str\+To\+Search for the last occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{int} temp = Ace::LastIndexOf(data, L\textcolor{stringliteral}{"th"});
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:55


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & Wide String to search starting from right to left. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & Wide String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. Returns -\/1 if not found. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Log\+Base\+Ten@{Log\+Base\+Ten}}
\index{Log\+Base\+Ten@{Log\+Base\+Ten}!Ace@{Ace}}
\subsubsection[{Log\+Base\+Ten(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Log\+Base\+Ten (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a278ffeb56149bc1cc75617d639b63468}


Calculates the logarithm (log) base 10 of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} retVal = Ace::LogBaseTen(69.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1.\+838849


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its logarithm base 10.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The logarithm base 10 of num. If a mathematical error occurs or num is negative, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Log\+Base\+Ten@{Log\+Base\+Ten}}
\index{Log\+Base\+Ten@{Log\+Base\+Ten}!Ace@{Ace}}
\subsubsection[{Log\+Base\+Ten(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Log\+Base\+Ten (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae49751bb233954e6d17505e1089d9f0c}


Calculates the logarithm (log) base 10 of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} retVal = Ace::LogBaseTen(69.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1.\+838849


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its logarithm base 10.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The logarithm base 10 of num. If a mathematical error occurs or num is negative, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Log\+Base\+Ten@{Log\+Base\+Ten}}
\index{Log\+Base\+Ten@{Log\+Base\+Ten}!Ace@{Ace}}
\subsubsection[{Log\+Base\+Ten(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Log\+Base\+Ten (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9cde14b79aae571c3d04a43812755ade}


Calculates the logarithm (log) base 10 of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} retVal = Ace::LogBaseTen(69);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its logarithm base 10.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The logarithm base 10 of num. If a mathematical error occurs or num is negative, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Log\+Base\+Two@{Log\+Base\+Two}}
\index{Log\+Base\+Two@{Log\+Base\+Two}!Ace@{Ace}}
\subsubsection[{Log\+Base\+Two(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Log\+Base\+Two (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af2bfc128e37911cda7a8af0b9a3a06b9}


Calculates the logarithm (log) base 2 of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} retVal = Ace::LogBaseTwo(69.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:6.\+108524


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its logarithm base 2.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The logarithm base 2 of num. If a mathematical error occurs or num is negative, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Log\+Base\+Two@{Log\+Base\+Two}}
\index{Log\+Base\+Two@{Log\+Base\+Two}!Ace@{Ace}}
\subsubsection[{Log\+Base\+Two(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Log\+Base\+Two (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6a2fa76e6de2cc82a2eb64bd07053f68}


Calculates the logarithm (log) base 2 of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} retVal = Ace::LogBaseTwo(69.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:6.\+108524


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its logarithm base 2.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The logarithm base 2 of num. If a mathematical error occurs or num is negative, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Log\+Base\+Two@{Log\+Base\+Two}}
\index{Log\+Base\+Two@{Log\+Base\+Two}!Ace@{Ace}}
\subsubsection[{Log\+Base\+Two(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Log\+Base\+Two (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a62426fd59f8c699fc66a5a738cec3e86}


Calculates the logarithm (log) base 2 of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} retVal = Ace::LogBaseTwo(69);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:6


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its logarithm base 2.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The logarithm base 2 of num. If a mathematical error occurs or num is negative, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Mod@{Mod}}
\index{Mod@{Mod}!Ace@{Ace}}
\subsubsection[{Mod(double numerator, double denominator)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Mod (
\begin{DoxyParamCaption}
\item[{double}]{numerator, }
\item[{double}]{denominator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6529499a01bc16109f19ebcb719019f7}


Computes the floating-\/point remainder of the division operation numerator/denominator in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::Mod(9.0, 5.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:4.\+000000


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The remainder of the division operation. If a mathematical error occurs or if denominator equals 0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Mod@{Mod}}
\index{Mod@{Mod}!Ace@{Ace}}
\subsubsection[{Mod(float numerator, float denominator)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Mod (
\begin{DoxyParamCaption}
\item[{float}]{numerator, }
\item[{float}]{denominator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac623f8d6f81e2b1725ca7039815a94c7}


Computes the floating-\/point remainder of the division operation numerator/denominator in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::Mod(9.0f, 5.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:4.\+000000


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The remainder of the division operation. If a mathematical error occurs or if denominator equals 0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Mod@{Mod}}
\index{Mod@{Mod}!Ace@{Ace}}
\subsubsection[{Mod(int numerator, int denominator)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Mod (
\begin{DoxyParamCaption}
\item[{int}]{numerator, }
\item[{int}]{denominator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6db0067235bda30dcdfd4181ce2fcf43}


Computes the floating-\/point remainder of the division operation numerator/denominator in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::Mod(9, 5);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:4


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The remainder of the division operation. If a mathematical error occurs or if denominator equals 0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Multiply\+Then\+Add@{Multiply\+Then\+Add}}
\index{Multiply\+Then\+Add@{Multiply\+Then\+Add}!Ace@{Ace}}
\subsubsection[{Multiply\+Then\+Add(double mult\+One, double mult\+Two, double add)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Multiply\+Then\+Add (
\begin{DoxyParamCaption}
\item[{double}]{mult\+One, }
\item[{double}]{mult\+Two, }
\item[{double}]{add}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9521670cd2b0a4f90f58ee430e26a44c}


Calculates the product of mult\+One $\ast$ mult\+Two, then adds add to that product (i.\+e. 

(mult\+One $\ast$ mult\+Two) + add). Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::MultiplyThenAdd(9.0, 3.0, 15.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:42.\+000000


\begin{DoxyParams}{Parameters}
{\em mult\+One} & Number to multiply. \\
\hline
{\em mult\+Two} & Other number to multiply. \\
\hline
{\em add} & Number to add to the product of mult\+One $\ast$ mult\+Two.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of (mult\+One $\ast$ mult\+Two) + add. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Multiply\+Then\+Add@{Multiply\+Then\+Add}}
\index{Multiply\+Then\+Add@{Multiply\+Then\+Add}!Ace@{Ace}}
\subsubsection[{Multiply\+Then\+Add(float mult\+One, float mult\+Two, float add)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Multiply\+Then\+Add (
\begin{DoxyParamCaption}
\item[{float}]{mult\+One, }
\item[{float}]{mult\+Two, }
\item[{float}]{add}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a934487848d6a37fef098f48d77473849}


Calculates the product of mult\+One $\ast$ mult\+Two, then adds add to that product (i.\+e. 

(mult\+One $\ast$ mult\+Two) + add). Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016 try \{ float result = \doxyref{Ace\+::\+Multiply\+Then\+Add}{p.}{class_ace_a9521670cd2b0a4f90f58ee430e26a44c}(9.\+0f, 3.\+0f, 15.\+0f); printf(\char`\"{}\%f\textbackslash{}n\char`\"{}, result); \} catch (char$\ast$ exception\+Message) \{ printf(\char`\"{}\%s\textbackslash{}n\char`\"{}, exception\+Message); \}
\end{DoxyDate}
Output\+:42.\+000000


\begin{DoxyParams}{Parameters}
{\em mult\+One} & Number to multiply. \\
\hline
{\em mult\+Two} & Other number to multiply. \\
\hline
{\em add} & Number to add to the product of mult\+One $\ast$ mult\+Two.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of (mult\+One $\ast$ mult\+Two) + add. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Multiply\+Then\+Add@{Multiply\+Then\+Add}}
\index{Multiply\+Then\+Add@{Multiply\+Then\+Add}!Ace@{Ace}}
\subsubsection[{Multiply\+Then\+Add(int mult\+One, int mult\+Two, int add)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Multiply\+Then\+Add (
\begin{DoxyParamCaption}
\item[{int}]{mult\+One, }
\item[{int}]{mult\+Two, }
\item[{int}]{add}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4567d1d43445af6391ef7ffe13860550}


Calculates the product of mult\+One $\ast$ mult\+Two, then adds add to that product (i.\+e. 

(mult\+One $\ast$ mult\+Two) + add). Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::MultiplyThenAdd(9, 3, 15);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:42


\begin{DoxyParams}{Parameters}
{\em mult\+One} & Number to multiply. \\
\hline
{\em mult\+Two} & Other number to multiply. \\
\hline
{\em add} & Number to add to the product of mult\+One $\ast$ mult\+Two.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of (mult\+One $\ast$ mult\+Two) + add. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Natural\+Log@{Natural\+Log}}
\index{Natural\+Log@{Natural\+Log}!Ace@{Ace}}
\subsubsection[{Natural\+Log(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Natural\+Log (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a69ddb0ab24047c5175b3dc4fb3e8f3c6}


Calculates the Natural Logarithm (ln) of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} retVal = Ace::NaturalLog(69.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:4.\+234107


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its Natural Logarithm.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Natural Logarithm of num. If a mathematical error occurs or num is negative, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Natural\+Log@{Natural\+Log}}
\index{Natural\+Log@{Natural\+Log}!Ace@{Ace}}
\subsubsection[{Natural\+Log(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Natural\+Log (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae5ac7b240b43c5af775695af889c1734}


Calculates the Natural Logarithm (ln) of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} retVal = Ace::NaturalLog(69.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:4.\+234107


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its Natural Logarithm.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Natural Logarithm of num. If a mathematical error occurs or num is negative, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Natural\+Log@{Natural\+Log}}
\index{Natural\+Log@{Natural\+Log}!Ace@{Ace}}
\subsubsection[{Natural\+Log(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Natural\+Log (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_afb72e9a106cb2e15d558796515efa19a}


Calculates the Natural Logarithm (ln) of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} retVal = Ace::NaturalLog(69);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:4


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its Natural Logarithm.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Natural Logarithm of num. If a mathematical error occurs or num is negative, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Natural\+Log\+Gamma\+Function@{Natural\+Log\+Gamma\+Function}}
\index{Natural\+Log\+Gamma\+Function@{Natural\+Log\+Gamma\+Function}!Ace@{Ace}}
\subsubsection[{Natural\+Log\+Gamma\+Function(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Natural\+Log\+Gamma\+Function (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2a3aa781cdf81480b5e1ce5075649ed4}


Calculates The Natural Log (ln) of The Gamma Function (ln $\vert$ (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] $\vert$). 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::NaturalLogGammaFunction(5.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:3.\+178054


\begin{DoxyParams}{Parameters}
{\em num} & Number to use for t$^\wedge$num-\/1 in the equation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of calculating The Gamma Function for t$^\wedge$num-\/1. If a mathematical error occurs or if num is less than or equal to 0.\+0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Natural\+Log\+Gamma\+Function@{Natural\+Log\+Gamma\+Function}}
\index{Natural\+Log\+Gamma\+Function@{Natural\+Log\+Gamma\+Function}!Ace@{Ace}}
\subsubsection[{Natural\+Log\+Gamma\+Function(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Natural\+Log\+Gamma\+Function (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a698a0b446107e5226c61faa3f3922277}


Calculates The Natural Log (ln) of The Gamma Function (ln $\vert$ (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] $\vert$). 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::NaturalLogGammaFunction(5.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:3.\+178054


\begin{DoxyParams}{Parameters}
{\em num} & Number to use for t$^\wedge$num-\/1 in the equation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of calculating The Gamma Function for t$^\wedge$num-\/1. If a mathematical error occurs or if num is less than or equal to 0.\+0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Natural\+Log\+Gamma\+Function@{Natural\+Log\+Gamma\+Function}}
\index{Natural\+Log\+Gamma\+Function@{Natural\+Log\+Gamma\+Function}!Ace@{Ace}}
\subsubsection[{Natural\+Log\+Gamma\+Function(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Natural\+Log\+Gamma\+Function (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af132654e86e8f6ee24e87e469fc8bae4}


Calculates The Natural Log (ln) of The Gamma Function (ln $\vert$ (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] $\vert$). 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::NaturalLogGammaFunction(5);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:3


\begin{DoxyParams}{Parameters}
{\em num} & Number to use for t$^\wedge$num-\/1 in the equation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of calculating The Gamma Function for t$^\wedge$num-\/1. If a mathematical error occurs or if num is less than or equal to 0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Next\+Index\+Of@{Next\+Index\+Of}}
\index{Next\+Index\+Of@{Next\+Index\+Of}!Ace@{Ace}}
\subsubsection[{Next\+Index\+Of(char $\ast$str\+To\+Search, char char\+To\+Look\+For, int start\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Next\+Index\+Of (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char}]{char\+To\+Look\+For, }
\item[{int}]{start\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a12241a4abf6a86ad707789cbe9979dd7}


Retrieves the first occurrence of char\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/10/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} retVal = Ace::NextIndexOf(\textcolor{stringliteral}{"I wish I blew it up instead...wicked."}, \textcolor{charliteral}{'I'}, 1);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:7


\begin{DoxyParams}{Parameters}
{\em str\+To\+Search} & String to search through. \\
\hline
{\em char\+To\+Look\+For} & Character to look for in str\+To\+Search. \\
\hline
{\em start\+Index} & Index to start looking.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The index of the first occurrence of char\+To\+Look\+For starting from start\+Index. If not found, -\/1 is returned. Throws an exception if str\+To\+Search is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Next\+Index\+Of@{Next\+Index\+Of}}
\index{Next\+Index\+Of@{Next\+Index\+Of}!Ace@{Ace}}
\subsubsection[{Next\+Index\+Of(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t char\+To\+Look\+For, int start\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Next\+Index\+Of (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t}]{char\+To\+Look\+For, }
\item[{int}]{start\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aeb1c9d5abc5fca76246008bada3bc55d}


Retrieves the first occurrence of char\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/10/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} retVal = Ace::NextIndexOf(L\textcolor{stringliteral}{"I wish I blew it up instead...wicked."}, L\textcolor{charliteral}{'I'}, 1);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:7


\begin{DoxyParams}{Parameters}
{\em str\+To\+Search} & Wide String to search through. \\
\hline
{\em char\+To\+Look\+For} & Wide Character to look for in str\+To\+Search. \\
\hline
{\em start\+Index} & Index to start looking.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The index of the first occurrence of char\+To\+Look\+For starting from start\+Index. If not found, -\/1 is returned. Throws an exception if str\+To\+Search is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Next\+Index\+Of@{Next\+Index\+Of}}
\index{Next\+Index\+Of@{Next\+Index\+Of}!Ace@{Ace}}
\subsubsection[{Next\+Index\+Of(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For, int start\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Next\+Index\+Of (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For, }
\item[{int}]{start\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aeb3c690712a0eb95f5dd60ebb6ea0120}


Retrieves the first occurrence of str\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/10/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} retVal = Ace::NextIndexOf(\textcolor{stringliteral}{"I wish I blew it up instead...wicked."}, \textcolor{stringliteral}{"wicked"}, 1);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:30


\begin{DoxyParams}{Parameters}
{\em str\+To\+Search} & String to search through. \\
\hline
{\em str\+To\+Look\+For} & String to look for in str\+To\+Search. \\
\hline
{\em start\+Index} & Index to start looking.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The index of the first occurrence of str\+To\+Look\+For starting from start\+Index. If not found, -\/1 is returned. Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Next\+Index\+Of@{Next\+Index\+Of}}
\index{Next\+Index\+Of@{Next\+Index\+Of}!Ace@{Ace}}
\subsubsection[{Next\+Index\+Of(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For, int start\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Next\+Index\+Of (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For, }
\item[{int}]{start\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0af0979cd0675ebeff6ff99621593f3d}


Retrieves the first occurrence of str\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/10/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} retVal = Ace::NextIndexOf(L\textcolor{stringliteral}{"I wish I blew it up instead...wicked."}, L\textcolor{stringliteral}{"wicked"}, 1);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:30


\begin{DoxyParams}{Parameters}
{\em str\+To\+Search} & Wide String to search through. \\
\hline
{\em str\+To\+Look\+For} & Wide String to look for in str\+To\+Search. \\
\hline
{\em start\+Index} & Index to start looking.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The index of the first occurrence of str\+To\+Look\+For starting from start\+Index. If not found, -\/1 is returned. Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Num\+Times\+Two\+To\+The\+X\+Power@{Num\+Times\+Two\+To\+The\+X\+Power}}
\index{Num\+Times\+Two\+To\+The\+X\+Power@{Num\+Times\+Two\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{Num\+Times\+Two\+To\+The\+X\+Power(double num, double power)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Num\+Times\+Two\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{double}]{num, }
\item[{double}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9beab58661041127b9073ec5ff8a275a}


Calculates num $\ast$ 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::NumTimesTwoToTheXPower(1.0 / 3.0, 5.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:10.\+666667


\begin{DoxyParams}{Parameters}
{\em num} & Number to multiply 2$^\wedge$power by. \\
\hline
{\em power} & Number to raise 2 to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of num $\ast$ 2$^\wedge$power. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Num\+Times\+Two\+To\+The\+X\+Power@{Num\+Times\+Two\+To\+The\+X\+Power}}
\index{Num\+Times\+Two\+To\+The\+X\+Power@{Num\+Times\+Two\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{Num\+Times\+Two\+To\+The\+X\+Power(float num, float power)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Num\+Times\+Two\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{float}]{num, }
\item[{float}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a432c3d7cf654920eb21e72f0711db3d5}


Calculates num $\ast$ 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::NumTimesTwoToTheXPower(1.0f / 3.0f, 5.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:10.\+666667


\begin{DoxyParams}{Parameters}
{\em num} & Number to multiply 2$^\wedge$power by. \\
\hline
{\em power} & Number to raise 2 to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of num $\ast$ 2$^\wedge$power. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Num\+Times\+Two\+To\+The\+X\+Power@{Num\+Times\+Two\+To\+The\+X\+Power}}
\index{Num\+Times\+Two\+To\+The\+X\+Power@{Num\+Times\+Two\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{Num\+Times\+Two\+To\+The\+X\+Power(int num, int power)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Num\+Times\+Two\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{int}]{num, }
\item[{int}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_acc050e2e414cffd28866a6e6f3997d7d}


Calculates num $\ast$ 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::NumTimesTwoToTheXPower(3, 5);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:96


\begin{DoxyParams}{Parameters}
{\em num} & Number to multiply 2$^\wedge$power by. \\
\hline
{\em power} & Number to raise 2 to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of num $\ast$ 2$^\wedge$power. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Positive\+Difference@{Positive\+Difference}}
\index{Positive\+Difference@{Positive\+Difference}!Ace@{Ace}}
\subsubsection[{Positive\+Difference(double num\+One, double num\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Positive\+Difference (
\begin{DoxyParamCaption}
\item[{double}]{num\+One, }
\item[{double}]{num\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5a64e64344fe2e67ba61a945d29ac95a}


Calculates the difference between num\+One and num\+Two only if num\+One $>$ num\+Two. 

If num\+One $<$= num\+Two then 0 is returned. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::PositiveDifference(6.3, 2.7);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:3.\+600000


\begin{DoxyParams}{Parameters}
{\em num\+One} & Number to use for subtraction. \\
\hline
{\em num\+Two} & Other number to use for subtraction.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If num\+One is larger then num\+Two; then num\+One -\/ num\+Two is returned, else 0 is returned. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Positive\+Difference@{Positive\+Difference}}
\index{Positive\+Difference@{Positive\+Difference}!Ace@{Ace}}
\subsubsection[{Positive\+Difference(float num\+One, float num\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Positive\+Difference (
\begin{DoxyParamCaption}
\item[{float}]{num\+One, }
\item[{float}]{num\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a94ec5e1a6548f4dc778e26c4049dc6e0}


Calculates the difference between num\+One and num\+Two only if num\+One $>$ num\+Two. 

If num\+One $<$= num\+Two then 0 is returned. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::PositiveDifference(6.3f, 2.7f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:3.\+600000


\begin{DoxyParams}{Parameters}
{\em num\+One} & Number to use for subtraction. \\
\hline
{\em num\+Two} & Other number to use for subtraction.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If num\+One is larger then num\+Two; then num\+One -\/ num\+Two is returned, else 0 is returned. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Positive\+Difference@{Positive\+Difference}}
\index{Positive\+Difference@{Positive\+Difference}!Ace@{Ace}}
\subsubsection[{Positive\+Difference(int num\+One, int num\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Positive\+Difference (
\begin{DoxyParamCaption}
\item[{int}]{num\+One, }
\item[{int}]{num\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa6a08895766682d1fd44a869a4823e50}


Calculates the difference between num\+One and num\+Two only if num\+One $>$ num\+Two. 

If num\+One $<$= num\+Two then 0 is returned. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::PositiveDifference(6, 2);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:4


\begin{DoxyParams}{Parameters}
{\em num\+One} & Number to use for subtraction. \\
\hline
{\em num\+Two} & Other number to use for subtraction.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If num\+One is larger then num\+Two; then num\+One -\/ num\+Two is returned, else 0 is returned. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Power@{Power}}
\index{Power@{Power}!Ace@{Ace}}
\subsubsection[{Power(double base, double exponent)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Power (
\begin{DoxyParamCaption}
\item[{double}]{base, }
\item[{double}]{exponent}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_adbcb9f24f9c412d29d7b671a3aa16c42}


Takes the provided base and raises it to the exponent (power). 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/29/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} powResult = Ace::Power(2.0, 5.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, powResult);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:32.\+000000


\begin{DoxyParams}{Parameters}
{\em base} & Number to raise. \\
\hline
{\em exponent} & Number of times to multiply base by itself.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The base raised to the exponent is returned. If a mathematical error occurs or base is 0.\+0 and exponent is less than or equal to 0.\+0 OR base is negative, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Power@{Power}}
\index{Power@{Power}!Ace@{Ace}}
\subsubsection[{Power(float base, float exponent)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Power (
\begin{DoxyParamCaption}
\item[{float}]{base, }
\item[{float}]{exponent}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abd44bbcb8b34e13bf23013af2522839d}


Takes the provided base and raises it to the exponent (power). 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} powResult = Ace::Power(2.0f, 5.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, powResult);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:32.\+000000


\begin{DoxyParams}{Parameters}
{\em base} & Number to raise. \\
\hline
{\em exponent} & Number of times to multiply base by itself.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The base raised to the exponent is returned. If a mathematical error occurs or base is 0.\+0 and exponent is less than or equal to 0.\+0 OR base is negative, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Power@{Power}}
\index{Power@{Power}!Ace@{Ace}}
\subsubsection[{Power(int base, int exponent)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Power (
\begin{DoxyParamCaption}
\item[{int}]{base, }
\item[{int}]{exponent}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad951abbecc70cd553935d77e9d00e703}


Takes the provided base and raises it to the exponent (power). 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} powResult = Ace::Power(2, 5);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, powResult);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:32


\begin{DoxyParams}{Parameters}
{\em base} & Number to raise. \\
\hline
{\em exponent} & Number of times to multiply base by itself.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The base raised to the exponent is returned. If a mathematical error occurs or base is 0 and exponent is less than or equal to 0 OR base is negative, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Radians\+To\+Degrees@{Radians\+To\+Degrees}}
\index{Radians\+To\+Degrees@{Radians\+To\+Degrees}!Ace@{Ace}}
\subsubsection[{Radians\+To\+Degrees(double radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Radians\+To\+Degrees (
\begin{DoxyParamCaption}
\item[{double}]{radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4acd795a7bf9c65be8e4c4f5d5647ba0}


Converts a number from radians to degrees. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/16/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} rad = 1.570796;
\textcolor{keywordtype}{double} deg = Ace::RadiansToDegrees(rad);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, deg);
\end{DoxyCode}
 Output\+:89.\+999981


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em radians} & Radians to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Degrees. 
\end{DoxyReturn}
\index{Ace@{Ace}!Radians\+To\+Degrees@{Radians\+To\+Degrees}}
\index{Radians\+To\+Degrees@{Radians\+To\+Degrees}!Ace@{Ace}}
\subsubsection[{Radians\+To\+Degrees(float radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Radians\+To\+Degrees (
\begin{DoxyParamCaption}
\item[{float}]{radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a38a090d5bd7b5b5cff8650f259ee35ce}


Converts a number from radians to degrees. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/16/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} rad = 1.570796f;
\textcolor{keywordtype}{float} deg = Ace::RadiansToDegrees(rad);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, deg);
\end{DoxyCode}
 Output\+:89.\+999981


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em radians} & Radians to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Degrees. 
\end{DoxyReturn}
\index{Ace@{Ace}!Radians\+To\+Degrees@{Radians\+To\+Degrees}}
\index{Radians\+To\+Degrees@{Radians\+To\+Degrees}!Ace@{Ace}}
\subsubsection[{Radians\+To\+Degrees(int radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Radians\+To\+Degrees (
\begin{DoxyParamCaption}
\item[{int}]{radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5c579085396a15f5aac5334e98fb9335}


Converts a number from radians to degrees. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/16/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} rad = 1;
\textcolor{keywordtype}{int} deg = Ace::RadiansToDegrees(rad);
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, deg);
\end{DoxyCode}
 Output\+:57


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em radians} & Radians to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Degrees. 
\end{DoxyReturn}
\index{Ace@{Ace}!Read\+Binary\+File@{Read\+Binary\+File}}
\index{Read\+Binary\+File@{Read\+Binary\+File}!Ace@{Ace}}
\subsubsection[{Read\+Binary\+File(char $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size=\+M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+Z\+E, const char $\ast$mode=""rb"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Read\+Binary\+File (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Path, }
\item[{size\+\_\+t}]{num\+Bytes\+To\+Read = {\ttfamily 0}, }
\item[{size\+\_\+t}]{max\+Buffer\+Size = {\ttfamily {\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}}, }
\item[{const char $\ast$}]{mode = {\ttfamily \char`\"{}rb\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9700d7264c30af90d9787a82c77170bb}


Opens a file for reading and returns a char buffer containing some or all of the data in the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* retVal = Ace::ReadBinaryFile(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)lookupdata.bin"});
    printf(\textcolor{stringliteral}{"%x\(\backslash\)0"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})retVal);
    \_aligned\_free(retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:(binary file data can\textquotesingle{}t be displayed).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
 & {\em num\+Bytes\+To\+Read} & The size of the buffer (the number bytes read in). If 0; num\+Bytes\+To\+Read = max\+Buffer\+Size. \\
\hline
 & {\em max\+Buffer\+Size} & Maximum number of bytes to read. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}r\char`\"{} for read, \char`\"{}r+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Number of bytes to offset from origin. \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The buffer containing the file data of size num\+Bytes\+To\+Read. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Read\+Binary\+FileW@{Read\+Binary\+FileW}}
\index{Read\+Binary\+FileW@{Read\+Binary\+FileW}!Ace@{Ace}}
\subsubsection[{Read\+Binary\+File\+W(wchar\+\_\+t $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size=\+M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+Z\+E, const wchar\+\_\+t $\ast$mode=L""rb, ccs=\+U\+T\+F-\/8"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Read\+Binary\+FileW (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Path, }
\item[{size\+\_\+t}]{num\+Bytes\+To\+Read = {\ttfamily 0}, }
\item[{size\+\_\+t}]{max\+Buffer\+Size = {\ttfamily {\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}}, }
\item[{const wchar\+\_\+t $\ast$}]{mode = {\ttfamily L\char`\"{}rb,~ccs=UTF-\/8\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a38223fc1f30e753afb34313ce190fc09}


Opens a file for reading and returns a wide char buffer containing some or all of the data in the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{comment}{//By default, read mode is set to "r, ccs=UTF-8".}
    \textcolor{keywordtype}{wchar\_t}* retVal = Ace::ReadBinaryFileW(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)lookupdata.bin"});
    printf(\textcolor{stringliteral}{"%x\(\backslash\)0"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})retVal);
    \_aligned\_free(retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:(binary file data can\textquotesingle{}t be displayed).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
 & {\em num\+Bytes\+To\+Read} & The size of the buffer (the number bytes read in). If 0; num\+Bytes\+To\+Read = max\+Buffer\+Size. \\
\hline
 & {\em max\+Buffer\+Size} & Maximum number of bytes to read. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}r\char`\"{} for read, \char`\"{}r, ccs=\+U\+T\+F-\/8\char`\"{} for read unicode, \char`\"{}r+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Number of bytes to offset from origin. \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The buffer containing the file data of size num\+Bytes\+To\+Read. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Read\+Text\+File@{Read\+Text\+File}}
\index{Read\+Text\+File@{Read\+Text\+File}!Ace@{Ace}}
\subsubsection[{Read\+Text\+File(char $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size=\+M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+Z\+E, const char $\ast$mode=""r"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Read\+Text\+File (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Path, }
\item[{size\+\_\+t}]{num\+Bytes\+To\+Read = {\ttfamily 0}, }
\item[{size\+\_\+t}]{max\+Buffer\+Size = {\ttfamily {\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}}, }
\item[{const char $\ast$}]{mode = {\ttfamily \char`\"{}r\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a66dfff3d59c12f04d7d45841ad8a1e85}


Opens a file for reading and returns a char buffer containing some or all of the data in the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/12/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* retVal = Ace::ReadTextFile(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)dicks.txt"});
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, retVal);
    \_aligned\_free(retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:dicksdicksdicksdicksdicksdicksdick8=$>$


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
 & {\em num\+Bytes\+To\+Read} & The size of the buffer (the number bytes read in). If 0; num\+Bytes\+To\+Read = max\+Buffer\+Size. \\
\hline
 & {\em max\+Buffer\+Size} & Maximum number of bytes to read. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}r\char`\"{} for read, \char`\"{}r+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Either zero, or a value returned by ftell(). \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The buffer containing the file data of size num\+Bytes\+To\+Read. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Read\+Text\+FileW@{Read\+Text\+FileW}}
\index{Read\+Text\+FileW@{Read\+Text\+FileW}!Ace@{Ace}}
\subsubsection[{Read\+Text\+File\+W(wchar\+\_\+t $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size=\+M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+Z\+E, const wchar\+\_\+t $\ast$mode=L""r, ccs=\+U\+T\+F-\/8"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Read\+Text\+FileW (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Path, }
\item[{size\+\_\+t}]{num\+Bytes\+To\+Read = {\ttfamily 0}, }
\item[{size\+\_\+t}]{max\+Buffer\+Size = {\ttfamily {\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}}, }
\item[{const wchar\+\_\+t $\ast$}]{mode = {\ttfamily L\char`\"{}r,~ccs=UTF-\/8\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a66aaa5acfe5830750b2c1d0658ac281b}


Opens a file for reading and returns a wide char buffer containing some or all of the data in the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{comment}{//By default, read mode is set to "r, ccs=UTF-8".}
    \textcolor{keywordtype}{wchar\_t}* retVal = Ace::ReadTextFileW(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)jap.txt"});
    MessageBoxW(NULL, retVal, NULL, 0);
    \_aligned\_free(retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
 & {\em num\+Bytes\+To\+Read} & The size of the buffer (the number bytes read in). If 0; num\+Bytes\+To\+Read = max\+Buffer\+Size. \\
\hline
 & {\em max\+Buffer\+Size} & Maximum number of bytes to read. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}r\char`\"{} for read, \char`\"{}r, ccs=\+U\+T\+F-\/8\char`\"{} for read unicode, \char`\"{}r+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Either zero, or a value returned by ftell(). \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The buffer containing the file data of size num\+Bytes\+To\+Read. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remainder@{Remainder}}
\index{Remainder@{Remainder}!Ace@{Ace}}
\subsubsection[{Remainder(double numerator, double denominator)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Remainder (
\begin{DoxyParamCaption}
\item[{double}]{numerator, }
\item[{double}]{denominator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0f05443f499ce94d53c3a5e584460d52}


Calculates the Computes The I\+E\+EE remainder of the floating point division operation numerator/denominator. 

In contrast to \doxyref{Mod()}{p.}{class_ace_a6529499a01bc16109f19ebcb719019f7}; the returned value is not guaranteed to have the same sign as the numerator. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::Remainder(-5.1, 3.2);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1.\+300000


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The I\+E\+EE remainder of the floating point division. If a mathematical error occurs or denominator equals 0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remainder@{Remainder}}
\index{Remainder@{Remainder}!Ace@{Ace}}
\subsubsection[{Remainder(float numerator, float denominator)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Remainder (
\begin{DoxyParamCaption}
\item[{float}]{numerator, }
\item[{float}]{denominator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af4dcc33bb8d85f3b654edbcb0912f88b}


Calculates the Computes The I\+E\+EE remainder of the floating point division operation numerator/denominator. 

In contrast to \doxyref{Mod()}{p.}{class_ace_a6529499a01bc16109f19ebcb719019f7}; the returned value is not guaranteed to have the same sign as the numerator. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::Remainder(-5.1f, 3.2f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1.\+300000


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The I\+E\+EE remainder of the floating point division. If a mathematical error occurs or denominator equals 0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remainder@{Remainder}}
\index{Remainder@{Remainder}!Ace@{Ace}}
\subsubsection[{Remainder(int numerator, int denominator)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Remainder (
\begin{DoxyParamCaption}
\item[{int}]{numerator, }
\item[{int}]{denominator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a87b5679163cbd8394fecf8a809b0506e}


Calculates the Computes The I\+E\+EE remainder of the floating point division operation numerator/denominator. 

In contrast to \doxyref{Mod()}{p.}{class_ace_a6529499a01bc16109f19ebcb719019f7}; the returned value is not guaranteed to have the same sign as the numerator. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::Remainder(-5, 3);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The I\+E\+EE remainder of the floating point division. If a mathematical error occurs or denominator equals 0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remainder\+With\+Quadrant@{Remainder\+With\+Quadrant}}
\index{Remainder\+With\+Quadrant@{Remainder\+With\+Quadrant}!Ace@{Ace}}
\subsubsection[{Remainder\+With\+Quadrant(double numerator, double denominator, int $\ast$out\+Quadrant)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Remainder\+With\+Quadrant (
\begin{DoxyParamCaption}
\item[{double}]{numerator, }
\item[{double}]{denominator, }
\item[{int $\ast$}]{out\+Quadrant}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a83c9c251b60c0becf2ff3b5f6fc3f0ab}


Calculates the floating-\/point remainder of the division operation numerator/denominator the same way the \doxyref{Remainder()}{p.}{class_ace_a0f05443f499ce94d53c3a5e584460d52} function does. 

Additionally, the sign and at least the three of the last bits of numerator/denominator will be stored in out\+Quadrant, sufficient to determine the quadrant of the result within a period. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} quadrant;
\textcolor{keywordtype}{double} result = Ace::RemainderWithQuadrant(-5.1, 3.2, &quadrant);
quadrant = (\textcolor{keywordtype}{unsigned} int)quadrant % 4;
printf(\textcolor{stringliteral}{"%f Quadrant:%d\(\backslash\)n"}, result, quadrant);
\end{DoxyCode}
 Output\+:1.\+300000 Quadrant\+:2


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by. \\
\hline
{\em out\+Quadrant} & Sign to indicate the quadrant.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The I\+E\+EE remainder of the floating point division and the quadrant data. If a mathematical error occurs or denominator equals 0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remainder\+With\+Quadrant@{Remainder\+With\+Quadrant}}
\index{Remainder\+With\+Quadrant@{Remainder\+With\+Quadrant}!Ace@{Ace}}
\subsubsection[{Remainder\+With\+Quadrant(float numerator, float denominator, int $\ast$out\+Quadrant)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Remainder\+With\+Quadrant (
\begin{DoxyParamCaption}
\item[{float}]{numerator, }
\item[{float}]{denominator, }
\item[{int $\ast$}]{out\+Quadrant}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9aeabf43c45659c6024a4dce1ae2a1cc}


Calculates the floating-\/point remainder of the division operation numerator/denominator the same way the \doxyref{Remainder()}{p.}{class_ace_a0f05443f499ce94d53c3a5e584460d52} function does. 

Additionally, the sign and at least the three of the last bits of numerator/denominator will be stored in out\+Quadrant, sufficient to determine the quadrant of the result within a period. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} quadrant;
\textcolor{keywordtype}{float} result = Ace::RemainderWithQuadrant(-5.1f, 3.2f, &quadrant);
quadrant = (\textcolor{keywordtype}{unsigned} int)quadrant % 4;
printf(\textcolor{stringliteral}{"%f Quadrant:%d\(\backslash\)n"}, result, quadrant);
\end{DoxyCode}
 Output\+:1.\+300000 Quadrant\+:2


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by. \\
\hline
{\em out\+Quadrant} & Sign to indicate the quadrant.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The I\+E\+EE remainder of the floating point division and the quadrant data. If a mathematical error occurs or denominator equals 0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remainder\+With\+Quadrant@{Remainder\+With\+Quadrant}}
\index{Remainder\+With\+Quadrant@{Remainder\+With\+Quadrant}!Ace@{Ace}}
\subsubsection[{Remainder\+With\+Quadrant(int numerator, int denominator, int $\ast$out\+Quadrant)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Remainder\+With\+Quadrant (
\begin{DoxyParamCaption}
\item[{int}]{numerator, }
\item[{int}]{denominator, }
\item[{int $\ast$}]{out\+Quadrant}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a858e4255eb19efbee6439ddecd4067af}


Calculates the floating-\/point remainder of the division operation numerator/denominator the same way the \doxyref{Remainder()}{p.}{class_ace_a0f05443f499ce94d53c3a5e584460d52} function does. 

Additionally, the sign and at least the three of the last bits of numerator/denominator will be stored in out\+Quadrant, sufficient to determine the quadrant of the result within a period. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} quadrant;
\textcolor{keywordtype}{int} result = Ace::RemainderWithQuadrant(-5, 3, &quadrant);
quadrant = (\textcolor{keywordtype}{unsigned} int)quadrant % 4;
printf(\textcolor{stringliteral}{"%d Quadrant:%d\(\backslash\)n"}, result, quadrant);
\end{DoxyCode}
 Output\+:1 Quadrant\+:2


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by. \\
\hline
{\em out\+Quadrant} & Sign to indicate the quadrant.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The I\+E\+EE remainder of the floating point division and the quadrant data. If a mathematical error occurs or denominator equals 0, then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+All\+Whitespace@{Remove\+All\+Whitespace}}
\index{Remove\+All\+Whitespace@{Remove\+All\+Whitespace}!Ace@{Ace}}
\subsubsection[{Remove\+All\+Whitespace(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Remove\+All\+Whitespace (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae41b2d2f89451e9659550845170d328a}


Removes all whitespace from a given string. 

A newly allocated string is returned that has all whitespace removed from it.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* temp = Ace::RemoveAllWhitespace(\textcolor{stringliteral}{"E dd\(\backslash\)t i  e "});
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, temp);
    \_aligned\_free(temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to remove whitespace from.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string containing no whitespace. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+All\+Whitespace@{Remove\+All\+Whitespace}}
\index{Remove\+All\+Whitespace@{Remove\+All\+Whitespace}!Ace@{Ace}}
\subsubsection[{Remove\+All\+Whitespace(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Remove\+All\+Whitespace (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a869247b2abaeca31aff7e12d030e0872}


Removes all whitespace from a given wide string. 

A newly allocated string is returned that has all whitespace removed from it.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* temp = Ace::RemoveAllWhitespace(L\textcolor{stringliteral}{"E dd\(\backslash\)t i  e "});
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, temp);
    \_aligned\_free(temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to remove whitespace from.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string containing no whitespace. Throws an exception if str is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+All\+Whitespace\+In\+Place@{Remove\+All\+Whitespace\+In\+Place}}
\index{Remove\+All\+Whitespace\+In\+Place@{Remove\+All\+Whitespace\+In\+Place}!Ace@{Ace}}
\subsubsection[{Remove\+All\+Whitespace\+In\+Place(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Remove\+All\+Whitespace\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a916dc3ddc85c0c5ad3840dfab4962f9e}


Removes all whitespace from a given string in place. 

This means That str is modified directly and as a result, no return value is needed. Assumes str is an allocated string and not a string literal.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* temp = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"E dd\(\backslash\)t i  e "});
    Ace::RemoveAllWhitespaceInPlace(temp);
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, temp);
    \_aligned\_free(temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str} & The string to directly modify and delete whitespace from. Throws an exception if str is N\+U\+LL. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Remove\+All\+Whitespace\+In\+Place@{Remove\+All\+Whitespace\+In\+Place}}
\index{Remove\+All\+Whitespace\+In\+Place@{Remove\+All\+Whitespace\+In\+Place}!Ace@{Ace}}
\subsubsection[{Remove\+All\+Whitespace\+In\+Place(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Remove\+All\+Whitespace\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aef98302ca6ffca2bf6ed13fd0f887a5d}


Removes all whitespace from a given wide string in place. 

This means That str is modified directly and as a result, no return value is needed. Assumes str is an allocated string and not a string literal.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* temp = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"E dd\(\backslash\)t i  e "});
    Ace::RemoveAllWhitespaceInPlace(temp);
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, temp);
    \_aligned\_free(temp);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str} & The wide string to directly modify and delete whitespace from. Throws an exception if str is N\+U\+LL. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Remove\+Characters\+From\+String@{Remove\+Characters\+From\+String}}
\index{Remove\+Characters\+From\+String@{Remove\+Characters\+From\+String}!Ace@{Ace}}
\subsubsection[{Remove\+Characters\+From\+String(char $\ast$str\+To\+Remove\+From, char char\+To\+Remove)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Remove\+Characters\+From\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Remove\+From, }
\item[{char}]{char\+To\+Remove}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac4f88cf4ac3842c748ed4222bf885660}


Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/12/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{char}* removedCharData = Ace::RemoveCharactersFromString(data, \textcolor{charliteral}{'a'});
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, removedCharData);
    \_aligned\_free(removedCharData);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Hs nyone ever been s fr s decided to be there nd then look more like?


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Remove\+From} & If non-\/null, to remove from. \\
\hline
 & {\em char\+To\+Remove} & The character to remove.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string with every occurrence of char\+To\+Remove removed. Throws an exception if str\+To\+Remove\+From is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+Characters\+From\+String@{Remove\+Characters\+From\+String}}
\index{Remove\+Characters\+From\+String@{Remove\+Characters\+From\+String}!Ace@{Ace}}
\subsubsection[{Remove\+Characters\+From\+String(wchar\+\_\+t $\ast$str\+To\+Remove\+From, wchar\+\_\+t char\+To\+Remove)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Remove\+Characters\+From\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Remove\+From, }
\item[{wchar\+\_\+t}]{char\+To\+Remove}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a517caf5b3abb9d9480f654afa2e9c121}


Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
    \textcolor{keywordtype}{wchar\_t}* removedCharData = Ace::RemoveCharactersFromString(data, L\textcolor{charliteral}{'a'});
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, removedCharData);
    \_aligned\_free(removedCharData);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Hs nyone ever been s fr s decided to be there nd then look more like?


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Remove\+From} & If non-\/null, to remove from. \\
\hline
 & {\em char\+To\+Remove} & The character to remove.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string with every occurrence of char\+To\+Remove removed. Throws an exception if str\+To\+Remove\+From is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+Characters\+From\+String\+In\+Place@{Remove\+Characters\+From\+String\+In\+Place}}
\index{Remove\+Characters\+From\+String\+In\+Place@{Remove\+Characters\+From\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Remove\+Characters\+From\+String\+In\+Place(char $\ast$str\+To\+Remove\+From, char char\+To\+Remove)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Remove\+Characters\+From\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Remove\+From, }
\item[{char}]{char\+To\+Remove}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7a4f21e66792a5813fc50775ae75091c}


Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. 

str\+To\+Remove\+From must be an allocated string since this function works directly on it.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/12/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* removedCharData = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there
       and then look more like?"});
    Ace::RemoveCharactersFromStringInPlace(removedCharData, \textcolor{charliteral}{'a'});
    printf(\textcolor{stringliteral}{"%s"}, removedCharData);
    \_aligned\_free(removedCharData);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Hs nyone ever been s fr s decided to be there nd then look more like?


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Remove\+From} & If non-\/null, to remove from. \\
\hline
 & {\em char\+To\+Remove} & The character to remove.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if str\+To\+Remove\+From is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+Characters\+From\+String\+In\+Place@{Remove\+Characters\+From\+String\+In\+Place}}
\index{Remove\+Characters\+From\+String\+In\+Place@{Remove\+Characters\+From\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Remove\+Characters\+From\+String\+In\+Place(wchar\+\_\+t $\ast$str\+To\+Remove\+From, wchar\+\_\+t char\+To\+Remove)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Remove\+Characters\+From\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Remove\+From, }
\item[{wchar\+\_\+t}]{char\+To\+Remove}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8b4630bd6fd620f1f9724a100f28acad}


Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. 

str\+To\+Remove\+From must be an allocated string since this function works directly on it.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* removedCharData = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be
       there and then look more like?"});
    Ace::RemoveCharactersFromStringInPlace(removedCharData, L\textcolor{charliteral}{'a'});
    printf(\textcolor{stringliteral}{"%S"}, removedCharData);
    \_aligned\_free(removedCharData);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Hs nyone ever been s fr s decided to be there nd then look more like?


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Remove\+From} & If non-\/null, to remove from. \\
\hline
 & {\em char\+To\+Remove} & The character to remove.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if str\+To\+Remove\+From is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+String\+From\+String@{Remove\+String\+From\+String}}
\index{Remove\+String\+From\+String@{Remove\+String\+From\+String}!Ace@{Ace}}
\subsubsection[{Remove\+String\+From\+String(char $\ast$str\+To\+Remove\+From, char $\ast$str\+To\+Remove, bool remove\+Only\+First\+Occurrence=false)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Remove\+String\+From\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Remove\+From, }
\item[{char $\ast$}]{str\+To\+Remove, }
\item[{bool}]{remove\+Only\+First\+Occurrence = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a504e21dc8f952771008044a2811c91e7}


Removes the specified string (str\+To\+Look\+For) from str\+To\+Search and returns a newly allocated buffer containing the result. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
11/2/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* retVal = Ace::RemoveStringFromString(\textcolor{stringliteral}{"Eddie has a small small dick."}, \textcolor{stringliteral}{"small "});
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, retVal);
    \_aligned\_free(retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie has a dick.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Search} & The string to directly parse and modify. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & The substring to look for. \\
\hline
 & {\em remove\+Only\+First\+Occurrence} & True if only the first occurrence of str\+To\+Look\+For should be removed.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+String\+From\+String@{Remove\+String\+From\+String}}
\index{Remove\+String\+From\+String@{Remove\+String\+From\+String}!Ace@{Ace}}
\subsubsection[{Remove\+String\+From\+String(wchar\+\_\+t $\ast$str\+To\+Remove\+From, wchar\+\_\+t $\ast$str\+To\+Remove, bool remove\+Only\+First\+Occurrence=false)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Remove\+String\+From\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Remove\+From, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Remove, }
\item[{bool}]{remove\+Only\+First\+Occurrence = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af119638980dc281d898338001d2b468a}


Removes the specified string (str\+To\+Look\+For) from str\+To\+Search and returns a newly allocated buffer containing the result. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
11/2/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* retVal = Ace::RemoveStringFromString(L\textcolor{stringliteral}{"Eddie has a small small dick."}, L\textcolor{stringliteral}{"small "});
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, retVal);
    \_aligned\_free(retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie has a dick.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Search} & The string to directly parse and modify. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & The substring to look for. \\
\hline
 & {\em remove\+Only\+First\+Occurrence} & True if only the first occurrence of str\+To\+Look\+For should be removed.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+String\+From\+String\+In\+Place@{Remove\+String\+From\+String\+In\+Place}}
\index{Remove\+String\+From\+String\+In\+Place@{Remove\+String\+From\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Remove\+String\+From\+String\+In\+Place(char $\ast$\&str\+To\+Remove\+From, char $\ast$str\+To\+Remove, bool remove\+Only\+First\+Occurrence=false)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Remove\+String\+From\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$\&}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For, }
\item[{bool}]{remove\+Only\+First\+Occurrence = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7e4cf99af9e3cd3f2a74fc29d72825c2}


Removes the specified string (str\+To\+Look\+For) by directly modifying str\+To\+Search. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
11/2/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* buffer = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"Eddie has a small small dick."});
    Ace::RemoveStringFromStringInPlace(buffer, \textcolor{stringliteral}{"small "});
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, buffer);
    \_aligned\_free(buffer);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie has a dick.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Search} & The string to directly parse and modify. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & The substring to look for. \\
\hline
 & {\em remove\+Only\+First\+Occurrence} & True if only the first occurrence of str\+To\+Look\+For should be removed.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+String\+From\+String\+In\+Place@{Remove\+String\+From\+String\+In\+Place}}
\index{Remove\+String\+From\+String\+In\+Place@{Remove\+String\+From\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Remove\+String\+From\+String\+In\+Place(wchar\+\_\+t $\ast$\&str\+To\+Remove\+From, wchar\+\_\+t $\ast$str\+To\+Remove, bool remove\+Only\+First\+Occurrence=false)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Remove\+String\+From\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$\&}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For, }
\item[{bool}]{remove\+Only\+First\+Occurrence = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac0a83c2d568dcc1249480e7173b3162a}


Removes the specified string (str\+To\+Look\+For) by directly modifying str\+To\+Search. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
11/2/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* buffer = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"Eddie has a small small dick."});
    Ace::RemoveStringFromStringInPlace(buffer, L\textcolor{stringliteral}{"small "});
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, buffer);
    \_aligned\_free(buffer);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie has a dick.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Search} & The string to directly parse and modify. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & The substring to look for. \\
\hline
 & {\em remove\+Only\+First\+Occurrence} & True if only the first occurrence of str\+To\+Look\+For should be removed.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Replace\+String@{Replace\+String}}
\index{Replace\+String@{Replace\+String}!Ace@{Ace}}
\subsubsection[{Replace\+String(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For, char $\ast$str\+To\+Replace\+With, bool remove\+Only\+First\+Occurrence=false)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Replace\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For, }
\item[{char $\ast$}]{str\+To\+Replace\+With, }
\item[{bool}]{remove\+Only\+First\+Occurrence = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af39e7d9f018b9ee33950b52ef9d14f14}


Inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. 

A newly allocated string is then returned.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = Ace::ReplaceString(\textcolor{stringliteral}{"Eddie is cool."}, \textcolor{stringliteral}{"is"}, \textcolor{stringliteral}{"is not"});
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie is not cool.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & The string to look through. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & The substring to look for. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Replace\+With} & The substring to replace with. \\
\hline
 & {\em remove\+Only\+First\+Occurrence} & True if only the first occurrence of str\+To\+Look\+For should be removed.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string with the change. Throws an exception if str\+To\+Search or str\+To\+Look\+For are N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Replace\+String@{Replace\+String}}
\index{Replace\+String@{Replace\+String}!Ace@{Ace}}
\subsubsection[{Replace\+String(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For, wchar\+\_\+t $\ast$str\+To\+Replace\+With, bool remove\+Only\+First\+Occurrence=false)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Replace\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Replace\+With, }
\item[{bool}]{remove\+Only\+First\+Occurrence = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a02967112e4ffe58c2874c73291cf774c}


Inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. 

A newly allocated wide string is then returned.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = Ace::ReplaceString(L\textcolor{stringliteral}{"Eddie is cool."}, L\textcolor{stringliteral}{"is"}, L\textcolor{stringliteral}{"is not"});
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie is not cool.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & The wide string to look through. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & The substring to look for. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Replace\+With} & The substring to replace with. \\
\hline
 & {\em remove\+Only\+First\+Occurrence} & True if only the first occurrence of str\+To\+Look\+For should be removed.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created wide string with the change. Throws an exception if str\+To\+Search or str\+To\+Look\+For are N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Replace\+String\+In\+Place@{Replace\+String\+In\+Place}}
\index{Replace\+String\+In\+Place@{Replace\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Replace\+String\+In\+Place(char $\ast$\&str\+To\+Search, char $\ast$str\+To\+Look\+For, char $\ast$str\+To\+Replace\+With, bool remove\+Only\+First\+Occurrence=false)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Replace\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$\&}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For, }
\item[{char $\ast$}]{str\+To\+Replace\+With, }
\item[{bool}]{remove\+Only\+First\+Occurrence = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a554b74fb326bd89ad29a0561b4d817e2}


Directly modifies and inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. 

Since str\+To\+Search is modified directly, there is no return value. data is re-\/allocated in order to hold the replacement string.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"Eddie is cool."});
    Ace::ReplaceStringInPlace(data, \textcolor{stringliteral}{"is"}, \textcolor{stringliteral}{"is not"});
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie is not cool.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Search} & The string to directly parse and modify. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & The substring to look for. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Replace\+With} & The substring to replace with. \\
\hline
 & {\em remove\+Only\+First\+Occurrence} & True if only the first occurrence of str\+To\+Look\+For should be removed.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Replace\+String\+In\+Place@{Replace\+String\+In\+Place}}
\index{Replace\+String\+In\+Place@{Replace\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Replace\+String\+In\+Place(wchar\+\_\+t $\ast$\&str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For, wchar\+\_\+t $\ast$str\+To\+Replace\+With, bool remove\+Only\+First\+Occurrence=false)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Replace\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$\&}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Replace\+With, }
\item[{bool}]{remove\+Only\+First\+Occurrence = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0cb3227573aff4a486f621c10f209d06}


Directly modifies and inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. 

Since str\+To\+Search is modified directly, there is no return value. data is re-\/allocated in order to hold the replacement wide string.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"Eddie is cool."});
    Ace::ReplaceStringInPlace(data, L\textcolor{stringliteral}{"is"}, L\textcolor{stringliteral}{"is not"});
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Eddie is not cool.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Search} & The wide string to directly parse and modify. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & The substring to look for. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Replace\+With} & The substring to replace with. \\
\hline
 & {\em remove\+Only\+First\+Occurrence} & True if only the first occurrence of str\+To\+Look\+For should be removed.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}}
\index{Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}!Ace@{Ace}}
\subsubsection[{Retrieve\+Data\+Between\+Tags(char $\ast$file\+Data, char $\ast$start\+Tag, char $\ast$end\+Tag)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Retrieve\+Data\+Between\+Tags (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Data, }
\item[{char $\ast$}]{start\+Tag, }
\item[{char $\ast$}]{end\+Tag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a15c42f6a53a7eaaf7a33b62d0cf3d015}


Finds the X\+ML data between the start\+Tag and end\+Tag and returns it. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = Ace::ReadTextFile(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Config.xml"});
    \textcolor{keywordtype}{char}* tagData = Ace::RetrieveDataBetweenTags(data, \textcolor{stringliteral}{"<position>"}, \textcolor{stringliteral}{"</position>"});
    printf(\textcolor{stringliteral}{"Data between tags:%s\(\backslash\)n"}, tagData);
    \_aligned\_free(tagData);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+1, 2.\+3, 2.\+2


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Data} & A string containing the data to be parsed. \\
\hline
\mbox{\tt in}  & {\em start\+Tag} & A string representing the tag to start from. \\
\hline
\mbox{\tt in}  & {\em end\+Tag} & A string representing the tag to end on.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A Buffer containing the data between start\+Tag + start\+Tag.\+length() and end\+Tag. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}}
\index{Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}!Ace@{Ace}}
\subsubsection[{Retrieve\+Data\+Between\+Tags(wchar\+\_\+t $\ast$file\+Data, wchar\+\_\+t $\ast$start\+Tag, wchar\+\_\+t $\ast$end\+Tag)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Retrieve\+Data\+Between\+Tags (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Data, }
\item[{wchar\+\_\+t $\ast$}]{start\+Tag, }
\item[{wchar\+\_\+t $\ast$}]{end\+Tag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad3a908a447d305f769bd40af461e48e5}


Finds the X\+ML data between the start\+Tag and end\+Tag and returns it. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = Ace::ReadTextFileW(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Config.xml"});
    \textcolor{keywordtype}{wchar\_t}* tagData = Ace::RetrieveDataBetweenTags(data, L\textcolor{stringliteral}{"<position>"}, L\textcolor{stringliteral}{"</position>"});
    printf(\textcolor{stringliteral}{"Data between tags:%S\(\backslash\)n"}, tagData);
    \_aligned\_free(tagData);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+1, 2.\+3, 2.\+2


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Data} & A string containing the data to be parsed. \\
\hline
\mbox{\tt in}  & {\em start\+Tag} & A string representing the tag to start from. \\
\hline
\mbox{\tt in}  & {\em end\+Tag} & A string representing the tag to end on.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A Buffer containing the data between start\+Tag + start\+Tag.\+length() and end\+Tag. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}}
\index{Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}!Ace@{Ace}}
\subsubsection[{Retrieve\+Data\+Between\+Tags(char $\ast$file\+Data, int start\+Tag\+Index, int end\+Tag\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Retrieve\+Data\+Between\+Tags (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Data, }
\item[{int}]{start\+Tag\+Index, }
\item[{int}]{end\+Tag\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac7c2687eabb6302150a0ef33dcc1e6c1}


Finds the X\+ML data between the start\+Tag\+Index and end\+Tag\+Index and returns it. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = Ace::ReadTextFile(\textcolor{stringliteral}{"C://Config.xml"});
    \textcolor{keywordtype}{int} startIndex = Ace::IndexOf(data, \textcolor{stringliteral}{"<position>"}) + strlen(\textcolor{stringliteral}{"<position>"});
    \textcolor{keywordtype}{int} endIndex = Ace::IndexOf(data, \textcolor{stringliteral}{"</position>"});
    \textcolor{keywordtype}{char}* tagData = Ace::RetrieveDataBetweenTags(data, startIndex, endIndex);
    printf(\textcolor{stringliteral}{"Data between tags:%s\(\backslash\)n"}, tagData);
    \_aligned\_free(tagData);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+1, 2.\+3, 2.\+2


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Data} & A string containing the data to be parsed. \\
\hline
\mbox{\tt in}  & {\em start\+Tag\+Index} & Index of where to start reading in. \\
\hline
\mbox{\tt in}  & {\em end\+Tag\+Index} & Index of where to end reading data.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A Buffer containing the data between start\+Tag\+Index and end\+Tag\+Index. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}}
\index{Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}!Ace@{Ace}}
\subsubsection[{Retrieve\+Data\+Between\+Tags(wchar\+\_\+t $\ast$file\+Data, int start\+Tag\+Index, int end\+Tag\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Retrieve\+Data\+Between\+Tags (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Data, }
\item[{int}]{start\+Tag\+Index, }
\item[{int}]{end\+Tag\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac33be815c3d923b322217d9822471680}


Finds the X\+ML data between the start\+Tag\+Index and end\+Tag\+Index and returns it. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = Ace::ReadTextFileW(L\textcolor{stringliteral}{"C://Config.xml"});
    \textcolor{keywordtype}{int} startIndex = Ace::IndexOf(data, L\textcolor{stringliteral}{"<position>"}) + wcslen(L\textcolor{stringliteral}{"<position>"});
    \textcolor{keywordtype}{int} endIndex = Ace::IndexOf(data, L\textcolor{stringliteral}{"</position>"});
    \textcolor{keywordtype}{wchar\_t}* tagData = Ace::RetrieveDataBetweenTags(data, startIndex, endIndex);
    printf(\textcolor{stringliteral}{"Data between tags:%S\(\backslash\)n"}, tagData);
    \_aligned\_free(tagData);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+1, 2.\+3, 2.\+2


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Data} & A wide string containing the data to be parsed. \\
\hline
\mbox{\tt in}  & {\em start\+Tag\+Index} & Index of where to start reading in. \\
\hline
\mbox{\tt in}  & {\em end\+Tag\+Index} & Index of where to end reading data.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A Buffer containing the data between start\+Tag\+Index and end\+Tag\+Index. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Data\+Chunks\+Between\+Tags@{Retrieve\+Data\+Chunks\+Between\+Tags}}
\index{Retrieve\+Data\+Chunks\+Between\+Tags@{Retrieve\+Data\+Chunks\+Between\+Tags}!Ace@{Ace}}
\subsubsection[{Retrieve\+Data\+Chunks\+Between\+Tags(char $\ast$file\+Data, char $\ast$start\+Tag, char $\ast$end\+Tag, int \&out\+Final\+Buffer\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$$\ast$ Ace\+::\+Retrieve\+Data\+Chunks\+Between\+Tags (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Data, }
\item[{char $\ast$}]{start\+Tag, }
\item[{char $\ast$}]{end\+Tag, }
\item[{int \&}]{out\+Final\+Buffer\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a639fcb40de735847ee36b09ebaf58243}


Finds a series of X\+ML data between start\+Tag and end\+Tag. 

For example, if we were reading in an X\+ML file that looked like this\+: $<$\+Models$>$ $<$\+Model$>$ $<$position$>$0.\+1, 2.\+3, 2.\+2$<$/position$>$ $<$rotation$>$20.\+0, 0.\+0, 0.\+0, 1.\+0$<$/rotation$>$ $<$/\+Model$>$ $<$\+Model$>$ $<$position$>$3.\+0, 4.\+0, 5.\+0$<$/position$>$ $<$rotation$>$0.\+0, 30.\+0, 0.\+0, 1.\+0$<$/rotation$>$ $<$/\+Model$>$ $<$/\+Models$>$

And the start and end tags were \char`\"{}$<$\+Model$>$\char`\"{} and \char`\"{}$<$/\+Model$>$\char`\"{} respectively; then the function will return an array containing\+: Array[0]=\char`\"{}$<$position$>$0.\+1, 2.\+3, 2.\+2$<$/position$>$
            $<$rotation$>$20.\+0, 0.\+0, 0.\+0, 1.\+0$<$/rotation$>$\char`\"{}

Array[1]=\char`\"{}$<$position$>$1.\+0, 2.\+0, 0.\+0$<$/position$>$
            $<$rotation$>$20.\+0, 0.\+0, 0.\+0, 1.\+0$<$/rotation$>$\char`\"{}

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = Ace::ReadTextFile(\textcolor{stringliteral}{"C://Config.xml"});
    \textcolor{keywordtype}{int} tagDataSize = 0;
    \textcolor{keywordtype}{char}** tagData = Ace::RetrieveDataChunksBetweenTags(data, \textcolor{stringliteral}{"<Model>"}, \textcolor{stringliteral}{"</Model>"}, tagDataSize);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < tagDataSize; currIndex++)
    \{
        printf(\textcolor{stringliteral}{"Array[%d]:%s\(\backslash\)n"}, currIndex, tagData[currIndex]);
        \_aligned\_free(tagData[currIndex]);
    \}
    \_aligned\_free(tagData);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:(\+Displayed Above)


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Data} & A string containing the data to be parsed. \\
\hline
\mbox{\tt in}  & {\em start\+Tag} & A string representing the tag to start from. \\
\hline
\mbox{\tt in}  & {\em end\+Tag} & A string representing the tag to end on. \\
\hline
\mbox{\tt out}  & {\em out\+Final\+Buffer\+Size} & Size of the out final buffer.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly allocated string array containing the data between each start\+Tag and end\+Tag found. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Data\+Chunks\+Between\+Tags@{Retrieve\+Data\+Chunks\+Between\+Tags}}
\index{Retrieve\+Data\+Chunks\+Between\+Tags@{Retrieve\+Data\+Chunks\+Between\+Tags}!Ace@{Ace}}
\subsubsection[{Retrieve\+Data\+Chunks\+Between\+Tags(wchar\+\_\+t $\ast$file\+Data, wchar\+\_\+t $\ast$start\+Tag, wchar\+\_\+t $\ast$end\+Tag, int \&out\+Final\+Buffer\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$$\ast$ Ace\+::\+Retrieve\+Data\+Chunks\+Between\+Tags (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Data, }
\item[{wchar\+\_\+t $\ast$}]{start\+Tag, }
\item[{wchar\+\_\+t $\ast$}]{end\+Tag, }
\item[{int \&}]{out\+Final\+Buffer\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_afc8d972571ec5b22f6a8553ac324fc3f}


Finds a series of X\+ML data between start\+Tag and end\+Tag. 

For example, if we were reading in an X\+ML file that looked like this\+: $<$\+Models$>$ $<$\+Model$>$ $<$position$>$0.\+1, 2.\+3, 2.\+2$<$/position$>$ $<$rotation$>$20.\+0, 0.\+0, 0.\+0, 1.\+0$<$/rotation$>$ $<$/\+Model$>$ $<$\+Model$>$ $<$position$>$3.\+0, 4.\+0, 5.\+0$<$/position$>$ $<$rotation$>$0.\+0, 30.\+0, 0.\+0, 1.\+0$<$/rotation$>$ $<$/\+Model$>$ $<$/\+Models$>$

And the start and end tags were \char`\"{}$<$\+Model$>$\char`\"{} and \char`\"{}$<$/\+Model$>$\char`\"{} respectively; then the function will return an array containing\+: Array[0]=\char`\"{}$<$position$>$0.\+1, 2.\+3, 2.\+2$<$/position$>$
            $<$rotation$>$20.\+0, 0.\+0, 0.\+0, 1.\+0$<$/rotation$>$\char`\"{}

Array[1]=\char`\"{}$<$position$>$1.\+0, 2.\+0, 0.\+0$<$/position$>$
            $<$rotation$>$20.\+0, 0.\+0, 0.\+0, 1.\+0$<$/rotation$>$\char`\"{}

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = Ace::ReadTextFileW(L\textcolor{stringliteral}{"C://Config.xml"});
    \textcolor{keywordtype}{int} tagDataSize = 0;
    \textcolor{keywordtype}{wchar\_t}** tagData = Ace::RetrieveDataChunksBetweenTags(data, L\textcolor{stringliteral}{"<Model>"}, L\textcolor{stringliteral}{"</Model>"}, tagDataSize);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < tagDataSize; currIndex++)
    \{
        printf(\textcolor{stringliteral}{"Array[%d]:%S\(\backslash\)n"}, currIndex, tagData[currIndex]);
        \_aligned\_free(tagData[currIndex]);
    \}
    \_aligned\_free(tagData);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:(\+Displayed Above)


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Data} & A wide string containing the data to be parsed. \\
\hline
\mbox{\tt in}  & {\em start\+Tag} & A wide string representing the tag to start from. \\
\hline
\mbox{\tt in}  & {\em end\+Tag} & A wide string representing the tag to end on. \\
\hline
\mbox{\tt out}  & {\em out\+Final\+Buffer\+Size} & Size of the out final buffer.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly allocated wide string array containing the data between each start\+Tag and end\+Tag found. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+File\+Names@{Retrieve\+File\+Names}}
\index{Retrieve\+File\+Names@{Retrieve\+File\+Names}!Ace@{Ace}}
\subsubsection[{Retrieve\+File\+Names(char $\ast$full\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ char $\ast$ $>$ Ace\+::\+Retrieve\+File\+Names (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{full\+File\+Path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a1126579b6ddd052f90e987ef056fad70}


Returns all the names of the files inside a folder, Ignores non files like folders. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
7/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* imageFilePath = \textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Images\(\backslash\)\(\backslash\)180Panoramic"};
    vector<char*> fileNames = Ace::RetrieveFileNames(imageFilePath);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < fileNames.size(); i++)
    \{
        printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, fileNames[i]);
        \_aligned\_free(fileNames[i]);
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:sky.\+jpg mountans.\+png tits.\+gtfo dontread.\+txt


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em full\+File\+Path} & Directory to look inside.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector array containing all the file names in the folder. Throws an exception if full\+File\+Path is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+File\+Names@{Retrieve\+File\+Names}}
\index{Retrieve\+File\+Names@{Retrieve\+File\+Names}!Ace@{Ace}}
\subsubsection[{Retrieve\+File\+Names(wchar\+\_\+t $\ast$full\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ wchar\+\_\+t $\ast$ $>$ Ace\+::\+Retrieve\+File\+Names (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{full\+File\+Path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5ade52ee2c4a73cb571a27f71cd91028}


Returns all the names of the files inside a folder, Ignores non files like folders. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* imageFilePath = L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Images\(\backslash\)\(\backslash\)180Panoramic"};
    vector<wchar\_t*> fileNames = Ace::RetrieveFileNames(imageFilePath);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < fileNames.size(); i++)
    \{
        printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, fileNames[i]);
        \_aligned\_free(fileNames[i]);
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:sky.\+jpg mountans.\+png tits.\+gtfo dontread.\+txt


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em full\+File\+Path} & Directory to look inside.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector array containing all the file names in the folder. Throws an exception if full\+File\+Path is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Folder\+Names@{Retrieve\+Folder\+Names}}
\index{Retrieve\+Folder\+Names@{Retrieve\+Folder\+Names}!Ace@{Ace}}
\subsubsection[{Retrieve\+Folder\+Names(char $\ast$full\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ char $\ast$ $>$ Ace\+::\+Retrieve\+Folder\+Names (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{full\+File\+Path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5336deec9aeb39d6239b5ce09a396e80}


Returns all the names of the sub-\/folder(s) in a folder. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/1/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* imageFilePath = \textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Images"};
    vector<char*> folderNames = Ace::RetrieveFolderNames(imageFilePath);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < folderNames.size(); i++)
    \{
        printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, folderNames[i]);
        \_aligned\_free(folderNames[i]);
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:180 panoramics 360 panoramics photospheres


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em full\+File\+Path} & Directory to look inside.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector array containing all the sub-\/folder names in the folder. Throws an exception if full\+File\+Path is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Folder\+Names@{Retrieve\+Folder\+Names}}
\index{Retrieve\+Folder\+Names@{Retrieve\+Folder\+Names}!Ace@{Ace}}
\subsubsection[{Retrieve\+Folder\+Names(wchar\+\_\+t $\ast$full\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ wchar\+\_\+t $\ast$ $>$ Ace\+::\+Retrieve\+Folder\+Names (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{full\+File\+Path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0d676a65bbb1f524cd6b0d0ac3f99013}


Returns all the names of the sub-\/folder(s) in a folder. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* imageFilePath = L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Images"};
    vector<wchar\_t*> folderNames = Ace::RetrieveFolderNames(imageFilePath);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < folderNames.size(); i++)
    \{
        printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, folderNames[i]);
        \_aligned\_free(folderNames[i]);
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:180 panoramics 360 panoramics photospheres


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em full\+File\+Path} & Directory to look inside.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector array containing all the sub-\/folder names in the folder. Throws an exception if full\+File\+Path is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Reverse\+String@{Reverse\+String}}
\index{Reverse\+String@{Reverse\+String}!Ace@{Ace}}
\subsubsection[{Reverse\+String(char $\ast$str\+To\+Reverse)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Reverse\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Reverse}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_acebc93fbbb2ead1c7177b42b64826b00}


Creates a new string containing all the characters from str\+To\+Reverse in reverse order. 

For example\+: \char`\"{}\+A\+B\+C\+D\+E\+F\char`\"{} will return \char`\"{}\+F\+E\+D\+C\+B\+A\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = Ace::ReverseString(\textcolor{stringliteral}{"ABCDEF"});
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:F\+E\+D\+C\+BA


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Reverse} & A string to reverse.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string containing the reverse of str\+To\+Reverse. Throws an exception if str\+To\+Reverse is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Reverse\+String@{Reverse\+String}}
\index{Reverse\+String@{Reverse\+String}!Ace@{Ace}}
\subsubsection[{Reverse\+String(wchar\+\_\+t $\ast$str\+To\+Reverse)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Reverse\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Reverse}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a310c25048fb63e5c43134c894eb71369}


Creates a new wide string containing all the characters from str\+To\+Reverse in reverse order. 

For example\+: \char`\"{}\+A\+B\+C\+D\+E\+F\char`\"{} will return \char`\"{}\+F\+E\+D\+C\+B\+A\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = Ace::ReverseString(L\textcolor{stringliteral}{"ABCDEF"});
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:F\+E\+D\+C\+BA


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Reverse} & A wide string to reverse.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created wide string containing the reverse of str\+To\+Reverse. Throws an exception of str\+To\+Reverse is N\+U\+LL. 
\end{DoxyReturn}
\index{Ace@{Ace}!Reverse\+String\+In\+Place@{Reverse\+String\+In\+Place}}
\index{Reverse\+String\+In\+Place@{Reverse\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Reverse\+String\+In\+Place(char $\ast$str\+To\+Reverse)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Reverse\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Reverse}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9bd246903778d20a982765bea54ec8f4}


Directly modifies str\+To\+Reverse to have all its characters in reverse order. 

For example\+: \char`\"{}\+A\+B\+C\+D\+E\+F\char`\"{} will return \char`\"{}\+F\+E\+D\+C\+B\+A\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* data = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"ABCDEF"});
    Ace::ReverseStringInPlace(data);
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:(\+Displayed above)


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Reverse} & A preallocated string to reverse. Throws an exception of str\+To\+Reverse is N\+U\+LL. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Reverse\+String\+In\+Place@{Reverse\+String\+In\+Place}}
\index{Reverse\+String\+In\+Place@{Reverse\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Reverse\+String\+In\+Place(wchar\+\_\+t $\ast$str\+To\+Reverse)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Reverse\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Reverse}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a1b0e0afa5c975cc03845b6a79331f228}


Directly modifies str\+To\+Reverse to have all its characters in reverse order. 

For example\+: \char`\"{}\+A\+B\+C\+D\+E\+F\char`\"{} will return \char`\"{}\+F\+E\+D\+C\+B\+A\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* data = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"ABCDEF"});
    Ace::ReverseStringInPlace(data);
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, data);
    \_aligned\_free(data);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:(\+Displayed above)


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Reverse} & A preallocated string to reverse. Throws an exception of str\+To\+Reverse is N\+U\+LL. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Round\+To\+Nearest\+Integer@{Round\+To\+Nearest\+Integer}}
\index{Round\+To\+Nearest\+Integer@{Round\+To\+Nearest\+Integer}!Ace@{Ace}}
\subsubsection[{Round\+To\+Nearest\+Integer(double num)}]{\setlength{\rightskip}{0pt plus 5cm}long Ace\+::\+Round\+To\+Nearest\+Integer (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7bf2286843651fe1cd72b037a1030320}


Rounds the floating-\/point argument num to an integer value, using the current rounding mode. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{long} result = Ace::RoundToNearestInteger(3.5);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:4


\begin{DoxyParams}{Parameters}
{\em num} & Number to round.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The num rounded using the current rounding mode. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Round\+To\+Nearest\+Integer@{Round\+To\+Nearest\+Integer}}
\index{Round\+To\+Nearest\+Integer@{Round\+To\+Nearest\+Integer}!Ace@{Ace}}
\subsubsection[{Round\+To\+Nearest\+Integer(float num)}]{\setlength{\rightskip}{0pt plus 5cm}long Ace\+::\+Round\+To\+Nearest\+Integer (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a892854a0074451f70c0bfa9568b7c7eb}


Rounds the floating-\/point argument num to an integer value, using the current rounding mode. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{long} result = Ace::RoundToNearestInteger(3.5f);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:4


\begin{DoxyParams}{Parameters}
{\em num} & Number to round.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The num rounded using the current rounding mode. If a mathematical error occurs then then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Round\+To\+Nearest\+Integer@{Round\+To\+Nearest\+Integer}}
\index{Round\+To\+Nearest\+Integer@{Round\+To\+Nearest\+Integer}!Ace@{Ace}}
\subsubsection[{Round\+To\+Nearest\+Integer(int num)}]{\setlength{\rightskip}{0pt plus 5cm}long Ace\+::\+Round\+To\+Nearest\+Integer (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7a58ce0e83b2e98d83f0968c9eff8606}


Rounds the floating-\/point argument num to an integer value, using the current rounding mode. 

This function is somewhat useless but provided for completeness. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/19/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{long} result = Ace::RoundToNearestInteger(3);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:3


\begin{DoxyParams}{Parameters}
{\em num} & Number to round.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The num rounded using the current rounding mode. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Round\+Up@{Round\+Up}}
\index{Round\+Up@{Round\+Up}!Ace@{Ace}}
\subsubsection[{Round\+Up(double num)}]{\setlength{\rightskip}{0pt plus 5cm}long Ace\+::\+Round\+Up (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a020fc7df33dce4679ed8a392da725b8b}


Calculates the nearest integer value to num (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{long} result = Ace::RoundUp(3.5);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:4


\begin{DoxyParams}{Parameters}
{\em num} & Number to round.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The nearest integer value to num, rounding halfway cases away from zero. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Round\+Up@{Round\+Up}}
\index{Round\+Up@{Round\+Up}!Ace@{Ace}}
\subsubsection[{Round\+Up(float num)}]{\setlength{\rightskip}{0pt plus 5cm}long Ace\+::\+Round\+Up (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5feb3de75f4f946d79f4ff56389f93cd}


Calculates the nearest integer value to num (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{long} result = Ace::RoundUp(3.5f);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:4


\begin{DoxyParams}{Parameters}
{\em num} & Number to round.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The nearest integer value to num, rounding halfway cases away from zero. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Round\+Up@{Round\+Up}}
\index{Round\+Up@{Round\+Up}!Ace@{Ace}}
\subsubsection[{Round\+Up(int num)}]{\setlength{\rightskip}{0pt plus 5cm}long Ace\+::\+Round\+Up (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5b9826b67afaa347a548479f86460c24}


Calculates the nearest integer value to num (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode. 

This function is somewhat useless but provided for completeness. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{long} result = Ace::RoundUp(3);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:3


\begin{DoxyParams}{Parameters}
{\em num} & Number to round.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The nearest integer value to num, rounding halfway cases away from zero. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Show\+Message\+Box@{Show\+Message\+Box}}
\index{Show\+Message\+Box@{Show\+Message\+Box}!Ace@{Ace}}
\subsubsection[{Show\+Message\+Box(\+H\+W\+N\+D h\+Window, char $\ast$message, char $\ast$title=""Error"")}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Show\+Message\+Box (
\begin{DoxyParamCaption}
\item[{H\+W\+ND}]{h\+Window, }
\item[{char $\ast$}]{message, }
\item[{char $\ast$}]{title = {\ttfamily \char`\"{}Error\char`\"{}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a77deefeaedf4e2bd0eee31ad3bdfb2e7}


Displays a standard message box with a message, title, and an OK button. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/31/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    Ace::ShowMessageBox(NULL, \textcolor{stringliteral}{"Hello Eddie!"}, \textcolor{stringliteral}{"Message Box Name"});
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:(\+Shows a message box with the message).


\begin{DoxyParams}{Parameters}
{\em h\+Window} & The parent window to the message box (Can be N\+U\+LL). \\
\hline
{\em message} & The message to display in the message box (Can be N\+U\+LL). \\
\hline
{\em title} & The title to use in the message box window (Can be N\+U\+LL).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if an error is encountered. 
\end{DoxyReturn}
\index{Ace@{Ace}!Show\+Message\+Box@{Show\+Message\+Box}}
\index{Show\+Message\+Box@{Show\+Message\+Box}!Ace@{Ace}}
\subsubsection[{Show\+Message\+Box(\+H\+W\+N\+D h\+Window, wchar\+\_\+t $\ast$message, wchar\+\_\+t $\ast$title=L""Error"")}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Show\+Message\+Box (
\begin{DoxyParamCaption}
\item[{H\+W\+ND}]{h\+Window, }
\item[{wchar\+\_\+t $\ast$}]{message, }
\item[{wchar\+\_\+t $\ast$}]{title = {\ttfamily L\char`\"{}Error\char`\"{}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2acc2788f710af663da2badb5d28134e}


Displays a standard message box with a message, title, and an OK button. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/31/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    Ace::ShowMessageBox(NULL, L\textcolor{stringliteral}{"Hello Eddie!"}, L\textcolor{stringliteral}{"Message Box Name"});
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:(\+Shows a message box with the message).


\begin{DoxyParams}{Parameters}
{\em h\+Window} & The parent window to the message box (Can be N\+U\+LL). \\
\hline
{\em message} & The message to display in the message box (Can be N\+U\+LL). \\
\hline
{\em title} & The title to use in the message box window (Can be N\+U\+LL).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Throws an exception if an error is encountered. 
\end{DoxyReturn}
\index{Ace@{Ace}!Sin@{Sin}}
\index{Sin@{Sin}!Ace@{Ace}}
\subsubsection[{Sin(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Sin (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a06e3e46bfa12aeef6c13edf8d57b2b24}


Calculates the Sin in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
    \textcolor{keywordtype}{double} result = Ace::Sin(PI / 4.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+707107


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Sin for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Sin of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Sin@{Sin}}
\index{Sin@{Sin}!Ace@{Ace}}
\subsubsection[{Sin(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Sin (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a94a843acbc1575633980b4e00253847e}


Calculates the Sin in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{float} result = Ace::Sin(PI / 4.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+707107


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Sin for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Sin of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Sin@{Sin}}
\index{Sin@{Sin}!Ace@{Ace}}
\subsubsection[{Sin(int num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Sin (
\begin{DoxyParamCaption}
\item[{int}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4100b79a22131a7a80422f69ad6c798b}


Calculates the Sin in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{int} result = Ace::Sin((\textcolor{keywordtype}{int})(PI / 4));
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+707107


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Sin for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Sin of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!SinH@{SinH}}
\index{SinH@{SinH}!Ace@{Ace}}
\subsubsection[{Sin\+H(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+SinH (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab20988efdaa2f4ad09ee73c6ce108e19}


Calculates the SinH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
    \textcolor{keywordtype}{double} result = Ace::SinH(PI / 4.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+868671


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate SinH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The SinH of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!SinH@{SinH}}
\index{SinH@{SinH}!Ace@{Ace}}
\subsubsection[{Sin\+H(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+SinH (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a3e7c3e005fd8cb91de75cbf911766bf3}


Calculates the SinH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{float} result = Ace::SinH(PI / 4.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+868671


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate SinH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The SinH of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!SinH@{SinH}}
\index{SinH@{SinH}!Ace@{Ace}}
\subsubsection[{Sin\+H(int num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+SinH (
\begin{DoxyParamCaption}
\item[{int}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a77b76c2bd994f8d0524394b894d4adc5}


Calculates the SinH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
    \textcolor{keywordtype}{int} result = Ace::SinH((\textcolor{keywordtype}{int})(PI / 4));
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate SinH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The SinH of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Smallest@{Smallest}}
\index{Smallest@{Smallest}!Ace@{Ace}}
\subsubsection[{Smallest(double num1, double num2)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Smallest (
\begin{DoxyParamCaption}
\item[{double}]{num1, }
\item[{double}]{num2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a43a41e4cedf8be5164b3938a010028c8}


Calculates the smaller of the two values and returns the smaller one. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} retVal = Ace::Smallest(5.002, 5.01);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:5.\+002000


\begin{DoxyParams}{Parameters}
{\em num1} & Number to compare. \\
\hline
{\em num2} & Other number to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The smaller of the two values. 
\end{DoxyReturn}
\index{Ace@{Ace}!Smallest@{Smallest}}
\index{Smallest@{Smallest}!Ace@{Ace}}
\subsubsection[{Smallest(float num1, float num2)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Smallest (
\begin{DoxyParamCaption}
\item[{float}]{num1, }
\item[{float}]{num2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad07c864576d94daac736fe121ae87a02}


Calculates the smaller of the two values and returns the smaller one. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} retVal = Ace::Smallest(5.002f, 5.01f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:5.\+002000


\begin{DoxyParams}{Parameters}
{\em num1} & Number to compare. \\
\hline
{\em num2} & Other number to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The smaller of the two values. 
\end{DoxyReturn}
\index{Ace@{Ace}!Smallest@{Smallest}}
\index{Smallest@{Smallest}!Ace@{Ace}}
\subsubsection[{Smallest(int num1, int num2)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Smallest (
\begin{DoxyParamCaption}
\item[{int}]{num1, }
\item[{int}]{num2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af5b08817503584cb546dba5d81174c23}


Calculates the smaller of the two values and returns the smaller one. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} retVal = Ace::Smallest(5, 7);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:5


\begin{DoxyParams}{Parameters}
{\em num1} & Number to compare. \\
\hline
{\em num2} & Other number to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The smaller of the two values. 
\end{DoxyReturn}
\index{Ace@{Ace}!Square\+Root@{Square\+Root}}
\index{Square\+Root@{Square\+Root}!Ace@{Ace}}
\subsubsection[{Square\+Root(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Square\+Root (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a29179fe6de4ef729c5922aeafbde9821}


Returns the Square Root of the provided number. 

If the number provided is negative, -\/1 is returned.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/29/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} squareRoot = Ace::SquareRoot(144.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, squareRoot);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:12.\+000000000


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num} & The number to take the Square Root of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If num is negative; an exception is thrown, else the Square Root is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Square\+Root@{Square\+Root}}
\index{Square\+Root@{Square\+Root}!Ace@{Ace}}
\subsubsection[{Square\+Root(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Square\+Root (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad29221122ff5bc838ed5741cef72364b}


Returns the Square Root of the provided number. 

If the number provided is negative, -\/1 is returned.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} squareRoot = Ace::SquareRoot(144.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, squareRoot);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:12.\+000000000


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num} & The number to take the Square Root of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If num is negative; an exception is thrown, else the Square Root is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Square\+Root@{Square\+Root}}
\index{Square\+Root@{Square\+Root}!Ace@{Ace}}
\subsubsection[{Square\+Root(int num)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Square\+Root (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae5443299e3160c883357d90a2346be13}


Returns the Square Root of the provided number. 

If the number provided is negative, -\/1 is returned.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} squareRoot = Ace::SquareRoot(144);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, squareRoot);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:12


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num} & The number to take the Square Root of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If num is negative; an exception is thrown, else the Square Root is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Sub\+String@{Sub\+String}}
\index{Sub\+String@{Sub\+String}!Ace@{Ace}}
\subsubsection[{Sub\+String(char $\ast$str, int start\+Index, int up\+To\+But\+Not\+Including\+Index=\+I\+N\+T\+\_\+\+M\+A\+X)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Sub\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str, }
\item[{int}]{start\+Index, }
\item[{int}]{up\+To\+But\+Not\+Including\+Index = {\ttfamily INT\+\_\+MAX}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab94f6a0b50f95846b20a921c1c48cbbd}


Returns a string containing the characters between start\+Index and up\+To\+But\+Not\+Including\+Index. 

Unlike strstr(), this function creates a new string and returns it. If up\+To\+But\+Not\+Including\+Index is not provided, then the string returned is everything from start\+Index to the end of the string.

Here\textquotesingle{}s an example\+: str = \char`\"{}\+Happiness\char`\"{} start\+Index = 3 up\+To\+But\+Not\+Including\+Index = 8 then the output would be \char`\"{}pines\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* substr = Ace::SubString(\textcolor{stringliteral}{"Happiness"}, 3, 8);
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, substr);
    \_aligned\_free(substr);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:pines


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to parse. \\
\hline
\mbox{\tt in}  & {\em start\+Index} & The (0 based) index of where to start parsing str. \\
\hline
\mbox{\tt in}  & {\em up\+To\+But\+Not\+Including\+Index} & The (0 based) index of where to stop.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string containing the characters from start\+Index to up\+To\+But\+Not\+Including\+Index. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Sub\+String@{Sub\+String}}
\index{Sub\+String@{Sub\+String}!Ace@{Ace}}
\subsubsection[{Sub\+String(wchar\+\_\+t $\ast$str, int start\+Index, int up\+To\+But\+Not\+Including\+Index=\+I\+N\+T\+\_\+\+M\+A\+X)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Sub\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str, }
\item[{int}]{start\+Index, }
\item[{int}]{up\+To\+But\+Not\+Including\+Index = {\ttfamily INT\+\_\+MAX}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7d4131741f469b7220631088526e12ee}


Returns a wide string containing the characters between start\+Index and up\+To\+But\+Not\+Including\+Index. 

Unlike strstr(), this function creates a new string and returns it. If up\+To\+But\+Not\+Including\+Index is not provided, then the string returned is everything from start\+Index to the end of the string.

Here\textquotesingle{}s an example\+: str = \char`\"{}\+Happiness\char`\"{} start\+Index = 3 up\+To\+But\+Not\+Including\+Index = 8 then the output would be \char`\"{}pines\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* substr = Ace::SubString(L\textcolor{stringliteral}{"Happiness"}, 3, 8);
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, substr);
    \_aligned\_free(substr);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:pines


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The wide string to parse. \\
\hline
\mbox{\tt in}  & {\em start\+Index} & The (0 based) index of where to start parsing str. \\
\hline
\mbox{\tt in}  & {\em up\+To\+But\+Not\+Including\+Index} & The (0 based) index of where to stop.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created wide string containing the characters from start\+Index to up\+To\+But\+Not\+Including\+Index. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Tan@{Tan}}
\index{Tan@{Tan}!Ace@{Ace}}
\subsubsection[{Tan(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Tan (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8434cb3dc1700eb767a393087cf35ade}


Calculates the Tangent (Tan) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265358979;
    \textcolor{keywordtype}{double} retVal = Ace::Tan(PI / 4.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1.\+000000


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number to use to calculate its tangent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Tangent (tan) of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Tan@{Tan}}
\index{Tan@{Tan}!Ace@{Ace}}
\subsubsection[{Tan(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Tan (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8733891f27eea8b6725acd6ef81c123e}


Calculates the Tangent (Tan) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.141592654f;
    \textcolor{keywordtype}{float} retVal = Ace::Tan(PI / 4.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:1.\+000000


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number to use to calculate its tangent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Tangent (tan) of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Tan@{Tan}}
\index{Tan@{Tan}!Ace@{Ace}}
\subsubsection[{Tan(int num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Tan (
\begin{DoxyParamCaption}
\item[{int}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5603e8bcad484268ff7e4b213c5494f4}


Calculates the Tangent (Tan) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265358979;
    \textcolor{keywordtype}{int} retVal = Ace::Tan((\textcolor{keywordtype}{int})(PI / 4));
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number to use to calculate its tangent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Tangent (tan) of num\+In\+Radians. If a mathematical error occurs then exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!TanH@{TanH}}
\index{TanH@{TanH}!Ace@{Ace}}
\subsubsection[{Tan\+H(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+TanH (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abeaf6de454adb6cbec71470d9c290631}


Calculates The Hyperbolic Tangent (TanH) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265358979;
    \textcolor{keywordtype}{double} retVal = Ace::TanH(PI / 4.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+655794


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number to use to calculate its hyperbolic tangent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Hyperbolic Tangent (tan) of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!TanH@{TanH}}
\index{TanH@{TanH}!Ace@{Ace}}
\subsubsection[{Tan\+H(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+TanH (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac035088ac628b78d0af94c801211dae8}


Calculates The Hyperbolic Tangent (TanH) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.141592654f;
    \textcolor{keywordtype}{float} retVal = Ace::TanH(PI / 4.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0.\+655794


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number to use to calculate its hyperbolic tangent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Hyperbolic Tangent (tan) of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!TanH@{TanH}}
\index{TanH@{TanH}!Ace@{Ace}}
\subsubsection[{Tan\+H(int num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+TanH (
\begin{DoxyParamCaption}
\item[{int}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af06fe4e6aa9e8c3232123deb8c24d47c}


Calculates The Hyperbolic Tangent (TanH) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265358979;
    \textcolor{keywordtype}{int} retVal = Ace::TanH((\textcolor{keywordtype}{int})(PI / 4));
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:0


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number to use to calculate its hyperbolic tangent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Hyperbolic Tangent (tan) of num\+In\+Radians. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Tokenize@{Tokenize}}
\index{Tokenize@{Tokenize}!Ace@{Ace}}
\subsubsection[{Tokenize(char $\ast$str\+To\+Tokenize, char $\ast$delimiter, int \&out\+Num\+Tokens\+Found)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$$\ast$ Ace\+::\+Tokenize (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Tokenize, }
\item[{char $\ast$}]{delimiter, }
\item[{int \&}]{out\+Num\+Tokens\+Found}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8e948c04ce26696ede60e70c5f70c361}


Breaks up a string and returns an array of all the strings between each delimiter. 

For example\+: \char`\"{}\+Shit,\+Piss, Cunt,\+Cock-\/sucker,\+Mother\+\_\+\+Fucker,and tits\char`\"{} And the delimiter was \char`\"{},\char`\"{} then the function would return\+: Array[0] = \char`\"{}\+Shit\char`\"{} Array[1] = \char`\"{}\+Piss\char`\"{} Array[2] = \char`\"{} Cunt\char`\"{} Array[3] = \char`\"{}\+Cock-\/sucker\char`\"{} Array[4] = \char`\"{}\+Mother\+\_\+\+Fucker\char`\"{} Array[5] = \char`\"{}and tits\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} numItems = 0;
    \textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Shit, Piss, Cunt, Cock - sucker, Mother\_Fucker, and tits"};
    \textcolor{keywordtype}{char}** items = Ace::Tokenize(data, \textcolor{stringliteral}{","}, numItems);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < numItems; currIndex++)
    \{
        printf(\textcolor{stringliteral}{"Array[%d]:%s\(\backslash\)n"}, currIndex, items[currIndex]);
        \_aligned\_free(items[currIndex]);
    \}
    \_aligned\_free(items);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Array[0] = \char`\"{}\+Shit\char`\"{} Array[1] = \char`\"{}\+Piss\char`\"{} Array[2] = \char`\"{} Cunt\char`\"{} Array[3] = \char`\"{}\+Cock-\/sucker\char`\"{} Array[4] = \char`\"{}\+Mother\+\_\+\+Fucker\char`\"{} Array[5] = \char`\"{}and tits\char`\"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Tokenize} & A string to break up into an array. \\
\hline
\mbox{\tt in,out}  & {\em delimiter} & A string/character used to separate each string in str\+To\+Tokenize. \\
\hline
\mbox{\tt in,out}  & {\em out\+Num\+Tokens\+Found} & Number of strings added to the final array.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of strings broken up from str\+To\+Tokenize. Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Tokenize@{Tokenize}}
\index{Tokenize@{Tokenize}!Ace@{Ace}}
\subsubsection[{Tokenize(wchar\+\_\+t $\ast$str\+To\+Tokenize, wchar\+\_\+t $\ast$delimiter, int \&out\+Num\+Tokens\+Found)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$$\ast$ Ace\+::\+Tokenize (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Tokenize, }
\item[{wchar\+\_\+t $\ast$}]{delimiter, }
\item[{int \&}]{out\+Num\+Tokens\+Found}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a31130831d9560838ac2a2cb54cd6f876}


Breaks up a wide string and returns an array of all the wide strings between each delimiter. 

For example\+: \char`\"{}\+Shit,\+Piss, Cunt,\+Cock-\/sucker,\+Mother\+\_\+\+Fucker,and tits\char`\"{} And the delimiter was \char`\"{},\char`\"{} then the function would return\+: Array[0] = \char`\"{}\+Shit\char`\"{} Array[1] = \char`\"{}\+Piss\char`\"{} Array[2] = \char`\"{} Cunt\char`\"{} Array[3] = \char`\"{}\+Cock-\/sucker\char`\"{} Array[4] = \char`\"{}\+Mother\+\_\+\+Fucker\char`\"{} Array[5] = \char`\"{}and tits\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} numItems = 0;
    \textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Shit, Piss, Cunt, Cock - sucker, Mother\_Fucker, and tits"};
    \textcolor{keywordtype}{wchar\_t}** items = Ace::Tokenize(data, L\textcolor{stringliteral}{","}, numItems);
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < numItems; currIndex++)
    \{
        printf(\textcolor{stringliteral}{"Array[%d]:%S\(\backslash\)n"}, currIndex, items[currIndex]);
        \_aligned\_free(items[currIndex]);
    \}
    \_aligned\_free(items);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:Array[0] = \char`\"{}\+Shit\char`\"{} Array[1] = \char`\"{}\+Piss\char`\"{} Array[2] = \char`\"{} Cunt\char`\"{} Array[3] = \char`\"{}\+Cock-\/sucker\char`\"{} Array[4] = \char`\"{}\+Mother\+\_\+\+Fucker\char`\"{} Array[5] = \char`\"{}and tits\char`\"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Tokenize} & A wide string to break up into an array. \\
\hline
\mbox{\tt in,out}  & {\em delimiter} & A wide string/character used to separate each wide string in str\+To\+Tokenize. \\
\hline
\mbox{\tt in,out}  & {\em out\+Num\+Tokens\+Found} & Number of wide strings added to the final array.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of strings broken up from str\+To\+Tokenize. Throws an exception if an error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Truncate@{Truncate}}
\index{Truncate@{Truncate}!Ace@{Ace}}
\subsubsection[{Truncate(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Truncate (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa10aa03639439fc61b99fa44d5f611ea}


Removes everything after the decimal point. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} retVal = Ace::Truncate(2.849543);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:2.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & Number to truncate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The truncated version of num. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Truncate@{Truncate}}
\index{Truncate@{Truncate}!Ace@{Ace}}
\subsubsection[{Truncate(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Truncate (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae512b20c30e74f66fef6c9d7fb14e331}


Removes everything after the decimal point. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} retVal = Ace::Truncate(2.849543f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:2.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & Number to truncate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The truncated version of num. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Two\+To\+The\+X\+Power@{Two\+To\+The\+X\+Power}}
\index{Two\+To\+The\+X\+Power@{Two\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{Two\+To\+The\+X\+Power(double power)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Two\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{double}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9c69db829c926e09d728f6f793414fc2}


Calculates 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{double} result = Ace::TwoToTheXPower(6.0);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:64.\+000000


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise 2 to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of 2$^\wedge$power. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Two\+To\+The\+X\+Power@{Two\+To\+The\+X\+Power}}
\index{Two\+To\+The\+X\+Power@{Two\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{Two\+To\+The\+X\+Power(float power)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Two\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{float}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0cb2b7227bece54575fd0cb20d5f8234}


Calculates 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{float} result = Ace::TwoToTheXPower(6.0f);
    printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:64.\+000000


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise 2 to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of 2$^\wedge$power. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Two\+To\+The\+X\+Power@{Two\+To\+The\+X\+Power}}
\index{Two\+To\+The\+X\+Power@{Two\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{Two\+To\+The\+X\+Power(int power)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Two\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{int}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abf0ac8523fedc92767d73cffa77f5c41}


Calculates 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/20/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{int} result = Ace::TwoToTheXPower(4);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:16


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise 2 to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of 2$^\wedge$power. If a mathematical error occurs then an exception is thrown. 
\end{DoxyReturn}
\index{Ace@{Ace}!Validate@{Validate}}
\index{Validate@{Validate}!Ace@{Ace}}
\subsubsection[{Validate(\+H\+W\+N\+D h\+Wnd, H\+R\+E\+S\+U\+L\+T result, char $\ast$message, char $\ast$title=""E\+R\+R\+OR"")}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Validate (
\begin{DoxyParamCaption}
\item[{H\+W\+ND}]{h\+Wnd, }
\item[{H\+R\+E\+S\+U\+LT}]{result, }
\item[{char $\ast$}]{message, }
\item[{char $\ast$}]{title = {\ttfamily \char`\"{}ERROR\char`\"{}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab751a186da0c64e7d020b32f649a7006}


Returns false and displays an error window if result is an error (i.\+e. 

F\+A\+I\+L\+ED). Otherwise returns true.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/18/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    HRESULT hResult = -1;
    \textcolor{keywordtype}{bool} result = Ace::Validate(NULL, hResult, \textcolor{stringliteral}{"Ace Error: Windows function encountered error."}, \textcolor{stringliteral}{"Error
       Window"});
    \textcolor{keywordflow}{if} (result == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Windows function succeeded."});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:(Message box appears and displays the provided E\+R\+R\+OR message.)


\begin{DoxyParams}[1]{Parameters}
 & {\em h\+Wnd} & Handle of the window. \\
\hline
 & {\em result} & The result to validate. \\
\hline
\mbox{\tt in}  & {\em message} & The message to display if failure. \\
\hline
\mbox{\tt in}  & {\em title} & The title for the display window if failure.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if error, true otherwise. Throws an exception if \doxyref{Show\+Message\+Box()}{p.}{class_ace_a77deefeaedf4e2bd0eee31ad3bdfb2e7} encounters an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Validate@{Validate}}
\index{Validate@{Validate}!Ace@{Ace}}
\subsubsection[{Validate(\+H\+W\+N\+D h\+Wnd, H\+R\+E\+S\+U\+L\+T result, wchar\+\_\+t $\ast$message, wchar\+\_\+t $\ast$title=L""E\+R\+R\+OR"")}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Validate (
\begin{DoxyParamCaption}
\item[{H\+W\+ND}]{h\+Wnd, }
\item[{H\+R\+E\+S\+U\+LT}]{result, }
\item[{wchar\+\_\+t $\ast$}]{message, }
\item[{wchar\+\_\+t $\ast$}]{title = {\ttfamily L\char`\"{}ERROR\char`\"{}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae8cd114758e1c21d1808bfa546c6109b}


Returns false and displays an error window if result is an error (i.\+e. 

F\+A\+I\+L\+ED). Otherwise returns true.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/18/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    HRESULT hResult = -1;
    \textcolor{keywordtype}{bool} result = Ace::Validate(NULL, hResult, L\textcolor{stringliteral}{"Ace Error: Windows function encountered error."}, L\textcolor{stringliteral}{"Error
       Window"});
    \textcolor{keywordflow}{if} (result == \textcolor{keyword}{true})
    \{
        printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Windows function succeeded."});
    \}
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:(Message box appears and displays the provided error message.)


\begin{DoxyParams}[1]{Parameters}
 & {\em h\+Wnd} & Handle of the window. \\
\hline
 & {\em result} & The result to validate. \\
\hline
\mbox{\tt in}  & {\em message} & The message to display if failure. \\
\hline
\mbox{\tt in}  & {\em title} & The title for the display window if failure.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if error, true otherwise. Throws an exception if \doxyref{Show\+Message\+Box()}{p.}{class_ace_a77deefeaedf4e2bd0eee31ad3bdfb2e7} encounters an error. 
\end{DoxyReturn}
\index{Ace@{Ace}!Write\+Binary\+File@{Write\+Binary\+File}}
\index{Write\+Binary\+File@{Write\+Binary\+File}!Ace@{Ace}}
\subsubsection[{Write\+Binary\+File(char $\ast$file\+Path, char $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const char $\ast$mode=""wb"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t Ace\+::\+Write\+Binary\+File (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Path, }
\item[{char $\ast$}]{buffer\+To\+Write, }
\item[{size\+\_\+t}]{buffer\+Size, }
\item[{const char $\ast$}]{mode = {\ttfamily \char`\"{}wb\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5796438df275d4868eda8e1d72991350}


Opens a file for writing and returns the number of items/elements written to the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{size\_t} numItemsWritten = Ace::WriteBinaryFile(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)lookupdata.bin"}, \textcolor{stringliteral}{"0xFFFFFFFF"}, 11);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)0"}, numItemsWritten);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:11


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
 & {\em buffer\+To\+Write} & The data to be written. \\
\hline
 & {\em buffer\+Size} & Maximum number of bytes to read. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}w\char`\"{} for write, \char`\"{}w+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Number of bytes to offset from origin. \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The buffer containing the file data of size num\+Bytes\+To\+Read. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Write\+Binary\+FileW@{Write\+Binary\+FileW}}
\index{Write\+Binary\+FileW@{Write\+Binary\+FileW}!Ace@{Ace}}
\subsubsection[{Write\+Binary\+File\+W(wchar\+\_\+t $\ast$file\+Path, wchar\+\_\+t $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const wchar\+\_\+t $\ast$mode=L""wb, ccs=\+U\+T\+F-\/8"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t Ace\+::\+Write\+Binary\+FileW (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Path, }
\item[{wchar\+\_\+t $\ast$}]{buffer\+To\+Write, }
\item[{size\+\_\+t}]{buffer\+Size, }
\item[{const wchar\+\_\+t $\ast$}]{mode = {\ttfamily L\char`\"{}wb,~ccs=UTF-\/8\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a3dd67050348d7bd1838b2a85e53a93f3}


Opens a file for writing and returns the number of items/elements written to the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{size\_t} numItemsWritten = Ace::WriteBinaryFileW(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)lookupdata.bin"}, L\textcolor{stringliteral}{"0xFFFFFFFF"}, 11);
    printf(\textcolor{stringliteral}{"%d\(\backslash\)0"}, numItemsWritten);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:11


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
 & {\em buffer\+To\+Write} & The data to be written. \\
\hline
 & {\em buffer\+Size} & Maximum number of bytes to read. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}w\char`\"{} for write, \char`\"{}w+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Number of bytes to offset from origin. \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The buffer containing the file data of size num\+Bytes\+To\+Read. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Write\+Text\+File@{Write\+Text\+File}}
\index{Write\+Text\+File@{Write\+Text\+File}!Ace@{Ace}}
\subsubsection[{Write\+Text\+File(char $\ast$file\+Path, char $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const char $\ast$mode=""w"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t Ace\+::\+Write\+Text\+File (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Path, }
\item[{char $\ast$}]{buffer\+To\+Write, }
\item[{size\+\_\+t}]{buffer\+Size, }
\item[{const char $\ast$}]{mode = {\ttfamily \char`\"{}w\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af96ec8733f6e776aa2296afd79dfe38c}


Opens a file for writing and returns the number of items/elements written to the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{char}* buffer = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"In a row?!"});
    \textcolor{keywordtype}{size\_t} bufferSize = strlen(buffer) * \textcolor{keyword}{sizeof}(char);
    \textcolor{keywordtype}{size\_t} retVal = Ace::WriteTextFile(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)dicks.txt"}, buffer, bufferSize, \textcolor{stringliteral}{"a"});
    \_aligned\_free(buffer);
    buffer = Ace::ReadTextFile(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)dicks.txt"});
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, buffer);
    \_aligned\_free(buffer);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:dicksdicksdicksdicksdicksdicksdick8=$>$In a row?!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
\mbox{\tt in}  & {\em buffer\+To\+Write} & The data to be written. \\
\hline
 & {\em buffer\+Size} & Size of the buffer in bytes. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}w\char`\"{} for write, \char`\"{}w+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Either zero, or a value returned by ftell(). \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of items/elements written to the file. Throws an exception if error occurs. 
\end{DoxyReturn}
\index{Ace@{Ace}!Write\+Text\+FileW@{Write\+Text\+FileW}}
\index{Write\+Text\+FileW@{Write\+Text\+FileW}!Ace@{Ace}}
\subsubsection[{Write\+Text\+File\+W(wchar\+\_\+t $\ast$file\+Path, wchar\+\_\+t $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const wchar\+\_\+t $\ast$mode=L""w, ccs=\+U\+T\+F-\/8"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t Ace\+::\+Write\+Text\+FileW (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Path, }
\item[{wchar\+\_\+t $\ast$}]{buffer\+To\+Write, }
\item[{size\+\_\+t}]{buffer\+Size, }
\item[{const wchar\+\_\+t $\ast$}]{mode = {\ttfamily L\char`\"{}w,~ccs=UTF-\/8\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7a200d3c2e606619c3044ea50904f632}


Opens a file for writing and returns the number of items/elements written to the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
    \textcolor{keywordtype}{wchar\_t}* buffer = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{""});
    \textcolor{keywordtype}{size\_t} bufferSize = wcslen(buffer) * \textcolor{keyword}{sizeof}(wchar\_t);
    \textcolor{keywordtype}{size\_t} retVal = Ace::WriteTextFileW(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)jap.txt"}, buffer, bufferSize, L\textcolor{stringliteral}{"a, ccs=UTF-8"});
    \_aligned\_free(buffer);
    buffer = Ace::ReadTextFileW(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)jap.txt"});
    MessageBoxW(NULL, buffer, NULL, 0);
    \_aligned\_free(buffer);
\}
\textcolor{keywordflow}{catch} (\textcolor{keywordtype}{char}* exceptionMessage)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, exceptionMessage);
\}
\end{DoxyCode}
 Output\+:


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
\mbox{\tt in}  & {\em buffer\+To\+Write} & The data to be written. \\
\hline
 & {\em buffer\+Size} & Size of the buffer in bytes. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}w\char`\"{} for write, \char`\"{}w+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Either zero, or a value returned by ftell(). \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of items/elements written to the file. Throws an exception if error occurs. 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
{\bf Ace.\+h}\item 
{\bf Ace.\+cpp}\end{DoxyCompactItemize}
