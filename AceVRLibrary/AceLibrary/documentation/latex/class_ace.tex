\section{Ace Class Reference}
\label{class_ace}\index{Ace@{Ace}}


{\ttfamily \#include $<$Ace.\+h$>$}

\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static double {\bf Absolute\+Value} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the absolute value of a number in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Absolute\+Value} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the absolute value of a number in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Allocate\+And\+Copy\+String} (char $\ast$str\+To\+Copy)
\begin{DoxyCompactList}\small\item\em Allocates a buffer and copies a provided traditional string into the buffer. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Allocate\+And\+Copy\+String} (wchar\+\_\+t $\ast$wide\+Str\+To\+Copy)
\begin{DoxyCompactList}\small\item\em Allocates a buffer and copies a provided traditional wide string into the buffer. \end{DoxyCompactList}\item 
static double {\bf Arc\+Cos} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Cos in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+Cos} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Cos in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Arc\+Cosh} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Cosh in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+Cosh} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Cosh in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Arc\+Sin} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Sin in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+Sin} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Sin in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Arc\+SinH} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+SinH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+SinH} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+SinH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Arc\+Tan} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Tan in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+Tan} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Tan in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Arc\+TanH} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+TanH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+TanH} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+TanH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Arc\+Tan2} (double y\+In\+Radians, double x\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Tan2 in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Arc\+Tan2} (float y\+In\+Radians, float x\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Arc\+Tan2 in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static L\+O\+N\+G\+L\+O\+NG {\bf Calculate\+File\+Size} (char $\ast$the\+File\+Path)
\begin{DoxyCompactList}\small\item\em Uses fseek() to calculate the size of the file by moving the file pointer to the end. \end{DoxyCompactList}\item 
static L\+O\+N\+G\+L\+O\+NG {\bf Calculate\+File\+Size} (wchar\+\_\+t $\ast$the\+File\+Path)
\begin{DoxyCompactList}\small\item\em Gets the size of the file in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Ceiling} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the smallest integer value greater than or equal to num. \end{DoxyCompactList}\item 
static float {\bf Ceiling} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the smallest integer value greater than or equal to num. \end{DoxyCompactList}\item 
static char {\bf Char\+At} (char $\ast$str, int index)
\begin{DoxyCompactList}\small\item\em Returns a single character in str at a specified index. \end{DoxyCompactList}\item 
static wchar\+\_\+t {\bf Char\+At} (wchar\+\_\+t $\ast$str, int index)
\begin{DoxyCompactList}\small\item\em Returns a single character in str at a specified index. \end{DoxyCompactList}\item 
static double {\bf Complementary\+Error\+Function} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the Complementary Error Function integral from num to infinity in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Complementary\+Error\+Function} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the Complementary Error Function integral from num to infinity in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Concatenate\+Strings} (int num\+Strings, char $\ast$$\ast$string\+Array)
\begin{DoxyCompactList}\small\item\em Appends an array of strings together and returns the combined string. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Concatenate\+Strings} (int num\+Strings, wchar\+\_\+t $\ast$$\ast$string\+Array)
\begin{DoxyCompactList}\small\item\em Appends an array of strings together and returns the combined string. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Concatenate\+Strings} (vector$<$ char $\ast$ $>$ string\+Vector\+Array)
\begin{DoxyCompactList}\small\item\em Appends a vector array of strings together and returns the combined string. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Concatenate\+Strings} (vector$<$ wchar\+\_\+t $\ast$ $>$ string\+Vector\+Array)
\begin{DoxyCompactList}\small\item\em Appends a vector array of wide strings together and returns the combined wide string. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Concatenate} (int num\+Strings,...)
\begin{DoxyCompactList}\small\item\em Appends a series of strings together. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf ConcatenateW} (int num\+Wide\+Strings,...)
\begin{DoxyCompactList}\small\item\em Appends a series of strings together. \end{DoxyCompactList}\item 
static bool {\bf Contains} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns true if found. \end{DoxyCompactList}\item 
static bool {\bf Contains} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns true if found. \end{DoxyCompactList}\item 
static bool {\bf Contains\+Ignore\+Case} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns true if found. \end{DoxyCompactList}\item 
static bool {\bf Contains\+Ignore\+Case} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns true if found. \end{DoxyCompactList}\item 
static bool {\bf Convert\+Int\+To\+Bool} (int num)
\begin{DoxyCompactList}\small\item\em By definition, false is equal to 0 and true is equal to anything but 0. \end{DoxyCompactList}\item 
static vector$<$ char $\ast$ $>$ {\bf Convert\+String\+Array\+To\+String\+Vector\+Array} (char $\ast$$\ast$string\+Array)
\begin{DoxyCompactList}\small\item\em Converts a traditional string array to a vector string array. \end{DoxyCompactList}\item 
static vector$<$ wchar\+\_\+t $\ast$ $>$ {\bf Convert\+String\+Array\+To\+String\+Vector\+Array} (wchar\+\_\+t $\ast$$\ast$string\+Array)
\begin{DoxyCompactList}\small\item\em Converts a traditional wide string array to a vector wide string array. \end{DoxyCompactList}\item 
static bool {\bf Convert\+String\+To\+Bool} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a given string to a bool, If str is a string like \char`\"{}\+False\char`\"{}, \char`\"{}\+F\+A\+L\+S\+E\char`\"{}, or \char`\"{}t\+Ru\+E\char`\"{}, then the function will return false, false, true respectively. \end{DoxyCompactList}\item 
static bool {\bf Convert\+String\+To\+Bool} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a given wide string to a bool, If str is a wide string like \char`\"{}\+False\char`\"{}, \char`\"{}\+F\+A\+L\+S\+E\char`\"{}, or \char`\"{}t\+Ru\+E\char`\"{}, then the function will return false, false, true respectively. \end{DoxyCompactList}\item 
static float $\ast$ {\bf Convert\+String\+To\+Float\+Array} (char $\ast$str\+To\+Convert, char $\ast$delimiter, int \&out\+Num\+Items)
\begin{DoxyCompactList}\small\item\em Converts a tokenized string (a string with commas separating numbers for example) to an array of floats. \end{DoxyCompactList}\item 
static float $\ast$ {\bf Convert\+String\+To\+Float\+Array} (wchar\+\_\+t $\ast$str\+To\+Convert, wchar\+\_\+t $\ast$delimiter, int \&out\+Num\+Items)
\begin{DoxyCompactList}\small\item\em Converts a tokenized wide string (a string with commas separating numbers for example) to an array of floats. \end{DoxyCompactList}\item 
static unsigned int {\bf Convert\+String\+To\+Hex} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a string to its hex value. \end{DoxyCompactList}\item 
static unsigned int {\bf Convert\+String\+To\+Hex} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a string to its hex value. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Convert\+String\+To\+One\+Line} (char $\ast$str\+To\+Convert)
\begin{DoxyCompactList}\small\item\em Converts a traditional string to a traditional string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Convert\+String\+To\+One\+Line} (wchar\+\_\+t $\ast$str\+To\+Convert)
\begin{DoxyCompactList}\small\item\em Converts a traditional wide string to a traditional wide string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. \end{DoxyCompactList}\item 
static void {\bf Convert\+String\+To\+One\+Line\+In\+Place} (char $\ast$str\+To\+Convert)
\begin{DoxyCompactList}\small\item\em Converts a traditional string to a traditional string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. \end{DoxyCompactList}\item 
static void {\bf Convert\+String\+To\+One\+Line\+In\+Place} (wchar\+\_\+t $\ast$str\+To\+Convert)
\begin{DoxyCompactList}\small\item\em Converts a traditional wide string to a traditional wide string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Convert\+String\+To\+W\+Char\+String} (const char $\ast$str\+To\+Convert)
\begin{DoxyCompactList}\small\item\em Converts a traditional string to a wide string. \end{DoxyCompactList}\item 
static char $\ast$$\ast$ {\bf Convert\+String\+Vector\+Array\+To\+String\+Array} (vector$<$ char $\ast$ $>$ string\+Vector\+Array)
\begin{DoxyCompactList}\small\item\em Converts a string vector array to a traditional string array. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$$\ast$ {\bf Convert\+String\+Vector\+Array\+To\+String\+Array} (vector$<$ wchar\+\_\+t $\ast$ $>$ string\+Vector\+Array)
\begin{DoxyCompactList}\small\item\em Converts a wide string vector array to a traditional wide string array. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Convert\+To\+Lower\+Case} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a string to all lowercase letters. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Convert\+To\+Lower\+Case} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a wide string to all lowercase letters. \end{DoxyCompactList}\item 
static void {\bf Convert\+To\+Lower\+Case\+In\+Place} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Directly modifies str to have all its letters converted to lower case. \end{DoxyCompactList}\item 
static void {\bf Convert\+To\+Lower\+Case\+In\+Place} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Directly modifies str to have all its letters converted to lower case. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Convert\+To\+Upper\+Case} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a string to all uppercase letters. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Convert\+To\+Upper\+Case} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Converts a string to all uppercase letters. \end{DoxyCompactList}\item 
static void {\bf Convert\+To\+Upper\+Case\+In\+Place} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Directly modifies str to have all its letters converted to upper case. \end{DoxyCompactList}\item 
static void {\bf Convert\+To\+Upper\+Case\+In\+Place} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Directly modifies str to have all its letters converted to upper case. \end{DoxyCompactList}\item 
static double {\bf Cos} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Cosine (cos) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Cos} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Cosine (cos) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf CosH} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the CosH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf CosH} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the CosH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Count\+Num\+Occurrences} (char $\ast$str\+To\+Search, char char\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Counts the number of times char\+To\+Look\+For appears in str\+To\+Search. \end{DoxyCompactList}\item 
static int {\bf Count\+Num\+Occurrences} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t char\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Counts the number of times char\+To\+Look\+For appears in str\+To\+Search. \end{DoxyCompactList}\item 
static int {\bf Count\+Num\+Occurrences} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Counts the number of times str\+To\+Look\+For appears in str\+To\+Search. \end{DoxyCompactList}\item 
static int {\bf Count\+Num\+Occurrences} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Counts the number of times str\+To\+Look\+For appears in str\+To\+Search. \end{DoxyCompactList}\item 
static double {\bf Cube\+Root} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the Cube Root in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Cube\+Root} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the Cube Root in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Degrees\+To\+Radians} (double degrees)
\begin{DoxyCompactList}\small\item\em Converts a number from degrees to radians. \end{DoxyCompactList}\item 
static float {\bf Degrees\+To\+Radians} (float degrees)
\begin{DoxyCompactList}\small\item\em Converts a number from degrees to radians. \end{DoxyCompactList}\item 
static bool {\bf Does\+File\+Exist} (char $\ast$full\+File\+Path\+With\+Name\+And\+Ext)
\begin{DoxyCompactList}\small\item\em Returns true if the specified file exists, false otherwise. \end{DoxyCompactList}\item 
static bool {\bf Does\+File\+Exist} (wchar\+\_\+t $\ast$full\+File\+Path\+With\+Name\+And\+Ext)
\begin{DoxyCompactList}\small\item\em Returns true if the specified file exists, false otherwise. \end{DoxyCompactList}\item 
static double {\bf Error\+Function} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the Error Function integral from 0 to num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Error\+Function} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the Error Function integral from 0 to num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static bool {\bf Equals} (char $\ast$str\+To\+Comp\+One, char $\ast$str\+To\+Comp\+Two)
\begin{DoxyCompactList}\small\item\em Compares two traditional strings together. \end{DoxyCompactList}\item 
static bool {\bf Equals} (wchar\+\_\+t $\ast$str\+To\+Comp\+One, wchar\+\_\+t $\ast$str\+To\+Comp\+Two)
\begin{DoxyCompactList}\small\item\em Compares two traditional wide strings together. \end{DoxyCompactList}\item 
static bool {\bf Equals\+Ignore\+Case} (char $\ast$str\+To\+Comp\+One, char $\ast$str\+To\+Comp\+Two)
\begin{DoxyCompactList}\small\item\em Compares two traditional strings together but ignores upper/lower case. \end{DoxyCompactList}\item 
static bool {\bf Equals\+Ignore\+Case} (wchar\+\_\+t $\ast$str\+To\+Comp\+One, wchar\+\_\+t $\ast$str\+To\+Comp\+Two)
\begin{DoxyCompactList}\small\item\em Compares two traditional wide strings together but ignores upper/lower case. \end{DoxyCompactList}\item 
static double {\bf E\+To\+The\+X\+Power} (double power)
\begin{DoxyCompactList}\small\item\em Calculates e$^\wedge$x in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf E\+To\+The\+X\+Power} (float power)
\begin{DoxyCompactList}\small\item\em Calculates e$^\wedge$x in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf E\+To\+The\+X\+Power\+Minus\+One} (double power)
\begin{DoxyCompactList}\small\item\em Calculates (e$^\wedge$x) -\/ 1 in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf E\+To\+The\+X\+Power\+Minus\+One} (float power)
\begin{DoxyCompactList}\small\item\em Calculates (e$^\wedge$x) -\/ 1 in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static char {\bf First\+Char} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Returns the first character in str. \end{DoxyCompactList}\item 
static wchar\+\_\+t {\bf First\+Char} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Returns the first character in str. \end{DoxyCompactList}\item 
static double {\bf Floor} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the largest integer value not greater than num. \end{DoxyCompactList}\item 
static float {\bf Floor} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the largest integer value not greater than num. \end{DoxyCompactList}\item 
static double {\bf Gamma\+Function} (double num)
\begin{DoxyCompactList}\small\item\em Calculates The Gamma Function ( (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] ) in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Gamma\+Function} (float num)
\begin{DoxyCompactList}\small\item\em Calculates The Gamma Function ( (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] ) in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static int {\bf Generate\+Random\+Num} (int min, int max)
\begin{DoxyCompactList}\small\item\em Some might think this is all unnecessary but I think it\textquotesingle{}s important to seed the Random\+Number\+Generator properly with a proper seed value. \end{DoxyCompactList}\item 
static double {\bf Hypotenuse} (double x, double y)
\begin{DoxyCompactList}\small\item\em Solves for c in Pythagoras theorem (a$^\wedge$2 + b$^\wedge$2 = c$^\wedge$2); i.\+e square root of (x$^\wedge$2 + y$^\wedge$2). \end{DoxyCompactList}\item 
static float {\bf Hypotenuse} (float x, float y)
\begin{DoxyCompactList}\small\item\em Solves for c in Pythagoras theorem (a$^\wedge$2 + b$^\wedge$2 = c$^\wedge$2); i.\+e square root of (x$^\wedge$2 + y$^\wedge$2). \end{DoxyCompactList}\item 
static int {\bf Index\+Of} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static int {\bf Index\+Of} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static int {\bf Index\+Of\+First\+Letter} (char $\ast$str\+To\+Search)
\begin{DoxyCompactList}\small\item\em Returns the first index of a letter in a given string. \end{DoxyCompactList}\item 
static int {\bf Index\+Of\+First\+Letter} (wchar\+\_\+t $\ast$str\+To\+Search)
\begin{DoxyCompactList}\small\item\em Returns the first index of a letter in a given wide string. \end{DoxyCompactList}\item 
static int {\bf Index\+Of\+Ignore\+Case} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static int {\bf Index\+Of\+Ignore\+Case} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Insert\+String} (char $\ast$str\+To\+Receive, char $\ast$str\+To\+Insert, int start\+Index)
\begin{DoxyCompactList}\small\item\em Inserts the string str\+To\+Insert into str\+To\+Revcive by \char`\"{}sandwiching\char`\"{} the two halves of str\+To\+Receive. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Insert\+String} (wchar\+\_\+t $\ast$str\+To\+Receive, wchar\+\_\+t $\ast$str\+To\+Insert, int start\+Index)
\begin{DoxyCompactList}\small\item\em Inserts the string str\+To\+Insert into str\+To\+Revcive by \char`\"{}sandwiching\char`\"{} the two halves of str\+To\+Receive. \end{DoxyCompactList}\item 
static bool {\bf Is\+Alphabetic} (char character)
\begin{DoxyCompactList}\small\item\em Returns true if a character is a letter from either a to z or A to Z. \end{DoxyCompactList}\item 
static bool {\bf Is\+Alphabetic} (wchar\+\_\+t character)
\begin{DoxyCompactList}\small\item\em Returns true if a wide character is not a digit. \end{DoxyCompactList}\item 
static bool {\bf Is\+Digit} (char character)
\begin{DoxyCompactList}\small\item\em Returns true if a character is a digit from 0-\/9. \end{DoxyCompactList}\item 
static bool {\bf Is\+Digit} (wchar\+\_\+t character)
\begin{DoxyCompactList}\small\item\em Returns true if a wide character is a digit. \end{DoxyCompactList}\item 
static bool {\bf Is\+Empty} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Searches a given string to see if it is all empty. \end{DoxyCompactList}\item 
static bool {\bf Is\+Empty} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Searches a given wide string to see if it is all empty. \end{DoxyCompactList}\item 
static bool {\bf Is\+Number} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Returns true if all characters are a digit. \end{DoxyCompactList}\item 
static bool {\bf Is\+Number} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Returns true if all characters are a digit. \end{DoxyCompactList}\item 
static bool {\bf Is\+Path\+A\+Device} (const char $\ast$path)
\begin{DoxyCompactList}\small\item\em Returns true if the provided path leads to a device rather than a file. \end{DoxyCompactList}\item 
static bool {\bf Is\+Path\+A\+Device} (const wchar\+\_\+t $\ast$path)
\begin{DoxyCompactList}\small\item\em Returns true if the provided path leads to a device rather than a file. \end{DoxyCompactList}\item 
static bool {\bf Is\+Whitespace} (char character)
\begin{DoxyCompactList}\small\item\em Returns true if a character is whitespace. \end{DoxyCompactList}\item 
static bool {\bf Is\+Whitespace} (wchar\+\_\+t character)
\begin{DoxyCompactList}\small\item\em Returns true if a wide character is whitespace. \end{DoxyCompactList}\item 
static double {\bf Largest} (double num1, double num2)
\begin{DoxyCompactList}\small\item\em Returns the larger of the two values. \end{DoxyCompactList}\item 
static float {\bf Largest} (float num1, float num2)
\begin{DoxyCompactList}\small\item\em Returns the larger of the two values. \end{DoxyCompactList}\item 
static char {\bf Last\+Char} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Returns the last character in str. \end{DoxyCompactList}\item 
static wchar\+\_\+t {\bf Last\+Char} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Returns the last character in str. \end{DoxyCompactList}\item 
static int {\bf Last\+Index\+Of} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the last occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static int {\bf Last\+Index\+Of} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)
\begin{DoxyCompactList}\small\item\em Searches str\+To\+Search for the last occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. \end{DoxyCompactList}\item 
static double {\bf Log\+Base\+Ten} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the logarithm (log) base 10 of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Log\+Base\+Ten} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the logarithm (log) base 10 of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Log\+Base\+Two} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the logarithm (log) base 2 of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Log\+Base\+Two} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the logarithm (log) base 2 of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Mod} (double numerator, double denominator)
\begin{DoxyCompactList}\small\item\em Computes the floating-\/point remainder of the division operation numerator/denominator in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Mod} (float numerator, float denominator)
\begin{DoxyCompactList}\small\item\em Computes the floating-\/point remainder of the division operation numerator/denominator in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Multiply\+Then\+Add} (double mult\+One, double mult\+Two, double add)
\begin{DoxyCompactList}\small\item\em Calculates the product of mult\+One $\ast$ mult\+Two, then adds add to that product (i.\+e. \end{DoxyCompactList}\item 
static float {\bf Multiply\+Then\+Add} (float mult\+One, float mult\+Two, float add)
\begin{DoxyCompactList}\small\item\em Calculates the product of mult\+One $\ast$ mult\+Two, then adds add to that product (i.\+e. \end{DoxyCompactList}\item 
static double {\bf Natural\+Log} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the Natural Logarithm (ln) of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Natural\+Log} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the Natural Logarithm (ln) of num in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Natural\+Log\+Gamma\+Function} (double num)
\begin{DoxyCompactList}\small\item\em Calculates The Natural Log (ln) of The Gamma Function (ln $\vert$ (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] $\vert$). \end{DoxyCompactList}\item 
static float {\bf Natural\+Log\+Gamma\+Function} (float num)
\begin{DoxyCompactList}\small\item\em Calculates The Natural Log (ln) of The Gamma Function (ln $\vert$ (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] $\vert$). \end{DoxyCompactList}\item 
static int {\bf Next\+Index\+Of} (char $\ast$str\+To\+Search, char char\+To\+Look\+For, int start\+Index)
\begin{DoxyCompactList}\small\item\em Retrieves the first occurrence of char\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. \end{DoxyCompactList}\item 
static int {\bf Next\+Index\+Of} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t char\+To\+Look\+For, int start\+Index)
\begin{DoxyCompactList}\small\item\em Retrieves the first occurrence of char\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. \end{DoxyCompactList}\item 
static int {\bf Next\+Index\+Of} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For, int start\+Index)
\begin{DoxyCompactList}\small\item\em Retrieves the first occurrence of str\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. \end{DoxyCompactList}\item 
static int {\bf Next\+Index\+Of} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For, int start\+Index)
\begin{DoxyCompactList}\small\item\em Retrieves the first occurrence of str\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. \end{DoxyCompactList}\item 
static double {\bf Num\+Times\+Two\+To\+The\+X\+Power} (double num, double power)
\begin{DoxyCompactList}\small\item\em Calculates num $\ast$ 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Num\+Times\+Two\+To\+The\+X\+Power} (float num, float power)
\begin{DoxyCompactList}\small\item\em Calculates num $\ast$ 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Power} (double base, double exponent)
\begin{DoxyCompactList}\small\item\em Takes the provided base and raises it to the exponent (power). \end{DoxyCompactList}\item 
static float {\bf Power} (float base, float exponent)
\begin{DoxyCompactList}\small\item\em Takes the provided base and raises it to the exponent (power). \end{DoxyCompactList}\item 
static double {\bf Positive\+Difference} (double num\+One, double num\+Two)
\begin{DoxyCompactList}\small\item\em Calculates the difference between num\+One and num\+Two only if num\+One $>$ num\+Two. \end{DoxyCompactList}\item 
static float {\bf Positive\+Difference} (float num\+One, float num\+Two)
\begin{DoxyCompactList}\small\item\em Calculates the difference between num\+One and num\+Two only if num\+One $>$ num\+Two. \end{DoxyCompactList}\item 
static double {\bf Radians\+To\+Degrees} (double radians)
\begin{DoxyCompactList}\small\item\em Converts a number from radians to degrees. \end{DoxyCompactList}\item 
static float {\bf Radians\+To\+Degrees} (float radians)
\begin{DoxyCompactList}\small\item\em Converts a number from radians to degrees. \end{DoxyCompactList}\item 
static double {\bf Remainder} (double numerator, double denominator)
\begin{DoxyCompactList}\small\item\em Calculates the Computes The I\+E\+EE remainder of the floating point division operation numerator/denominator. \end{DoxyCompactList}\item 
static float {\bf Remainder} (float numerator, float denominator)
\begin{DoxyCompactList}\small\item\em Calculates the Computes The I\+E\+EE remainder of the floating point division operation numerator/denominator. \end{DoxyCompactList}\item 
static double {\bf Remainder\+With\+Quadrant} (double numerator, double denominator, int $\ast$out\+Quadrant)
\begin{DoxyCompactList}\small\item\em Calculates the floating-\/point remainder of the division operation numerator/denominator the same way the \doxyref{Remainder()}{p.}{class_ace_a0f05443f499ce94d53c3a5e584460d52} function does. \end{DoxyCompactList}\item 
static float {\bf Remainder\+With\+Quadrant} (float numerator, float denominator, int $\ast$out\+Quadrant)
\begin{DoxyCompactList}\small\item\em Calculates the floating-\/point remainder of the division operation numerator/denominator the same way the \doxyref{Remainder()}{p.}{class_ace_a0f05443f499ce94d53c3a5e584460d52} function does. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Remove\+All\+Whitespace} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Removes all whitespace from a given string. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Remove\+All\+Whitespace} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Removes all whitespace from a given wide string. \end{DoxyCompactList}\item 
static void {\bf Remove\+All\+Whitespace\+In\+Place} (char $\ast$str)
\begin{DoxyCompactList}\small\item\em Removes all whitespace from a given string in place. \end{DoxyCompactList}\item 
static void {\bf Remove\+All\+Whitespace\+In\+Place} (wchar\+\_\+t $\ast$str)
\begin{DoxyCompactList}\small\item\em Removes all whitespace from a given wide string in place. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Remove\+Characters\+From\+String} (char $\ast$str\+To\+Remove\+From, char char\+To\+Remove)
\begin{DoxyCompactList}\small\item\em Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Remove\+Characters\+From\+String} (wchar\+\_\+t $\ast$str\+To\+Remove\+From, wchar\+\_\+t char\+To\+Remove)
\begin{DoxyCompactList}\small\item\em Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. \end{DoxyCompactList}\item 
static void {\bf Remove\+Characters\+From\+String\+In\+Place} (char $\ast$str\+To\+Remove\+From, char char\+To\+Remove)
\begin{DoxyCompactList}\small\item\em Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. \end{DoxyCompactList}\item 
static void {\bf Remove\+Characters\+From\+String\+In\+Place} (wchar\+\_\+t $\ast$str\+To\+Remove\+From, wchar\+\_\+t char\+To\+Remove)
\begin{DoxyCompactList}\small\item\em Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Replace\+String} (char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For, char $\ast$str\+To\+Replace\+With)
\begin{DoxyCompactList}\small\item\em Inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Replace\+String} (wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For, wchar\+\_\+t $\ast$str\+To\+Replace\+With)
\begin{DoxyCompactList}\small\item\em Inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. \end{DoxyCompactList}\item 
static void {\bf Replace\+String\+In\+Place} (char $\ast$\&str\+To\+Search, char $\ast$str\+To\+Look\+For, char $\ast$str\+To\+Replace\+With)
\begin{DoxyCompactList}\small\item\em Directly modifies and inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. \end{DoxyCompactList}\item 
static void {\bf Replace\+String\+In\+Place} (wchar\+\_\+t $\ast$\&str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For, wchar\+\_\+t $\ast$str\+To\+Replace\+With)
\begin{DoxyCompactList}\small\item\em Directly modifies and inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Retrieve\+Data\+Between\+Tags} (char $\ast$file\+Data, char $\ast$start\+Tag, char $\ast$end\+Tag)
\begin{DoxyCompactList}\small\item\em Finds the X\+ML data between the start\+Tag and end\+Tag and returns it. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Retrieve\+Data\+Between\+Tags} (wchar\+\_\+t $\ast$file\+Data, wchar\+\_\+t $\ast$start\+Tag, wchar\+\_\+t $\ast$end\+Tag)
\begin{DoxyCompactList}\small\item\em Finds the X\+ML data between the start\+Tag and end\+Tag and returns it. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Retrieve\+Data\+Between\+Tags} (char $\ast$file\+Data, int start\+Tag\+Index, int end\+Tag\+Index)
\begin{DoxyCompactList}\small\item\em Finds the X\+ML data between the start\+Tag\+Index and end\+Tag\+Index and returns it. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Retrieve\+Data\+Between\+Tags} (wchar\+\_\+t $\ast$file\+Data, int start\+Tag\+Index, int end\+Tag\+Index)
\begin{DoxyCompactList}\small\item\em Finds the X\+ML data between the start\+Tag\+Index and end\+Tag\+Index and returns it. \end{DoxyCompactList}\item 
static char $\ast$$\ast$ {\bf Retrieve\+Data\+Chunks\+Between\+Tags} (char $\ast$file\+Data, char $\ast$start\+Tag, char $\ast$end\+Tag, int \&out\+Final\+Buffer\+Size)
\begin{DoxyCompactList}\small\item\em Finds a series of X\+ML data between start\+Tag and end\+Tag. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$$\ast$ {\bf Retrieve\+Data\+Chunks\+Between\+Tags} (wchar\+\_\+t $\ast$file\+Data, wchar\+\_\+t $\ast$start\+Tag, wchar\+\_\+t $\ast$end\+Tag, int \&out\+Final\+Buffer\+Size)
\begin{DoxyCompactList}\small\item\em Finds a series of X\+ML data between start\+Tag and end\+Tag. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Read\+Text\+File} (char $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size={\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}, const char $\ast$mode=\char`\"{}r\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for reading and returns a char buffer containing some or all of the data in the file. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Read\+Text\+FileW} (wchar\+\_\+t $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size={\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}, const wchar\+\_\+t $\ast$mode=L\char`\"{}r, ccs=U\+TF-\/8\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for reading and returns a wide char buffer containing some or all of the data in the file. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Read\+Binary\+File} (char $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size={\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}, const char $\ast$mode=\char`\"{}rb\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for reading and returns a char buffer containing some or all of the data in the file. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Read\+Binary\+FileW} (wchar\+\_\+t $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size={\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}, const wchar\+\_\+t $\ast$mode=L\char`\"{}rb, ccs=U\+TF-\/8\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for reading and returns a wide char buffer containing some or all of the data in the file. \end{DoxyCompactList}\item 
static vector$<$ char $\ast$ $>$ {\bf Retrieve\+File\+Names} (char $\ast$full\+File\+Path)
\begin{DoxyCompactList}\small\item\em Returns all the names of the files inside a folder, Ignores non files like folders. \end{DoxyCompactList}\item 
static vector$<$ wchar\+\_\+t $\ast$ $>$ {\bf Retrieve\+File\+Names} (wchar\+\_\+t $\ast$full\+File\+Path)
\begin{DoxyCompactList}\small\item\em Returns all the names of the files inside a folder, Ignores non files like folders. \end{DoxyCompactList}\item 
static vector$<$ char $\ast$ $>$ {\bf Retrieve\+Folder\+Names} (char $\ast$full\+File\+Path)
\begin{DoxyCompactList}\small\item\em Returns all the names of the sub-\/folder(s) in a folder. \end{DoxyCompactList}\item 
static vector$<$ wchar\+\_\+t $\ast$ $>$ {\bf Retrieve\+Folder\+Names} (wchar\+\_\+t $\ast$full\+File\+Path)
\begin{DoxyCompactList}\small\item\em Returns all the names of the sub-\/folder(s) in a folder. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Reverse\+String} (char $\ast$str\+To\+Reverse)
\begin{DoxyCompactList}\small\item\em Creates a new string containing all the characters from str\+To\+Reverse in reverse order. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Reverse\+String} (wchar\+\_\+t $\ast$str\+To\+Reverse)
\begin{DoxyCompactList}\small\item\em Creates a new wide string containing all the characters from str\+To\+Reverse in reverse order. \end{DoxyCompactList}\item 
static void {\bf Reverse\+String\+In\+Place} (char $\ast$str\+To\+Reverse)
\begin{DoxyCompactList}\small\item\em Directly modifies str\+To\+Reverse to have all its characters in reverse order. \end{DoxyCompactList}\item 
static void {\bf Reverse\+String\+In\+Place} (wchar\+\_\+t $\ast$str\+To\+Reverse)
\begin{DoxyCompactList}\small\item\em Directly modifies str\+To\+Reverse to have all its characters in reverse order. \end{DoxyCompactList}\item 
static long {\bf Round\+To\+Nearest\+Integer} (double num)
\begin{DoxyCompactList}\small\item\em Rounds the floating-\/point argument num to an integer value, using the current rounding mode. \end{DoxyCompactList}\item 
static long {\bf Round\+To\+Nearest\+Integer} (float num)
\begin{DoxyCompactList}\small\item\em Rounds the floating-\/point argument num to an integer value, using the current rounding mode. \end{DoxyCompactList}\item 
static long {\bf Round\+Up} (double num)
\begin{DoxyCompactList}\small\item\em Calculates the nearest integer value to num (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode. \end{DoxyCompactList}\item 
static long {\bf Round\+Up} (float num)
\begin{DoxyCompactList}\small\item\em Calculates the nearest integer value to num (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode. \end{DoxyCompactList}\item 
static double {\bf SinH} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the SinH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf SinH} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the SinH in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf Smallest} (double num1, double num2)
\begin{DoxyCompactList}\small\item\em Calculates the smaller of the two values and returns the smaller one. \end{DoxyCompactList}\item 
static float {\bf Smallest} (float num1, float num2)
\begin{DoxyCompactList}\small\item\em Calculates the smaller of the two values and returns the smaller one. \end{DoxyCompactList}\item 
static double {\bf Square\+Root} (double num)
\begin{DoxyCompactList}\small\item\em Returns the Square Root of the provided number. \end{DoxyCompactList}\item 
static float {\bf Square\+Root} (float num)
\begin{DoxyCompactList}\small\item\em Returns the Square Root of the provided number. \end{DoxyCompactList}\item 
static char $\ast$ {\bf Sub\+String} (char $\ast$str, int start\+Index, int up\+To\+But\+Not\+Including\+Index=I\+N\+T\+\_\+\+M\+AX)
\begin{DoxyCompactList}\small\item\em Returns a string containing the characters between start\+Index and up\+To\+But\+Not\+Including\+Index. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$ {\bf Sub\+String} (wchar\+\_\+t $\ast$str, int start\+Index, int up\+To\+But\+Not\+Including\+Index=I\+N\+T\+\_\+\+M\+AX)
\begin{DoxyCompactList}\small\item\em Returns a wide string containing the characters between start\+Index and up\+To\+But\+Not\+Including\+Index. \end{DoxyCompactList}\item 
static double {\bf Tan} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Tangent (Tan) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Tan} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates the Tangent (Tan) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static double {\bf TanH} (double num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates The Hyperbolic Tangent (TanH) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf TanH} (float num\+In\+Radians)
\begin{DoxyCompactList}\small\item\em Calculates The Hyperbolic Tangent (TanH) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static char $\ast$$\ast$ {\bf Tokenize} (char $\ast$str\+To\+Tokenize, char $\ast$delimiter, int \&out\+Num\+Tokens\+Found)
\begin{DoxyCompactList}\small\item\em Breaks up a string and returns an array of all the strings between each delimiter. \end{DoxyCompactList}\item 
static wchar\+\_\+t $\ast$$\ast$ {\bf Tokenize} (wchar\+\_\+t $\ast$str\+To\+Tokenize, wchar\+\_\+t $\ast$delimiter, int \&out\+Num\+Tokens\+Found)
\begin{DoxyCompactList}\small\item\em Breaks up a wide string and returns an array of all the wide strings between each delimiter. \end{DoxyCompactList}\item 
static double {\bf Truncate} (double num)
\begin{DoxyCompactList}\small\item\em Removes everything after the decimal point. \end{DoxyCompactList}\item 
static float {\bf Truncate} (float num)
\begin{DoxyCompactList}\small\item\em Removes everything after the decimal point. \end{DoxyCompactList}\item 
static double {\bf Two\+To\+The\+X\+Power} (double power)
\begin{DoxyCompactList}\small\item\em Calculates 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static float {\bf Two\+To\+The\+X\+Power} (float power)
\begin{DoxyCompactList}\small\item\em Calculates 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. \end{DoxyCompactList}\item 
static size\+\_\+t {\bf Write\+Text\+File} (char $\ast$file\+Path, char $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const char $\ast$mode=\char`\"{}w\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for writing and returns the number of items/elements written to the file. \end{DoxyCompactList}\item 
static size\+\_\+t {\bf Write\+Text\+FileW} (wchar\+\_\+t $\ast$file\+Path, wchar\+\_\+t $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const wchar\+\_\+t $\ast$mode=L\char`\"{}w, ccs=U\+TF-\/8\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for writing and returns the number of items/elements written to the file. \end{DoxyCompactList}\item 
static size\+\_\+t {\bf Write\+Binary\+File} (char $\ast$file\+Path, char $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const char $\ast$mode=\char`\"{}wb\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for writing and returns the number of items/elements written to the file. \end{DoxyCompactList}\item 
static size\+\_\+t {\bf Write\+Binary\+FileW} (wchar\+\_\+t $\ast$file\+Path, wchar\+\_\+t $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const wchar\+\_\+t $\ast$mode=L\char`\"{}wb, ccs=U\+TF-\/8\char`\"{}, int seek\+Offset=0, int seek\+Origin=S\+E\+E\+K\+\_\+\+S\+ET, long $\ast$out\+End\+Cursor\+Pos=N\+U\+LL)
\begin{DoxyCompactList}\small\item\em Opens a file for writing and returns the number of items/elements written to the file. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\index{Ace@{Ace}!Absolute\+Value@{Absolute\+Value}}
\index{Absolute\+Value@{Absolute\+Value}!Ace@{Ace}}
\subsubsection[{Absolute\+Value(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Absolute\+Value (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae1d25ce89a5152ac3dd591aa75c57764}


Calculates the absolute value of a number in compliance with C\+E\+RT Coding Standard. 

The absolute value is the positive version of value (example\+: $\vert$3-\/4$\vert$ = 1).

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
:
   \textcolor{keywordtype}{double} retVal = Ace::AbsoluteValue(-2.3);
   printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 2.\+300000


\begin{DoxyParams}{Parameters}
{\em num} & The number to use to determine the absolute value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The absolute value of num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Absolute\+Value@{Absolute\+Value}}
\index{Absolute\+Value@{Absolute\+Value}!Ace@{Ace}}
\subsubsection[{Absolute\+Value(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Absolute\+Value (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae573ce4a06f6050b29e5c8ad3285b05c}


Calculates the absolute value of a number in compliance with C\+E\+RT Coding Standard. 

The absolute value is the positive version of value (example\+: $\vert$3-\/4$\vert$ = 1).

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
:
   \textcolor{keywordtype}{float} retVal = Ace::AbsoluteValue(-2.3f);
   printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 2.\+300000


\begin{DoxyParams}{Parameters}
{\em num} & The number to use to determine the absolute value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The absolute value of num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Allocate\+And\+Copy\+String@{Allocate\+And\+Copy\+String}}
\index{Allocate\+And\+Copy\+String@{Allocate\+And\+Copy\+String}!Ace@{Ace}}
\subsubsection[{Allocate\+And\+Copy\+String(char $\ast$str\+To\+Copy)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Allocate\+And\+Copy\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae84033e0edc7822aa6a1cd3d6147dac8}


Allocates a buffer and copies a provided traditional string into the buffer. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
7/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* strToCopy = \textcolor{stringliteral}{"An eraser of love..."};
\textcolor{keywordtype}{char}* buffer = Ace::AllocateAndCopyString(strToCopy);
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, buffer);
\_aligned\_free(buffer);
\end{DoxyCode}
 Output\+:An eraser of love...


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Copy} & If non-\/null, to copy.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly allocated buffer containing str\+To\+Copy. 
\end{DoxyReturn}
\index{Ace@{Ace}!Allocate\+And\+Copy\+String@{Allocate\+And\+Copy\+String}}
\index{Allocate\+And\+Copy\+String@{Allocate\+And\+Copy\+String}!Ace@{Ace}}
\subsubsection[{Allocate\+And\+Copy\+String(wchar\+\_\+t $\ast$wide\+Str\+To\+Copy)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Allocate\+And\+Copy\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{wide\+Str\+To\+Copy}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7df3d37c864aaded3894cff9fcb72b71}


Allocates a buffer and copies a provided traditional wide string into the buffer. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
7/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* strToCopy = L\textcolor{stringliteral}{"An eraser of love..."};
\textcolor{keywordtype}{wchar\_t}* buffer = Ace::AllocateAndCopyString(strToCopy);
printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, buffer);
\_aligned\_free(buffer);
\end{DoxyCode}
 Output\+:An eraser of love...


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em wide\+Str\+To\+Copy} & If non-\/null, the wide string to copy.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly allocated buffer containing wide\+Str\+To\+Copy. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Cos@{Arc\+Cos}}
\index{Arc\+Cos@{Arc\+Cos}!Ace@{Ace}}
\subsubsection[{Arc\+Cos(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+Cos (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aec125b75d04c5ae6b9ba3f77d9ae5303}


Calculates the Arc\+Cos in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/3/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
\textcolor{keywordtype}{double} result = Ace::ArcCos(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 0.\+667457


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Cos for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Cos of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is not between -\/1 and 1, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Cos@{Arc\+Cos}}
\index{Arc\+Cos@{Arc\+Cos}!Ace@{Ace}}
\subsubsection[{Arc\+Cos(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+Cos (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa2cd7566162e0d739d730444a99b395a}


Calculates the Arc\+Cos in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
\textcolor{keywordtype}{float} result = Ace::ArcCos(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 0.\+667457


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Cos for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Cos of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is not between -\/1 and 1, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Cosh@{Arc\+Cosh}}
\index{Arc\+Cosh@{Arc\+Cosh}!Ace@{Ace}}
\subsubsection[{Arc\+Cosh(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+Cosh (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a315b29bc2074a8f2354e9607fdca545c}


Calculates the Arc\+Cosh in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/3/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::ArcCosh(1.5);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+:0.\+962424


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Cosh for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Cosh of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is less than 1, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Cosh@{Arc\+Cosh}}
\index{Arc\+Cosh@{Arc\+Cosh}!Ace@{Ace}}
\subsubsection[{Arc\+Cosh(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+Cosh (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a967e4ba19d22783893f86204712cce81}


Calculates the Arc\+Cosh in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::ArcCosh(1.5f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+:0.\+962424


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Cosh for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Cosh of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is less than 1, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Sin@{Arc\+Sin}}
\index{Arc\+Sin@{Arc\+Sin}!Ace@{Ace}}
\subsubsection[{Arc\+Sin(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+Sin (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6dda55fe05e7f2874f44e9347d64068a}


Calculates the Arc\+Sin in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
\textcolor{keywordtype}{double} result = Ace::ArcSin(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 0.\+903339


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Sin for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Sin of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is less than or equal to -\/1 or num\+In\+Radians is greater then 1, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Sin@{Arc\+Sin}}
\index{Arc\+Sin@{Arc\+Sin}!Ace@{Ace}}
\subsubsection[{Arc\+Sin(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+Sin (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab254fa951c7846affad26371c3ff2a12}


Calculates the Arc\+Sin in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
\textcolor{keywordtype}{float} result = Ace::ArcSin(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 0.\+903339


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Sin for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Sin of num\+In\+Radians. If a mathematical error occurs or num\+In\+Radians is less than or equal to -\/1 or num\+In\+Radians is greater then 1, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+SinH@{Arc\+SinH}}
\index{Arc\+SinH@{Arc\+SinH}!Ace@{Ace}}
\subsubsection[{Arc\+Sin\+H(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+SinH (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa4e43dbae9fc597031f96b6826077792}


Calculates the Arc\+SinH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
\textcolor{keywordtype}{double} result = Ace::ArcSinH(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+:0.\+721225


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+SinH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+SinH of num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+SinH@{Arc\+SinH}}
\index{Arc\+SinH@{Arc\+SinH}!Ace@{Ace}}
\subsubsection[{Arc\+Sin\+H(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+SinH (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aff6eb5ec6b5bf00bc9dab3187c0e1a35}


Calculates the Arc\+SinH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
\textcolor{keywordtype}{float} result = Ace::ArcSinH(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+:0.\+721225


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+SinH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+SinH of num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Tan@{Arc\+Tan}}
\index{Arc\+Tan@{Arc\+Tan}!Ace@{Ace}}
\subsubsection[{Arc\+Tan(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+Tan (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a34a530e5c9e7d179fa411cb182fd4b52}


Calculates the Arc\+Tan in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
\textcolor{keywordtype}{double} result = Ace::ArcTan(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 0.\+665774


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Tan for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Tan of num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Tan@{Arc\+Tan}}
\index{Arc\+Tan@{Arc\+Tan}!Ace@{Ace}}
\subsubsection[{Arc\+Tan(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+Tan (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2360cc88ef910ae6eff49033072e5273}


Calculates the Arc\+Tan in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
\textcolor{keywordtype}{float} result = Ace::ArcTan(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 0.\+665774


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+Tan for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+Tan of num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Tan2@{Arc\+Tan2}}
\index{Arc\+Tan2@{Arc\+Tan2}!Ace@{Ace}}
\subsubsection[{Arc\+Tan2(double y\+In\+Radians, double x\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+Tan2 (
\begin{DoxyParamCaption}
\item[{double}]{y, }
\item[{double}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ade721fa5fb6371e4ba4863413be468c2}


Calculates the Arc\+Tan2 in compliance with C\+E\+RT Coding Standard. 

To compute the value, the function takes into account the sign of both arguments in order to determine the quadrant.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::ArcTan2(-10.0, 5.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: -\/1.\+107149


\begin{DoxyParams}{Parameters}
{\em y} & Value representing the proportion of the y-\/coordinate. \\
\hline
{\em x} & Value representing the proportion of the x-\/coordinate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Arc Tangent of y/x, in radians. If y = 0 or x = 0, -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+Tan2@{Arc\+Tan2}}
\index{Arc\+Tan2@{Arc\+Tan2}!Ace@{Ace}}
\subsubsection[{Arc\+Tan2(float y\+In\+Radians, float x\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+Tan2 (
\begin{DoxyParamCaption}
\item[{float}]{y, }
\item[{float}]{x}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a212a9d7345151ebaa457c693b4f110c4}


Calculates the Arc\+Tan2 in compliance with C\+E\+RT Coding Standard. 

To compute the value, the function takes into account the sign of both arguments in order to determine the quadrant.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::ArcTan2(-10.0f, 5.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: -\/1.\+107149


\begin{DoxyParams}{Parameters}
{\em y} & Value representing the proportion of the y-\/coordinate. \\
\hline
{\em x} & Value representing the proportion of the x-\/coordinate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Arc Tangent of y/x, in radians. If y = 0 or x = 0, -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+TanH@{Arc\+TanH}}
\index{Arc\+TanH@{Arc\+TanH}!Ace@{Ace}}
\subsubsection[{Arc\+Tan\+H(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Arc\+TanH (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab95c327492c783547e8c16c4dd9570d8}


Calculates the Arc\+TanH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/3/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
\textcolor{keywordtype}{double} result = Ace::ArcTanH(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 1.\+059306


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+TanH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+TanH of num\+In\+Radians. If a mathematical error occurs or if num\+In\+Radians is less than or equal to -\/1 or if num\+In\+Radians is greater than or equal to 1, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Arc\+TanH@{Arc\+TanH}}
\index{Arc\+TanH@{Arc\+TanH}!Ace@{Ace}}
\subsubsection[{Arc\+Tan\+H(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Arc\+TanH (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a3c43f19a4371770bbeacd76e8d8f5e24}


Calculates the Arc\+TanH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
\textcolor{keywordtype}{float} result = Ace::ArcTanH(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 1.\+059306


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate Arc\+TanH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Arc\+TanH of num\+In\+Radians. If a mathematical error occurs or if num\+In\+Radians is less than or equal to -\/1 or if num\+In\+Radians is greater than or equal to 1, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Calculate\+File\+Size@{Calculate\+File\+Size}}
\index{Calculate\+File\+Size@{Calculate\+File\+Size}!Ace@{Ace}}
\subsubsection[{Calculate\+File\+Size(char $\ast$the\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}L\+O\+N\+G\+L\+O\+NG Ace\+::\+Calculate\+File\+Size (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{the\+File\+Path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a24687acdeab8af43507fea6467f29247}


Uses fseek() to calculate the size of the file by moving the file pointer to the end. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} fileSize = Ace::CalculateFileSize(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Dicks.txt"});
cout << fileSize << endl;
\end{DoxyCode}
 Output\+:37


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em the\+File} & A pointer to the File.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Size of the file in bytes. 
\end{DoxyReturn}
\index{Ace@{Ace}!Calculate\+File\+Size@{Calculate\+File\+Size}}
\index{Calculate\+File\+Size@{Calculate\+File\+Size}!Ace@{Ace}}
\subsubsection[{Calculate\+File\+Size(wchar\+\_\+t $\ast$the\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}L\+O\+N\+G\+L\+O\+NG Ace\+::\+Calculate\+File\+Size (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{the\+File\+Path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_adb5ff5f5dff024aa0d089bb2a018f8a7}


Gets the size of the file in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} fileSize = Ace::CalculateFileSize(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Dicks.txt"});
cout << fileSize << endl;
\end{DoxyCode}
 Output\+:37


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em the\+File\+Path} & The full file path.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Size of the file in bytes. 
\end{DoxyReturn}
\index{Ace@{Ace}!Ceiling@{Ceiling}}
\index{Ceiling@{Ceiling}!Ace@{Ace}}
\subsubsection[{Ceiling(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Ceiling (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab8cc0635c5777ced01f1cd35948bafa2}


Calculates the smallest integer value greater than or equal to num. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} retVal = Ace::Ceiling(1.01);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 2.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & The number to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The smallest integral value not less than num. 
\end{DoxyReturn}
\index{Ace@{Ace}!Ceiling@{Ceiling}}
\index{Ceiling@{Ceiling}!Ace@{Ace}}
\subsubsection[{Ceiling(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Ceiling (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a00736bf27104bf30fa2f3c4a463657ab}


Calculates the smallest integer value greater than or equal to num. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} retVal = Ace::Ceiling(1.01f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 2.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & The number to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The smallest integral value not less than num. 
\end{DoxyReturn}
\index{Ace@{Ace}!Char\+At@{Char\+At}}
\index{Char\+At@{Char\+At}!Ace@{Ace}}
\subsubsection[{Char\+At(char $\ast$str, int index)}]{\setlength{\rightskip}{0pt plus 5cm}char Ace\+::\+Char\+At (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str, }
\item[{int}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a63f81ff2236e723a0d84bd60dae9bb05}


Returns a single character in str at a specified index. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{char} temp = Ace::CharAt(data, 11);
printf(\textcolor{stringliteral}{"%c"}, temp);
\end{DoxyCode}
 Output\+:e


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to search. \\
\hline
 & {\em index} & The (0 based) index of what character to get.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A single character from str. 
\end{DoxyReturn}
\index{Ace@{Ace}!Char\+At@{Char\+At}}
\index{Char\+At@{Char\+At}!Ace@{Ace}}
\subsubsection[{Char\+At(wchar\+\_\+t $\ast$str, int index)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t Ace\+::\+Char\+At (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str, }
\item[{int}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a10123c2253ad11233dfe03584aa279c5}


Returns a single character in str at a specified index. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{wchar\_t} temp = Ace::CharAt(data, 11);
printf(\textcolor{stringliteral}{"%c"}, temp);
\end{DoxyCode}
 Output\+:e


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to search. \\
\hline
 & {\em index} & The (0 based) index of what character to get.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A single character from str. 
\end{DoxyReturn}
\index{Ace@{Ace}!Complementary\+Error\+Function@{Complementary\+Error\+Function}}
\index{Complementary\+Error\+Function@{Complementary\+Error\+Function}!Ace@{Ace}}
\subsubsection[{Complementary\+Error\+Function(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Complementary\+Error\+Function (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6905860b7a53563ab3c73b89e25160da}


Calculates the Complementary Error Function integral from num to infinity in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::ComplementaryErrorFunction(1.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 0.\+157299


\begin{DoxyParams}{Parameters}
{\em num} & The starting point for the integral.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of the Complementary Error Function integral. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Complementary\+Error\+Function@{Complementary\+Error\+Function}}
\index{Complementary\+Error\+Function@{Complementary\+Error\+Function}!Ace@{Ace}}
\subsubsection[{Complementary\+Error\+Function(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Complementary\+Error\+Function (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a611ec18e97b274af873f785a557808e7}


Calculates the Complementary Error Function integral from num to infinity in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::ComplementaryErrorFunction(1.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 0.\+157299


\begin{DoxyParams}{Parameters}
{\em num} & The starting point for the integral.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of the Complementary Error Function integral. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Concatenate@{Concatenate}}
\index{Concatenate@{Concatenate}!Ace@{Ace}}
\subsubsection[{Concatenate(int num\+Strings,...)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Concatenate (
\begin{DoxyParamCaption}
\item[{int}]{num\+Strings, }
\item[{}]{...}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a54627c41eea2730839d98f33542a5492}


Appends a series of strings together. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* completeStr = Ace::Concatenate(3, \textcolor{stringliteral}{"Everything"}, \textcolor{stringliteral}{"Everything"}, \textcolor{stringliteral}{"Everything"});
printf(\textcolor{stringliteral}{"%s"}, completeStr);
\_aligned\_free(completeStr);
\end{DoxyCode}
 Output\+:Everything\+Everything\+Everything.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num\+Strings} & Number of strings to append. \\
\hline
\mbox{\tt in}  & {\em ...} & Variable arguments providing additional strings.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A combined string of all the strings in the arguments. 
\end{DoxyReturn}
\index{Ace@{Ace}!Concatenate\+Strings@{Concatenate\+Strings}}
\index{Concatenate\+Strings@{Concatenate\+Strings}!Ace@{Ace}}
\subsubsection[{Concatenate\+Strings(int num\+Strings, char $\ast$$\ast$string\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Concatenate\+Strings (
\begin{DoxyParamCaption}
\item[{int}]{num\+Strings, }
\item[{char $\ast$$\ast$}]{string\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a940cef052ddd6f308129a20fa2489d03}


Appends an array of strings together and returns the combined string. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}** stringArray = (\textcolor{keywordtype}{char}**)\_aligned\_malloc(4 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}*), 16);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
\{
    stringArray[currIndex] = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"Everything"});
\}
\textcolor{keywordtype}{char}* completeStr = Ace::ConcatenateStrings(4, stringArray);
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, completeStr);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
\{
    \_aligned\_free(stringArray[currIndex]);
\}
\_aligned\_free(stringArray);
\_aligned\_free(completeStr);
\end{DoxyCode}
 Output\+:Everything\+Everything\+Everything\+Everything


\begin{DoxyParams}[1]{Parameters}
 & {\em num\+Strings} & Number of strings to append. \\
\hline
\mbox{\tt in}  & {\em string\+Array} & The array of strings to append.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A combined string of all the strings in the array. 
\end{DoxyReturn}
\index{Ace@{Ace}!Concatenate\+Strings@{Concatenate\+Strings}}
\index{Concatenate\+Strings@{Concatenate\+Strings}!Ace@{Ace}}
\subsubsection[{Concatenate\+Strings(int num\+Strings, wchar\+\_\+t $\ast$$\ast$string\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Concatenate\+Strings (
\begin{DoxyParamCaption}
\item[{int}]{num\+Strings, }
\item[{wchar\+\_\+t $\ast$$\ast$}]{string\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4d5ee021b1049844d690a884aa3beb31}


Appends an array of strings together and returns the combined string. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
  \textcolor{keywordtype}{wchar\_t}** stringArray = (\textcolor{keywordtype}{wchar\_t}**)\_aligned\_malloc(4 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t}*), 16);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
\{
  stringArray[currIndex] = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"Everything"});
\}
\textcolor{keywordtype}{wchar\_t}* completeStr = Ace::ConcatenateStrings(4, stringArray);
printf(\textcolor{stringliteral}{"%S"}, completeStr);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
\{
  \_aligned\_free(stringArray[currIndex]);
\}
\_aligned\_free(stringArray);
\_aligned\_free(completeStr);
\end{DoxyCode}
 Output\+:Everything\+Everything\+Everything\+Everything


\begin{DoxyParams}[1]{Parameters}
 & {\em num\+Strings} & Number of strings to append. \\
\hline
\mbox{\tt in}  & {\em string\+Array} & The array of strings to append.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A combined string of all the strings in the array. 
\end{DoxyReturn}
\index{Ace@{Ace}!Concatenate\+Strings@{Concatenate\+Strings}}
\index{Concatenate\+Strings@{Concatenate\+Strings}!Ace@{Ace}}
\subsubsection[{Concatenate\+Strings(vector$<$ char $\ast$ $>$ string\+Vector\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Concatenate\+Strings (
\begin{DoxyParamCaption}
\item[{vector$<$ char $\ast$ $>$}]{string\+Vector\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8699d2d8921db243252650adde40c999}


Appends a vector array of strings together and returns the combined string. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/6/2016
\end{DoxyDate}

\begin{DoxyCode}
vector<char*> stringVectorArray;
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 1; currIndex <= 4; currIndex++)
\{
    stringVectorArray.push\_back(\textcolor{stringliteral}{"Everything"});
\}
\textcolor{keywordtype}{char}* completeStr = Ace::ConcatenateStrings(stringVectorArray);
printf(\textcolor{stringliteral}{"%s"}, completeStr);
\_aligned\_free(completeStr);
\end{DoxyCode}
 Output\+:Everything\+Everything\+Everything\+Everything.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em string\+Vector\+Array} & The vector array of strings to append.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A combined string of all the strings in the array. 
\end{DoxyReturn}
\index{Ace@{Ace}!Concatenate\+Strings@{Concatenate\+Strings}}
\index{Concatenate\+Strings@{Concatenate\+Strings}!Ace@{Ace}}
\subsubsection[{Concatenate\+Strings(vector$<$ wchar\+\_\+t $\ast$ $>$ string\+Vector\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Concatenate\+Strings (
\begin{DoxyParamCaption}
\item[{vector$<$ wchar\+\_\+t $\ast$ $>$}]{string\+Vector\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a061739b0be1e26fcf5fc84d09fa9bd5d}


Appends a vector array of wide strings together and returns the combined wide string. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/4/2016
\end{DoxyDate}

\begin{DoxyCode}
vector<wchar\_t*> stringVectorArray;
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 1; currIndex <= 4; currIndex++)
\{
    stringVectorArray.push\_back(L\textcolor{stringliteral}{"Everything"});
\}
\textcolor{keywordtype}{wchar\_t}* completeStr = Ace::ConcatenateStrings(stringVectorArray);
printf(\textcolor{stringliteral}{"%S"}, completeStr);
\_aligned\_free(completeStr);
\end{DoxyCode}
 Output\+:Everything\+Everything\+Everything\+Everything.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em string\+Vector\+Array} & The vector array of strings to append.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A combined string of all the strings in the array. 
\end{DoxyReturn}
\index{Ace@{Ace}!ConcatenateW@{ConcatenateW}}
\index{ConcatenateW@{ConcatenateW}!Ace@{Ace}}
\subsubsection[{Concatenate\+W(int num\+Wide\+Strings,...)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+ConcatenateW (
\begin{DoxyParamCaption}
\item[{int}]{num\+Wide\+Strings, }
\item[{}]{...}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af0cd7dce3668bd1ee3e9f86b687caa5c}


Appends a series of strings together. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* completeStr = Ace::ConcatenateW(3, L\textcolor{stringliteral}{"Everything"}, L\textcolor{stringliteral}{"Everything"}, L\textcolor{stringliteral}{"Everything"});
printf(\textcolor{stringliteral}{"%S"}, completeStr);
\_aligned\_free(completeStr);
\end{DoxyCode}
 Output\+:Everything\+Everything\+Everything.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num\+Strings} & Number of strings to append. \\
\hline
\mbox{\tt in}  & {\em ...} & Variable arguments providing additional strings.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A combined string of all the strings in the arguments. 
\end{DoxyReturn}
\index{Ace@{Ace}!Contains@{Contains}}
\index{Contains@{Contains}!Ace@{Ace}}
\subsubsection[{Contains(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Contains (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af8c652e46bc6729b5619d794101540a2}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns true if found. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/26/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{bool} result = Ace::Contains(\textcolor{stringliteral}{"My name is Eddie and I like cheese."}, \textcolor{stringliteral}{"Eddie"});
\textcolor{keywordflow}{if} (result == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Contains the word."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Does not contain the word."});
\}
\end{DoxyCode}
 Output\+:Contains the word.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str\+To\+Search contains str\+To\+Look\+For, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Contains@{Contains}}
\index{Contains@{Contains}!Ace@{Ace}}
\subsubsection[{Contains(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Contains (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac0c4f1f93bb980eaf627a1dde757765d}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns true if found. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{bool} result = Ace::Contains(L\textcolor{stringliteral}{"My name is Eddie and I like cheese."}, L\textcolor{stringliteral}{"Eddie"});
\textcolor{keywordflow}{if} (result == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Contains the word."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Does not contain the word."});
\}
\end{DoxyCode}
 Output\+:Contains the word.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & Wide String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & Wide String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str\+To\+Search contains str\+To\+Look\+For, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Contains\+Ignore\+Case@{Contains\+Ignore\+Case}}
\index{Contains\+Ignore\+Case@{Contains\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Contains\+Ignore\+Case(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Contains\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa1a0f98f4f52323b776c8da11d4af7f7}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns true if found. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/26/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{bool} result = Ace::ContainsIgnoreCase(\textcolor{stringliteral}{"My name is eddIe and I like cheese."}, \textcolor{stringliteral}{"EdDIe"});
\textcolor{keywordflow}{if} (result == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Contains the word."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Does not contain the word."});
\}
\end{DoxyCode}
 Output\+:Contains the word.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str\+To\+Search contains str\+To\+Look\+For, $>$false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Contains\+Ignore\+Case@{Contains\+Ignore\+Case}}
\index{Contains\+Ignore\+Case@{Contains\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Contains\+Ignore\+Case(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Contains\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a89a15437662eae89503cefc25e29a9f7}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns true if found. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{bool} result = Ace::ContainsIgnoreCase(L\textcolor{stringliteral}{"My name is eddIe and I like cheese."}, L\textcolor{stringliteral}{"EdDIe"});
\textcolor{keywordflow}{if} (result == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Contains the word."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Does not contain the word."});
\}
\end{DoxyCode}
 Output\+:Contains the word.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & Wide String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & Wide String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str\+To\+Search contains str\+To\+Look\+For, $>$false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+Int\+To\+Bool@{Convert\+Int\+To\+Bool}}
\index{Convert\+Int\+To\+Bool@{Convert\+Int\+To\+Bool}!Ace@{Ace}}
\subsubsection[{Convert\+Int\+To\+Bool(int num)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Convert\+Int\+To\+Bool (
\begin{DoxyParamCaption}
\item[{int}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aedf62dbbbeffecb146060a08a0fe07f7}


By definition, false is equal to 0 and true is equal to anything but 0. 

In other words, any positive or negative number returns true, if num is 0 then false.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{bool} data = Ace::ConvertIntToBool(0);
\textcolor{keywordflow}{if} (data == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:false


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num} & The number to determine if true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true or false based on the value of num. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+Array\+To\+String\+Vector\+Array@{Convert\+String\+Array\+To\+String\+Vector\+Array}}
\index{Convert\+String\+Array\+To\+String\+Vector\+Array@{Convert\+String\+Array\+To\+String\+Vector\+Array}!Ace@{Ace}}
\subsubsection[{Convert\+String\+Array\+To\+String\+Vector\+Array(char $\ast$$\ast$string\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ char $\ast$ $>$ Ace\+::\+Convert\+String\+Array\+To\+String\+Vector\+Array (
\begin{DoxyParamCaption}
\item[{char $\ast$$\ast$}]{string\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ace7ef8961e95078c69f2058025960c09}


Converts a traditional string array to a vector string array. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}** strArray = (\textcolor{keywordtype}{char}**)\_aligned\_malloc(4 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}*), 16);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
\{
    strArray[currIndex] = (\textcolor{keywordtype}{char}*)\_aligned\_malloc(32 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}), 16);
    memset(strArray[currIndex], 0, 32 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}));
    \_itoa\_s(currIndex, strArray[currIndex], 32, 10);
\}
vector<char*> stringVectorArray = Ace::ConvertStringArrayToStringVectorArray(strArray);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
\{
    printf(\textcolor{stringliteral}{"strVectorArray[%d]:%s\(\backslash\)n"}, currIndex, stringVectorArray[currIndex]);
    \_aligned\_free(strArray[currIndex]);
\}
\_aligned\_free(strArray);
\end{DoxyCode}
 Output\+:str\+Vector\+Array[0]\+:0 str\+Vector\+Array[1]\+:1 str\+Vector\+Array[2]\+:2 str\+Vector\+Array[3]\+:3


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em string\+Array} & The string array to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A string vector array. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+Array\+To\+String\+Vector\+Array@{Convert\+String\+Array\+To\+String\+Vector\+Array}}
\index{Convert\+String\+Array\+To\+String\+Vector\+Array@{Convert\+String\+Array\+To\+String\+Vector\+Array}!Ace@{Ace}}
\subsubsection[{Convert\+String\+Array\+To\+String\+Vector\+Array(wchar\+\_\+t $\ast$$\ast$string\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ wchar\+\_\+t $\ast$ $>$ Ace\+::\+Convert\+String\+Array\+To\+String\+Vector\+Array (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$$\ast$}]{string\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_afdfed76bad657496dd0b9d18e887048b}


Converts a traditional wide string array to a vector wide string array. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/5/2016
\end{DoxyDate}

\begin{DoxyCode}
  \textcolor{keywordtype}{wchar\_t}** strArray = (\textcolor{keywordtype}{wchar\_t}**)\_aligned\_malloc(4 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t}*), 16);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
\{
  strArray[currIndex] = (\textcolor{keywordtype}{wchar\_t}*)\_aligned\_malloc(32 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t}), 16);
  memset(strArray[currIndex], 0, 32 * \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{wchar\_t}));
  \_itow\_s(currIndex, strArray[currIndex], 32, 10);
\}
vector<wchar\_t*> stringVectorArray = Ace::ConvertStringArrayToStringVectorArray(strArray);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < 4; currIndex++)
\{
  printf(\textcolor{stringliteral}{"strVectorArray[%d]:%S\(\backslash\)n"}, currIndex, stringVectorArray[currIndex]);
  \_aligned\_free(strArray[currIndex]);
\}
\_aligned\_free(strArray);
\end{DoxyCode}
 Output\+:str\+Vector\+Array[0]\+:0 str\+Vector\+Array[1]\+:1 str\+Vector\+Array[2]\+:2 str\+Vector\+Array[3]\+:3


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em string\+Array} & The wide string array to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A wide string vector array. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+Bool@{Convert\+String\+To\+Bool}}
\index{Convert\+String\+To\+Bool@{Convert\+String\+To\+Bool}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+Bool(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Convert\+String\+To\+Bool (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9399ba5c75c6aa92dac1a8d1d9f4af61}


Converts a given string to a bool, If str is a string like \char`\"{}\+False\char`\"{}, \char`\"{}\+F\+A\+L\+S\+E\char`\"{}, or \char`\"{}t\+Ru\+E\char`\"{}, then the function will return false, false, true respectively. 

If str is an integer for example; \char`\"{}0\char`\"{} will return false and any other number will return true.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{bool} data = Ace::ConvertStringToBool(\textcolor{stringliteral}{"tRuE"});
\textcolor{keywordflow}{if} (data == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str is equal to \char`\"{}true\char`\"{} (any case combination) or if str is an integer not equal to 0; false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+Bool@{Convert\+String\+To\+Bool}}
\index{Convert\+String\+To\+Bool@{Convert\+String\+To\+Bool}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+Bool(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Convert\+String\+To\+Bool (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7b8a182a0d284265930026487405653a}


Converts a given wide string to a bool, If str is a wide string like \char`\"{}\+False\char`\"{}, \char`\"{}\+F\+A\+L\+S\+E\char`\"{}, or \char`\"{}t\+Ru\+E\char`\"{}, then the function will return false, false, true respectively. 

If str is an integer for example; \char`\"{}0\char`\"{} will return false and any other number will return true.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{bool} data = Ace::ConvertStringToBool(L\textcolor{stringliteral}{"tRuE"});
\textcolor{keywordflow}{if} (data == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & Wide String to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if str is equal to \char`\"{}true\char`\"{} (any case combination) or if str is an integer not equal to 0; false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+Float\+Array@{Convert\+String\+To\+Float\+Array}}
\index{Convert\+String\+To\+Float\+Array@{Convert\+String\+To\+Float\+Array}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+Float\+Array(char $\ast$str\+To\+Convert, char $\ast$delimiter, int \&out\+Num\+Items)}]{\setlength{\rightskip}{0pt plus 5cm}float $\ast$ Ace\+::\+Convert\+String\+To\+Float\+Array (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Convert, }
\item[{char $\ast$}]{delimiter, }
\item[{int \&}]{out\+Num\+Items}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2dd19dedc9fa4b83a8db2115fc3b65bb}


Converts a tokenized string (a string with commas separating numbers for example) to an array of floats. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/26/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} numItems = 0;
\textcolor{keywordtype}{char}* strPosition = \textcolor{stringliteral}{"0.0, 1.0f, 2.0"};
\textcolor{keywordtype}{float}* floatArray = Ace::ConvertStringToFloatArray(strPosition, \textcolor{stringliteral}{","}, numItems);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < numItems; currIndex++)
\{
    printf(\textcolor{stringliteral}{"floatArray[%d]: %f\(\backslash\)n"}, currIndex, floatArray[currIndex]);
\}
\_aligned\_free(floatArray);
\end{DoxyCode}
 Output\+:float\+Array[0]\+: 0.\+000000 float\+Array[1]\+: 1.\+000000 float\+Array[2]\+: 2.\+000000


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Convert} & String to convert. \\
\hline
\mbox{\tt in}  & {\em delimiter} & String that separates each number. \\
\hline
\mbox{\tt out}  & {\em out\+Num\+Items} & Size of the array.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly allocated array of floats. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+Float\+Array@{Convert\+String\+To\+Float\+Array}}
\index{Convert\+String\+To\+Float\+Array@{Convert\+String\+To\+Float\+Array}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+Float\+Array(wchar\+\_\+t $\ast$str\+To\+Convert, wchar\+\_\+t $\ast$delimiter, int \&out\+Num\+Items)}]{\setlength{\rightskip}{0pt plus 5cm}float $\ast$ Ace\+::\+Convert\+String\+To\+Float\+Array (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Convert, }
\item[{wchar\+\_\+t $\ast$}]{delimiter, }
\item[{int \&}]{out\+Num\+Items}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a561b5633460e1f395b6e6fd12ab455f5}


Converts a tokenized wide string (a string with commas separating numbers for example) to an array of floats. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} numItems = 0;
\textcolor{keywordtype}{wchar\_t}* strPosition = L\textcolor{stringliteral}{"0.0, 1.0f, 2.0"};
\textcolor{keywordtype}{float}* floatArray = Ace::ConvertStringToFloatArray(strPosition, L\textcolor{stringliteral}{","}, numItems);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < numItems; currIndex++)
\{
    printf(\textcolor{stringliteral}{"floatArray[%d]: %f\(\backslash\)n"}, currIndex, floatArray[currIndex]);
\}
\_aligned\_free(floatArray);
\end{DoxyCode}
 Output\+:float\+Array[0]\+: 0.\+000000 float\+Array[1]\+: 1.\+000000 float\+Array[2]\+: 2.\+000000


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Convert} & String to convert. \\
\hline
\mbox{\tt in}  & {\em delimiter} & String that separates each number. \\
\hline
\mbox{\tt out}  & {\em out\+Num\+Items} & Size of the array.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly allocated array of floats. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+Hex@{Convert\+String\+To\+Hex}}
\index{Convert\+String\+To\+Hex@{Convert\+String\+To\+Hex}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+Hex(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int Ace\+::\+Convert\+String\+To\+Hex (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9735962c53182de52caffda3b7dd091f}


Converts a string to its hex value. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} data = Ace::ConvertStringToHex(\textcolor{stringliteral}{"0xDEADBEEF"});
printf(\textcolor{stringliteral}{"Hex Value: %x\(\backslash\)n"}, data);
printf(\textcolor{stringliteral}{"Integer Value: %u\(\backslash\)n"}, data);
\end{DoxyCode}
 Output\+:Hex Value\+: deadbeef Integer Value\+: 305419896.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to convert to hex.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The hex value of the string. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+Hex@{Convert\+String\+To\+Hex}}
\index{Convert\+String\+To\+Hex@{Convert\+String\+To\+Hex}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+Hex(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int Ace\+::\+Convert\+String\+To\+Hex (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa575665aa3bc6f2366fabd3bdec04e25}


Converts a string to its hex value. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} data = Ace::ConvertStringToHex(L\textcolor{stringliteral}{"0xDEADBEEF"});
printf(\textcolor{stringliteral}{"Hex Value: %x\(\backslash\)n"}, data);
printf(\textcolor{stringliteral}{"Integer Value: %u\(\backslash\)n"}, data);
\end{DoxyCode}
 Output\+:Hex Value\+: deadbeef Integer Value\+: 305419896.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to convert to hex.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The hex value of the string. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+One\+Line@{Convert\+String\+To\+One\+Line}}
\index{Convert\+String\+To\+One\+Line@{Convert\+String\+To\+One\+Line}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+One\+Line(char $\ast$str\+To\+Convert)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Convert\+String\+To\+One\+Line (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Convert}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a27a4d4bc0cfe1b489582bf937e27d0e1}


Converts a traditional string to a traditional string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/12/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Krusty\(\backslash\)nKrab\(\backslash\)nUn-Fair\(\backslash\)n!"};
\textcolor{keywordtype}{char}* oneLineData = Ace::ConvertStringToOneLine(data);
printf(\textcolor{stringliteral}{"%s"}, oneLineData);
\_aligned\_free(oneLineData);
\end{DoxyCode}
 Output\+:Krusty\+Krab\+Un-\/\+Fair!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Convert} & The string to convert to one line.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A string with every occurrence of ~\newline
 removed. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+One\+Line@{Convert\+String\+To\+One\+Line}}
\index{Convert\+String\+To\+One\+Line@{Convert\+String\+To\+One\+Line}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+One\+Line(wchar\+\_\+t $\ast$str\+To\+Convert)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Convert\+String\+To\+One\+Line (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Convert}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a41c562a99b2eae02bed5d5c76b5ab8d9}


Converts a traditional wide string to a traditional wide string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Krusty\(\backslash\)nKrab\(\backslash\)nUn-Fair\(\backslash\)n!"};
\textcolor{keywordtype}{wchar\_t}* oneLineData = Ace::ConvertStringToOneLine(data);
printf(\textcolor{stringliteral}{"%S"}, oneLineData);
\_aligned\_free(oneLineData);
\end{DoxyCode}
 Output\+:Krusty\+Krab\+Un-\/\+Fair!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Convert} & The wide string to convert to one line.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A wide string with every occurrence of ~\newline
 removed. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+To\+One\+Line\+In\+Place@{Convert\+String\+To\+One\+Line\+In\+Place}}
\index{Convert\+String\+To\+One\+Line\+In\+Place@{Convert\+String\+To\+One\+Line\+In\+Place}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+One\+Line\+In\+Place(char $\ast$str\+To\+Convert)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Convert\+String\+To\+One\+Line\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Convert}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4ad8d96d9b8bad51a4364ae67fce4b73}


Converts a traditional string to a traditional string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. 

str\+To\+Convert must be an allocated string since this function works directly on it.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/12/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* oneLineData = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"Krusty\(\backslash\)nKrab\(\backslash\)nUn-Fair\(\backslash\)n!"});
Ace::ConvertStringToOneLineInPlace(oneLineData);
printf(\textcolor{stringliteral}{"%s"}, oneLineData);
\_aligned\_free(oneLineData);
\end{DoxyCode}
 Output\+:Krusty\+Krab\+Un-\/\+Fair!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Convert} & The string to directly convert to one line. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Convert\+String\+To\+One\+Line\+In\+Place@{Convert\+String\+To\+One\+Line\+In\+Place}}
\index{Convert\+String\+To\+One\+Line\+In\+Place@{Convert\+String\+To\+One\+Line\+In\+Place}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+One\+Line\+In\+Place(wchar\+\_\+t $\ast$str\+To\+Convert)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Convert\+String\+To\+One\+Line\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Convert}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6ab37e5c15b1cc6595fb2865c7fc12b1}


Converts a traditional wide string to a traditional wide string that is all on one line, In other words; this function removes any occurrence of ~\newline
 from string\+To\+Convert. 

str\+To\+Convert must be an allocated wide string since this function works directly on it.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* oneLineData = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"Krusty\(\backslash\)nKrab\(\backslash\)nUn-Fair\(\backslash\)n!"});
Ace::ConvertStringToOneLineInPlace(oneLineData);
printf(\textcolor{stringliteral}{"%S"}, oneLineData);
\_aligned\_free(oneLineData);
\end{DoxyCode}
 Output\+:Krusty\+Krab\+Un-\/\+Fair!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Convert} & The wide string to directly convert to one line. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Convert\+String\+To\+W\+Char\+String@{Convert\+String\+To\+W\+Char\+String}}
\index{Convert\+String\+To\+W\+Char\+String@{Convert\+String\+To\+W\+Char\+String}!Ace@{Ace}}
\subsubsection[{Convert\+String\+To\+W\+Char\+String(const char $\ast$str\+To\+Convert)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Convert\+String\+To\+W\+Char\+String (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{str\+To\+Convert}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_adebec5fecf3c418346f7e7233cac91f7}


Converts a traditional string to a wide string. 

A wide string is a string containing Unicode characters (non English).

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/25/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* normalString = \textcolor{stringliteral}{"The ceiling is right Squidward."};
\textcolor{keywordtype}{wchar\_t}* wideString = Ace::ConvertStringToWCharString(normalString);
printf(\textcolor{stringliteral}{"Wide string: %S\(\backslash\)n"}, wideString);
\_aligned\_free(wideString);
\end{DoxyCode}
 Output\+:Wide string\+: The ceiling is right Squidward.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Convert} & The string to convert to a wide string.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
null if it fails, else the string converted to w character string. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+Vector\+Array\+To\+String\+Array@{Convert\+String\+Vector\+Array\+To\+String\+Array}}
\index{Convert\+String\+Vector\+Array\+To\+String\+Array@{Convert\+String\+Vector\+Array\+To\+String\+Array}!Ace@{Ace}}
\subsubsection[{Convert\+String\+Vector\+Array\+To\+String\+Array(vector$<$ char $\ast$ $>$ string\+Vector\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$$\ast$ Ace\+::\+Convert\+String\+Vector\+Array\+To\+String\+Array (
\begin{DoxyParamCaption}
\item[{vector$<$ char $\ast$ $>$}]{string\+Vector\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5b925726cd02b9a41f8648173b8a4cd5}


Converts a string vector array to a traditional string array. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
vector<char*> strVectorArray;
strVectorArray.push\_back(\textcolor{stringliteral}{"My"});
strVectorArray.push\_back(\textcolor{stringliteral}{"name"});
strVectorArray.push\_back(\textcolor{stringliteral}{"is"});
strVectorArray.push\_back(\textcolor{stringliteral}{"Eddie."});
\textcolor{keywordtype}{int} numStrs = strVectorArray.size();
\textcolor{keywordtype}{char}** strArray = Ace::ConvertStringVectorArrayToStringArray(strVectorArray);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < numStrs; currIndex++)
\{
    printf(\textcolor{stringliteral}{"Array[%d]:%s\(\backslash\)n"}, currIndex, strArray[currIndex]);
    \_aligned\_free(strArray[currIndex]);
\}
\_aligned\_free(strArray);
\end{DoxyCode}
 Output\+:Array[0]\+:My Array[1]\+:name Array[2]\+:is Array[3]\+:Eddie.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em string\+Vector\+Array} & The string vector array to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created traditional string array. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+String\+Vector\+Array\+To\+String\+Array@{Convert\+String\+Vector\+Array\+To\+String\+Array}}
\index{Convert\+String\+Vector\+Array\+To\+String\+Array@{Convert\+String\+Vector\+Array\+To\+String\+Array}!Ace@{Ace}}
\subsubsection[{Convert\+String\+Vector\+Array\+To\+String\+Array(vector$<$ wchar\+\_\+t $\ast$ $>$ string\+Vector\+Array)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$$\ast$ Ace\+::\+Convert\+String\+Vector\+Array\+To\+String\+Array (
\begin{DoxyParamCaption}
\item[{vector$<$ wchar\+\_\+t $\ast$ $>$}]{string\+Vector\+Array}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7188a081ac708dc23678f3c5d56decb8}


Converts a wide string vector array to a traditional wide string array. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/4/2016
\end{DoxyDate}

\begin{DoxyCode}
vector<wchar\_t*> strVectorArray;
strVectorArray.push\_back(L\textcolor{stringliteral}{"My"});
strVectorArray.push\_back(L\textcolor{stringliteral}{"name"});
strVectorArray.push\_back(L\textcolor{stringliteral}{"is"});
strVectorArray.push\_back(L\textcolor{stringliteral}{"Eddie."});
\textcolor{keywordtype}{int} numStrs = strVectorArray.size();
\textcolor{keywordtype}{wchar\_t}** strArray = Ace::ConvertStringVectorArrayToStringArray(strVectorArray);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < numStrs; currIndex++)
\{
    printf(\textcolor{stringliteral}{"Array[%d]:%S\(\backslash\)n"}, currIndex, strArray[currIndex]);
    \_aligned\_free(strArray[currIndex]);
\}
\_aligned\_free(strArray);
\end{DoxyCode}
 Output\+:Array[0]\+:My Array[1]\+:name Array[2]\+:is Array[3]\+:Eddie.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em string\+Vector\+Array} & The string vector array to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created traditional string array. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Lower\+Case@{Convert\+To\+Lower\+Case}}
\index{Convert\+To\+Lower\+Case@{Convert\+To\+Lower\+Case}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Lower\+Case(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Convert\+To\+Lower\+Case (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a28cad743308ecbc46147e0203e2b14f3}


Converts a string to all lowercase letters. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = Ace::ConvertToLowerCase(\textcolor{stringliteral}{"ABCDEF"});
printf(\textcolor{stringliteral}{"%s"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:abcdef


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to determine if true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true or false based on the value of str. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Lower\+Case@{Convert\+To\+Lower\+Case}}
\index{Convert\+To\+Lower\+Case@{Convert\+To\+Lower\+Case}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Lower\+Case(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Convert\+To\+Lower\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aebe68e4280058616f63de68936cee206}


Converts a wide string to all lowercase letters. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = Ace::ConvertToLowerCase(L\textcolor{stringliteral}{"ABCDEF"});
printf(\textcolor{stringliteral}{"%S"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:abcdef


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to determine if true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true or false based on the value of str. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Lower\+Case\+In\+Place@{Convert\+To\+Lower\+Case\+In\+Place}}
\index{Convert\+To\+Lower\+Case\+In\+Place@{Convert\+To\+Lower\+Case\+In\+Place}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Lower\+Case\+In\+Place(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Convert\+To\+Lower\+Case\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a040b39d22ec0282b5a4185aba3e37633}


Directly modifies str to have all its letters converted to lower case. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"ABCDEF"});
Ace::ConvertToLowerCaseInPlace(data);
printf(\textcolor{stringliteral}{"%s"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:abcdef


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str} & The string to determine if true or false. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Convert\+To\+Lower\+Case\+In\+Place@{Convert\+To\+Lower\+Case\+In\+Place}}
\index{Convert\+To\+Lower\+Case\+In\+Place@{Convert\+To\+Lower\+Case\+In\+Place}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Lower\+Case\+In\+Place(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Convert\+To\+Lower\+Case\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a756a560a676102e318b403f4cd12a750}


Directly modifies str to have all its letters converted to lower case. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"ABCDEF"});
Ace::ConvertToLowerCaseInPlace(data);
printf(\textcolor{stringliteral}{"%S"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:abcdef


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str} & The wide string to determine if true or false. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Convert\+To\+Upper\+Case@{Convert\+To\+Upper\+Case}}
\index{Convert\+To\+Upper\+Case@{Convert\+To\+Upper\+Case}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Upper\+Case(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Convert\+To\+Upper\+Case (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a06f1154d2ce1775f53931aaf94c93f99}


Converts a string to all uppercase letters. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = Ace::ConvertToUpperCase(\textcolor{stringliteral}{"abcdef"});
printf(\textcolor{stringliteral}{"%s"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:A\+B\+C\+D\+EF


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to determine if true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string containing all the letters in str in uppercase. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Upper\+Case@{Convert\+To\+Upper\+Case}}
\index{Convert\+To\+Upper\+Case@{Convert\+To\+Upper\+Case}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Upper\+Case(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Convert\+To\+Upper\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a1fc45db42de7183ab5ec93a90a3f8cc7}


Converts a string to all uppercase letters. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = Ace::ConvertToUpperCase(L\textcolor{stringliteral}{"abcdef"});
printf(\textcolor{stringliteral}{"%S"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:A\+B\+C\+D\+EF


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to determine if true or false.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string containing all the letters in str in uppercase. 
\end{DoxyReturn}
\index{Ace@{Ace}!Convert\+To\+Upper\+Case\+In\+Place@{Convert\+To\+Upper\+Case\+In\+Place}}
\index{Convert\+To\+Upper\+Case\+In\+Place@{Convert\+To\+Upper\+Case\+In\+Place}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Upper\+Case\+In\+Place(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Convert\+To\+Upper\+Case\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4ce18b5ec8b3acce9219938b2d07af0b}


Directly modifies str to have all its letters converted to upper case. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"abcdef"});
Ace::ConvertToUpperCaseInPlace(data);
printf(\textcolor{stringliteral}{"%s"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:A\+B\+C\+D\+EF


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to convert to all uppercase letters. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Convert\+To\+Upper\+Case\+In\+Place@{Convert\+To\+Upper\+Case\+In\+Place}}
\index{Convert\+To\+Upper\+Case\+In\+Place@{Convert\+To\+Upper\+Case\+In\+Place}!Ace@{Ace}}
\subsubsection[{Convert\+To\+Upper\+Case\+In\+Place(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Convert\+To\+Upper\+Case\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab11cca7bc0da989b9bf6bd1158601fdd}


Directly modifies str to have all its letters converted to upper case. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"abcdef"});
Ace::ConvertToUpperCaseInPlace(data);
printf(\textcolor{stringliteral}{"%S"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:A\+B\+C\+D\+EF


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to convert to all uppercase letters. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Cos@{Cos}}
\index{Cos@{Cos}!Ace@{Ace}}
\subsubsection[{Cos(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Cos (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a59f079afef33f0a7bed749afbf777c36}


Calculates the Cosine (cos) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265358979;
\textcolor{keywordtype}{double} retVal = Ace::Cos(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+:0.\+707107


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & The number in radians to take the cosine of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The cosine of the num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Cos@{Cos}}
\index{Cos@{Cos}!Ace@{Ace}}
\subsubsection[{Cos(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Cos (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a55bebe92cca4c2a94f2cb30431475dea}


Calculates the Cosine (cos) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265358979f;
\textcolor{keywordtype}{float} retVal = Ace::Cos(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+:0.\+707107


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & The number in radians to take the cosine of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The cosine of the num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!CosH@{CosH}}
\index{CosH@{CosH}!Ace@{Ace}}
\subsubsection[{Cos\+H(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+CosH (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2a3e08791d5a9e794a02c118daca3402}


Calculates the CosH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
\textcolor{keywordtype}{double} result = Ace::CosH(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 1.\+324609


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate CosH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The CosH of num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!CosH@{CosH}}
\index{CosH@{CosH}!Ace@{Ace}}
\subsubsection[{Cos\+H(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+CosH (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a428056578b18e534a419d4fde48c1fef}


Calculates the CosH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
\textcolor{keywordtype}{float} result = Ace::CosH(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 1.\+324609


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate CosH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The CosH of num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Count\+Num\+Occurrences@{Count\+Num\+Occurrences}}
\index{Count\+Num\+Occurrences@{Count\+Num\+Occurrences}!Ace@{Ace}}
\subsubsection[{Count\+Num\+Occurrences(char $\ast$str\+To\+Search, char char\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Count\+Num\+Occurrences (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char}]{char\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4202759241426cfbbc2c15b5ea218ec8}


Counts the number of times char\+To\+Look\+For appears in str\+To\+Search. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/11/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{int} numOccurences = Ace::CountNumOccurrences(data, \textcolor{charliteral}{'e'});
printf(\textcolor{stringliteral}{"Number of occurrences of %c: %d\(\backslash\)n"}, \textcolor{charliteral}{'e'}, numOccurences);
\end{DoxyCode}
 Output\+:Number of occurrences of e\+: 13


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & A string containing the data to be searched. \\
\hline
\mbox{\tt in}  & {\em char\+To\+Look\+For} & A string character to look for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of times char\+To\+Look\+For occurred in str\+To\+Search. 
\end{DoxyReturn}
\index{Ace@{Ace}!Count\+Num\+Occurrences@{Count\+Num\+Occurrences}}
\index{Count\+Num\+Occurrences@{Count\+Num\+Occurrences}!Ace@{Ace}}
\subsubsection[{Count\+Num\+Occurrences(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t char\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Count\+Num\+Occurrences (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t}]{char\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad46096b28cff4e653243e0a0a3656f59}


Counts the number of times char\+To\+Look\+For appears in str\+To\+Search. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{int} numOccurences = Ace::CountNumOccurrences(data, L\textcolor{charliteral}{'e'});
printf(\textcolor{stringliteral}{"Number of occurrences of %c: %d\(\backslash\)n"}, L\textcolor{charliteral}{'e'}, numOccurences);
\end{DoxyCode}
 Output\+:Number of occurrences of e\+: 13


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & A wide string containing the data to be searched. \\
\hline
\mbox{\tt in}  & {\em char\+To\+Look\+For} & A wide character to look for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of times char\+To\+Look\+For occurred in str\+To\+Search. 
\end{DoxyReturn}
\index{Ace@{Ace}!Count\+Num\+Occurrences@{Count\+Num\+Occurrences}}
\index{Count\+Num\+Occurrences@{Count\+Num\+Occurrences}!Ace@{Ace}}
\subsubsection[{Count\+Num\+Occurrences(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Count\+Num\+Occurrences (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad9d6a9afe8007466f657522d9492dc89}


Counts the number of times str\+To\+Look\+For appears in str\+To\+Search. 

Assumes item\+To\+Look\+For is always smaller than word.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{int} numOccurences = Ace::CountNumOccurrences(data, \textcolor{stringliteral}{"as"});
printf(\textcolor{stringliteral}{"Number of occurrences of %s: %d"}, \textcolor{stringliteral}{"as"}, numOccurences);
\end{DoxyCode}
 Output\+:Number of occurrences of as\+: 3


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & A string containing the data to be searched. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & A string representing the substring to look for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of times str\+To\+Look\+For occurred in str\+To\+Search. 
\end{DoxyReturn}
\index{Ace@{Ace}!Count\+Num\+Occurrences@{Count\+Num\+Occurrences}}
\index{Count\+Num\+Occurrences@{Count\+Num\+Occurrences}!Ace@{Ace}}
\subsubsection[{Count\+Num\+Occurrences(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Count\+Num\+Occurrences (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aafbcb7320a4d903a15ef1039c78bd131}


Counts the number of times str\+To\+Look\+For appears in str\+To\+Search. 

Assumes item\+To\+Look\+For is always smaller than word.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{int} numOccurences = Ace::CountNumOccurrences(data, L\textcolor{stringliteral}{"as"});
printf(\textcolor{stringliteral}{"Number of occurrences of %S: %d"}, L\textcolor{stringliteral}{"as"}, numOccurences);
\end{DoxyCode}
 Output\+:Number of occurrences of as\+: 3


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & A wide string containing the data to be searched. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & A wide string representing the substring to look for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of times str\+To\+Look\+For occurred in str\+To\+Search. 
\end{DoxyReturn}
\index{Ace@{Ace}!Cube\+Root@{Cube\+Root}}
\index{Cube\+Root@{Cube\+Root}!Ace@{Ace}}
\subsubsection[{Cube\+Root(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Cube\+Root (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abf907ab5be1efd6f81532d2cb9f2a809}


Calculates the Cube Root in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} retVal = Ace::CubeRoot(1728.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 12.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & The number to take the Cube Root of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Cube Root of num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Cube\+Root@{Cube\+Root}}
\index{Cube\+Root@{Cube\+Root}!Ace@{Ace}}
\subsubsection[{Cube\+Root(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Cube\+Root (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aace71b982b1bdb3ed617b32e01335140}


Calculates the Cube Root in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} retVal = Ace::CubeRoot(1728.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 12.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & The number to take the Cube Root of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Cube Root of num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Degrees\+To\+Radians@{Degrees\+To\+Radians}}
\index{Degrees\+To\+Radians@{Degrees\+To\+Radians}!Ace@{Ace}}
\subsubsection[{Degrees\+To\+Radians(double degrees)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Degrees\+To\+Radians (
\begin{DoxyParamCaption}
\item[{double}]{degrees}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad4386a90f9491cc97945787e15e7554c}


Converts a number from degrees to radians. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/16/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} deg = 90.0;
\textcolor{keywordtype}{double} rad = Ace::DegreesToRadians(deg);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, rad);
\end{DoxyCode}
 Output\+:1.\+570796


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em degrees} & Degrees to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Radians. 
\end{DoxyReturn}
\index{Ace@{Ace}!Degrees\+To\+Radians@{Degrees\+To\+Radians}}
\index{Degrees\+To\+Radians@{Degrees\+To\+Radians}!Ace@{Ace}}
\subsubsection[{Degrees\+To\+Radians(float degrees)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Degrees\+To\+Radians (
\begin{DoxyParamCaption}
\item[{float}]{degrees}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a30d2e65624fcc7f6143bf16955f9fabd}


Converts a number from degrees to radians. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} deg = 90.0f;
\textcolor{keywordtype}{float} rad = Ace::DegreesToRadians(deg);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, rad);
\end{DoxyCode}
 Output\+:1.\+570796


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em degrees} & Degrees to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Radians. 
\end{DoxyReturn}
\index{Ace@{Ace}!Does\+File\+Exist@{Does\+File\+Exist}}
\index{Does\+File\+Exist@{Does\+File\+Exist}!Ace@{Ace}}
\subsubsection[{Does\+File\+Exist(char $\ast$full\+File\+Path\+With\+Name\+And\+Ext)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Does\+File\+Exist (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{full\+File\+Path\+With\+Name\+And\+Ext}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a63153a0d492cb0cbe3a4cd69fee74684}


Returns true if the specified file exists, false otherwise. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::DoesFileExist(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Images\(\backslash\)\(\backslash\)dickbutt.png"}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"File exists."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"File does NOT exist."});
\}
\end{DoxyCode}
 Output\+:File does N\+OT exist.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em full\+File\+Path\+With\+Name\+And\+Ext} & File to check.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if the specified file exists, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Does\+File\+Exist@{Does\+File\+Exist}}
\index{Does\+File\+Exist@{Does\+File\+Exist}!Ace@{Ace}}
\subsubsection[{Does\+File\+Exist(wchar\+\_\+t $\ast$full\+File\+Path\+With\+Name\+And\+Ext)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Does\+File\+Exist (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{full\+File\+Path\+With\+Name\+And\+Ext}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8391ff72632a4406b4cf1b8936bd908d}


Returns true if the specified file exists, false otherwise. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::DoesFileExist(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Images\(\backslash\)\(\backslash\)dickbutt.png"}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"File exists."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"File does NOT exist."});
\}
\end{DoxyCode}
 Output\+:File does N\+OT exist.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em full\+File\+Path\+With\+Name\+And\+Ext} & File to check.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if the specified file exists, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Equals@{Equals}}
\index{Equals@{Equals}!Ace@{Ace}}
\subsubsection[{Equals(char $\ast$str\+To\+Comp\+One, char $\ast$str\+To\+Comp\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Equals (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Comp\+One, }
\item[{char $\ast$}]{str\+To\+Comp\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a986a84d68783456d3c97b467cece5635}


Compares two traditional strings together. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/16/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* strOne = \textcolor{stringliteral}{"Eddie"};
\textcolor{keywordtype}{char}* strTwo = \textcolor{stringliteral}{"Katianie"};
\textcolor{keywordflow}{if} (Ace::Equals(strOne, strTwo) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Strings are equal."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Strings are NOT equal."});
\}
\end{DoxyCode}
 Output\+:Strings are N\+OT equal.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Comp\+One} & First string to compare. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Comp\+Two} & Second string to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the strings are equal, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Equals@{Equals}}
\index{Equals@{Equals}!Ace@{Ace}}
\subsubsection[{Equals(wchar\+\_\+t $\ast$str\+To\+Comp\+One, wchar\+\_\+t $\ast$str\+To\+Comp\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Equals (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Comp\+One, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Comp\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a613fd5b028d5ba0ac5c7de30ab744266}


Compares two traditional wide strings together. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* strOne = L\textcolor{stringliteral}{"Eddie"};
\textcolor{keywordtype}{wchar\_t}* strTwo = L\textcolor{stringliteral}{"Katianie"};
\textcolor{keywordflow}{if} (Ace::Equals(strOne, strTwo) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Strings are equal."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Strings are NOT equal."});
\}
\end{DoxyCode}
 Output\+:Strings are N\+OT equal.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Comp\+One} & First wide string to compare. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Comp\+Two} & Second wide string to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the wide strings are equal, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Equals\+Ignore\+Case@{Equals\+Ignore\+Case}}
\index{Equals\+Ignore\+Case@{Equals\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Equals\+Ignore\+Case(char $\ast$str\+To\+Comp\+One, char $\ast$str\+To\+Comp\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Equals\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Comp\+One, }
\item[{char $\ast$}]{str\+To\+Comp\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5310b61a074383bf2ee4df005c6784e1}


Compares two traditional strings together but ignores upper/lower case. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/16/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* strOne = \textcolor{stringliteral}{"Katianie"};
\textcolor{keywordtype}{char}* strTwo = \textcolor{stringliteral}{"kATIaNiE"};
\textcolor{keywordflow}{if} (Ace::EqualsIgnoreCase(strOne, strTwo) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Strings are equal."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"Strings are NOT equal."});
\}
\end{DoxyCode}
 Output\+:Strings are equal.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Comp\+One} & First string to compare. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Comp\+Two} & Second string to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the strings are equal, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Equals\+Ignore\+Case@{Equals\+Ignore\+Case}}
\index{Equals\+Ignore\+Case@{Equals\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Equals\+Ignore\+Case(wchar\+\_\+t $\ast$str\+To\+Comp\+One, wchar\+\_\+t $\ast$str\+To\+Comp\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Equals\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Comp\+One, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Comp\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abef72240bed5aa10df9b9f8bceec3bb9}


Compares two traditional wide strings together but ignores upper/lower case. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* strOne = L\textcolor{stringliteral}{"Katianie"};
\textcolor{keywordtype}{wchar\_t}* strTwo = L\textcolor{stringliteral}{"kATIaNiE"};
\textcolor{keywordflow}{if} (Ace::EqualsIgnoreCase(strOne, strTwo) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Strings are equal."});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"Strings are NOT equal."});
\}
\end{DoxyCode}
 Output\+:Strings are equal.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Comp\+One} & First wide string to compare. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Comp\+Two} & Second wide string to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the strings are equal, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Error\+Function@{Error\+Function}}
\index{Error\+Function@{Error\+Function}!Ace@{Ace}}
\subsubsection[{Error\+Function(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Error\+Function (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa522bbdb8b2d83603bf89f64714f4d89}


Calculates the Error Function integral from 0 to num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::ErrorFunction(1.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 0.\+842701


\begin{DoxyParams}{Parameters}
{\em num} & End point for the integral.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of the Error Function from 0 to num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Error\+Function@{Error\+Function}}
\index{Error\+Function@{Error\+Function}!Ace@{Ace}}
\subsubsection[{Error\+Function(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Error\+Function (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a93a5ce3eee3f3fabb6fa3a0ac9b2c8c4}


Calculates the Error Function integral from 0 to num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::ErrorFunction(1.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 0.\+842701


\begin{DoxyParams}{Parameters}
{\em num} & End point for the integral.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of the Error Function from 0 to num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!E\+To\+The\+X\+Power@{E\+To\+The\+X\+Power}}
\index{E\+To\+The\+X\+Power@{E\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{E\+To\+The\+X\+Power(double power)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+E\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{double}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae51ded8e8e681b85ee397e381068dbca}


Calculates e$^\wedge$x in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::EToTheXPower(5.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 148.\+413159


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise e to (i.\+e. power = x in e$^\wedge$x).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of raising e to power. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!E\+To\+The\+X\+Power@{E\+To\+The\+X\+Power}}
\index{E\+To\+The\+X\+Power@{E\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{E\+To\+The\+X\+Power(float power)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+E\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{float}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a263f99643d5a480447b556856b016b37}


Calculates e$^\wedge$x in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::EToTheXPower(5.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 148.\+413159


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise e to (i.\+e. power = x in e$^\wedge$x).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of raising e to power. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!E\+To\+The\+X\+Power\+Minus\+One@{E\+To\+The\+X\+Power\+Minus\+One}}
\index{E\+To\+The\+X\+Power\+Minus\+One@{E\+To\+The\+X\+Power\+Minus\+One}!Ace@{Ace}}
\subsubsection[{E\+To\+The\+X\+Power\+Minus\+One(double power)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+E\+To\+The\+X\+Power\+Minus\+One (
\begin{DoxyParamCaption}
\item[{double}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a50cb517fc19d73e44bb9c3cc1141d7bc}


Calculates (e$^\wedge$x) -\/ 1 in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::EToTheXPowerMinusOne(5.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 147.\+413159


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise e to (i.\+e. power = x in e$^\wedge$x).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of raising e to power then subtracting 1. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!E\+To\+The\+X\+Power\+Minus\+One@{E\+To\+The\+X\+Power\+Minus\+One}}
\index{E\+To\+The\+X\+Power\+Minus\+One@{E\+To\+The\+X\+Power\+Minus\+One}!Ace@{Ace}}
\subsubsection[{E\+To\+The\+X\+Power\+Minus\+One(float power)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+E\+To\+The\+X\+Power\+Minus\+One (
\begin{DoxyParamCaption}
\item[{float}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a544ff3061a586b5cdedddbf21287ae22}


Calculates (e$^\wedge$x) -\/ 1 in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::EToTheXPowerMinusOne(5.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 147.\+413159


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise e to (i.\+e. power = x in e$^\wedge$x).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of raising e to power then subtracting 1. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!First\+Char@{First\+Char}}
\index{First\+Char@{First\+Char}!Ace@{Ace}}
\subsubsection[{First\+Char(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}char Ace\+::\+First\+Char (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aca1a612de325a7636ef40c95b676795d}


Returns the first character in str. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{char} temp = Ace::FirstChar(data);
printf(\textcolor{stringliteral}{"%c"}, temp);
\end{DoxyCode}
 Output\+:H


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The first character in str. 
\end{DoxyReturn}
\index{Ace@{Ace}!First\+Char@{First\+Char}}
\index{First\+Char@{First\+Char}!Ace@{Ace}}
\subsubsection[{First\+Char(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t Ace\+::\+First\+Char (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0e34aae1025e81ad4684b34940a70959}


Returns the first character in str. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{wchar\_t} temp = Ace::FirstChar(data);
printf(\textcolor{stringliteral}{"%c"}, temp);
\end{DoxyCode}
 Output\+:H


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & Wide String to search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The first character in str. 
\end{DoxyReturn}
\index{Ace@{Ace}!Floor@{Floor}}
\index{Floor@{Floor}!Ace@{Ace}}
\subsubsection[{Floor(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Floor (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a509e6fda4da886680951615f2ac2d421}


Calculates the largest integer value not greater than num. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} retVal = Ace::Floor(2.9);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 2.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & The number to use to calculate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The largest integer value not greater than num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Floor@{Floor}}
\index{Floor@{Floor}!Ace@{Ace}}
\subsubsection[{Floor(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Floor (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae821a3392f3637b82112c010f060026b}


Calculates the largest integer value not greater than num. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} retVal = Ace::Floor(2.9f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 2.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & The number to use to calculate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The largest integer value not greater than num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Gamma\+Function@{Gamma\+Function}}
\index{Gamma\+Function@{Gamma\+Function}!Ace@{Ace}}
\subsubsection[{Gamma\+Function(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Gamma\+Function (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a06b87693241afd13cfe45e052e6196f0}


Calculates The Gamma Function ( (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] ) in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::GammaFunction(5.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 24.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & Number to use for t$^\wedge$num-\/1 in the equation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of calculating The Gamma Function for t$^\wedge$num-\/1. If a mathematical error occurs or if num is less than or equal to 0.\+0, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Gamma\+Function@{Gamma\+Function}}
\index{Gamma\+Function@{Gamma\+Function}!Ace@{Ace}}
\subsubsection[{Gamma\+Function(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Gamma\+Function (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_afe867fa9d28bd8f4233fd488b5e533ee}


Calculates The Gamma Function ( (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] ) in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::GammaFunction(5.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 24.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & Number to use for t$^\wedge$num-\/1 in the equation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of calculating The Gamma Function for t$^\wedge$num-\/1. If a mathematical error occurs or if num is less than or equal to 0.\+0, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Generate\+Random\+Num@{Generate\+Random\+Num}}
\index{Generate\+Random\+Num@{Generate\+Random\+Num}!Ace@{Ace}}
\subsubsection[{Generate\+Random\+Num(int min, int max)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Generate\+Random\+Num (
\begin{DoxyParamCaption}
\item[{int}]{min, }
\item[{int}]{max}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af052dd5bee7f50a8f80f3af4375a874a}


Some might think this is all unnecessary but I think it\textquotesingle{}s important to seed the Random\+Number\+Generator properly with a proper seed value. 

Too often are games plagued with predictable outcomes all leading back to not seeding the R\+NG properly. Generates a \char`\"{}super\char`\"{} random number using a random seed at launch.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} randomNum = -1;
\textcolor{comment}{//Generate 10 random numbers.}
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 1; currIndex <= 10; currIndex++)
\{
    randomNum = Ace::GenerateRandomNum(1, 100);
    printf(\textcolor{stringliteral}{"%d "}, randomNum);
\}
\end{DoxyCode}
 Output\+:35 82 10 52 10 34 56 21 37 14


\begin{DoxyParams}{Parameters}
{\em min} & Lowest number to generate. \\
\hline
{\em max} & Highest number to generate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A random number between the given range. 
\end{DoxyReturn}
\index{Ace@{Ace}!Hypotenuse@{Hypotenuse}}
\index{Hypotenuse@{Hypotenuse}!Ace@{Ace}}
\subsubsection[{Hypotenuse(double x, double y)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Hypotenuse (
\begin{DoxyParamCaption}
\item[{double}]{x, }
\item[{double}]{y}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a913e668440d1c00f00d340519bf95a7c}


Solves for c in Pythagoras theorem (a$^\wedge$2 + b$^\wedge$2 = c$^\wedge$2); i.\+e square root of (x$^\wedge$2 + y$^\wedge$2). 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::Hypotenuse(3.0, 4.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 5.\+000000


\begin{DoxyParams}{Parameters}
{\em x} & Value of one of the sides of the triangle. \\
\hline
{\em y} & Value of the other side of the triangle.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Hypotenuse (the longest side) of the triangle. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Hypotenuse@{Hypotenuse}}
\index{Hypotenuse@{Hypotenuse}!Ace@{Ace}}
\subsubsection[{Hypotenuse(float x, float y)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Hypotenuse (
\begin{DoxyParamCaption}
\item[{float}]{x, }
\item[{float}]{y}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aaa3ee98b16b39b101f3258803bc1e03d}


Solves for c in Pythagoras theorem (a$^\wedge$2 + b$^\wedge$2 = c$^\wedge$2); i.\+e square root of (x$^\wedge$2 + y$^\wedge$2). 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::Hypotenuse(3.0f, 4.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 5.\+000000


\begin{DoxyParams}{Parameters}
{\em x} & Value of one of the sides of the triangle. \\
\hline
{\em y} & Value of the other side of the triangle.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Hypotenuse (the longest side) of the triangle. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of@{Index\+Of}}
\index{Index\+Of@{Index\+Of}!Ace@{Ace}}
\subsubsection[{Index\+Of(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a50a722b64f2f7a54b297cb5beae7330b}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{int} temp = Ace::IndexOf(data, \textcolor{stringliteral}{"been"});
printf(\textcolor{stringliteral}{"%d"}, temp);
\end{DoxyCode}
 Output\+:16


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of@{Index\+Of}}
\index{Index\+Of@{Index\+Of}!Ace@{Ace}}
\subsubsection[{Index\+Of(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_acf9bd88f509f374f6020dc19c7a77252}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{int} temp = Ace::IndexOf(data, L\textcolor{stringliteral}{"been"});
printf(\textcolor{stringliteral}{"%d"}, temp);
\end{DoxyCode}
 Output\+:16


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & Wide String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & Wide String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of\+First\+Letter@{Index\+Of\+First\+Letter}}
\index{Index\+Of\+First\+Letter@{Index\+Of\+First\+Letter}!Ace@{Ace}}
\subsubsection[{Index\+Of\+First\+Letter(char $\ast$str\+To\+Search)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of\+First\+Letter (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a273501ca36610e1631ff37b2dd93cddf}


Returns the first index of a letter in a given string. 

For Example\+: \char`\"{}23584\+Anus\char`\"{} would return 5.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
printf(\textcolor{stringliteral}{"%d"}, Ace::IndexOfFirstLetter(\textcolor{stringliteral}{"23584Anus"}));
\end{DoxyCode}
 Output\+:5


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search for the first occurrence of a alphabetical character.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where in str\+To\+Search the first alphabetical character was found. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of\+First\+Letter@{Index\+Of\+First\+Letter}}
\index{Index\+Of\+First\+Letter@{Index\+Of\+First\+Letter}!Ace@{Ace}}
\subsubsection[{Index\+Of\+First\+Letter(wchar\+\_\+t $\ast$str\+To\+Search)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of\+First\+Letter (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae0ec852c9eea044d4a1dcb0d03462166}


Returns the first index of a letter in a given wide string. 

For Example\+: \char`\"{}23584\+Anus\char`\"{} would return 5.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
printf(\textcolor{stringliteral}{"%d"}, Ace::IndexOfFirstLetter(L\textcolor{stringliteral}{"23584Anus"}));
\end{DoxyCode}
 Output\+:5


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & Wide String to search for the first occurrence of a alphabetical character.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where in str\+To\+Search the first alphabetical character was found. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of\+Ignore\+Case@{Index\+Of\+Ignore\+Case}}
\index{Index\+Of\+Ignore\+Case@{Index\+Of\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Index\+Of\+Ignore\+Case(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5e24b813ba1540fc92502435e4d817ce}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/26/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} result = Ace::IndexOfIgnoreCase(\textcolor{stringliteral}{"My name is eddIe and I like cheese."}, \textcolor{stringliteral}{"EdDIe"});
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+:11


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. 
\end{DoxyReturn}
\index{Ace@{Ace}!Index\+Of\+Ignore\+Case@{Index\+Of\+Ignore\+Case}}
\index{Index\+Of\+Ignore\+Case@{Index\+Of\+Ignore\+Case}!Ace@{Ace}}
\subsubsection[{Index\+Of\+Ignore\+Case(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Index\+Of\+Ignore\+Case (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0827c26650755411f44c94920142c421}


Searches str\+To\+Search for the first occurrence of str\+To\+Look\+For (regardless of case) and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} result = Ace::IndexOfIgnoreCase(L\textcolor{stringliteral}{"My name is eddIe and I like cheese."}, L\textcolor{stringliteral}{"EdDIe"});
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+:11


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & Wide String to search starting from left to right. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & Wide String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. 
\end{DoxyReturn}
\index{Ace@{Ace}!Insert\+String@{Insert\+String}}
\index{Insert\+String@{Insert\+String}!Ace@{Ace}}
\subsubsection[{Insert\+String(char $\ast$str\+To\+Receive, char $\ast$str\+To\+Insert, int start\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Insert\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Receive, }
\item[{char $\ast$}]{str\+To\+Insert, }
\item[{int}]{start\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a488c9ea590fdf14919ad90ee1dc377ad}


Inserts the string str\+To\+Insert into str\+To\+Revcive by \char`\"{}sandwiching\char`\"{} the two halves of str\+To\+Receive. 

The first half is from 0 to start\+Index-\/1, the last half is from start\+Index to the end of str\+To\+Receive.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/10/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* retVal = Ace::InsertString(\textcolor{stringliteral}{"Eddie is a Computer Scientist."}, \textcolor{stringliteral}{" O\(\backslash\)'Hagan"}, 5);
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, retVal);
\_aligned\_free(retVal);
\end{DoxyCode}
 Output\+: Eddie O\textquotesingle{}Hagan is a Computer Scientist.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Receive} & The string to receive str\+To\+Insert. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Insert} & The string to sandwich/insert into str\+To\+Receive. \\
\hline
 & {\em start\+Index} & The index in str\+To\+Receive to insert at str\+To\+Insert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The newly created string with str\+To\+Insert inserted into str\+To\+Receive. 
\end{DoxyReturn}
\index{Ace@{Ace}!Insert\+String@{Insert\+String}}
\index{Insert\+String@{Insert\+String}!Ace@{Ace}}
\subsubsection[{Insert\+String(wchar\+\_\+t $\ast$str\+To\+Receive, wchar\+\_\+t $\ast$str\+To\+Insert, int start\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Insert\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Receive, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Insert, }
\item[{int}]{start\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac4a643953262f0837db5074a66286787}


Inserts the string str\+To\+Insert into str\+To\+Revcive by \char`\"{}sandwiching\char`\"{} the two halves of str\+To\+Receive. 

The first half is from 0 to start\+Index-\/1, the last half is from start\+Index to the end of str\+To\+Receive.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/10/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* retVal = Ace::InsertString(L\textcolor{stringliteral}{"Eddie is a Computer Scientist."}, L\textcolor{stringliteral}{" O\(\backslash\)'Hagan"}, 5);
printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, retVal);
\_aligned\_free(retVal);
\end{DoxyCode}
 Output\+: Eddie O\textquotesingle{}Hagan is a Computer Scientist.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Receive} & The wide string to receive str\+To\+Insert. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Insert} & The wide string to sandwich/insert into str\+To\+Receive. \\
\hline
 & {\em start\+Index} & The index in str\+To\+Receive to insert at str\+To\+Insert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The newly created wide string with str\+To\+Insert inserted into str\+To\+Receive. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Alphabetic@{Is\+Alphabetic}}
\index{Is\+Alphabetic@{Is\+Alphabetic}!Ace@{Ace}}
\subsubsection[{Is\+Alphabetic(char character)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Alphabetic (
\begin{DoxyParamCaption}
\item[{char}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aebb4f615642b84d54134e02e3fc8c083}


Returns true if a character is a letter from either a to z or A to Z. 

Letters fall into a range on the A\+S\+C\+II chart which makes this an simple test.

A\+S\+C\+II chart\+: {\tt http\+://www.\+asciitable.\+com/index/asciifull.\+gif}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsAlphabetic(\textcolor{charliteral}{'E'}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & A single character to test if it\textquotesingle{}s either a-\/z or A-\/Z.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the character is between ranges a-\/z or A-\/Z; false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Alphabetic@{Is\+Alphabetic}}
\index{Is\+Alphabetic@{Is\+Alphabetic}!Ace@{Ace}}
\subsubsection[{Is\+Alphabetic(wchar\+\_\+t character)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Alphabetic (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a658aece7e64b90e57ac08f8b79b8ed0c}


Returns true if a wide character is not a digit. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsAlphabetic(L\textcolor{charliteral}{'E'}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & A single wide character to test.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the character is not a digit. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Digit@{Is\+Digit}}
\index{Is\+Digit@{Is\+Digit}!Ace@{Ace}}
\subsubsection[{Is\+Digit(char character)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Digit (
\begin{DoxyParamCaption}
\item[{char}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab5bdc2fab29cf22bd6c06e62a5eab593}


Returns true if a character is a digit from 0-\/9. 

Digits fall into a range on the A\+S\+C\+II chart which makes this an simple test.

A\+S\+C\+II chart\+: {\tt http\+://www.\+asciitable.\+com/index/asciifull.\+gif}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsDigit(\textcolor{charliteral}{'7'}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & A single character to test if it\textquotesingle{}s between 0-\/9.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the character is between 0-\/9; false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Digit@{Is\+Digit}}
\index{Is\+Digit@{Is\+Digit}!Ace@{Ace}}
\subsubsection[{Is\+Digit(wchar\+\_\+t character)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Digit (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2e41b7c6ba214c7088e723a9027cf197}


Returns true if a wide character is a digit. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsDigit(L\textcolor{charliteral}{'7'}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & A single wide character to test if it\textquotesingle{}s between 0-\/9.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the wide character is a digit; false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Empty@{Is\+Empty}}
\index{Is\+Empty@{Is\+Empty}!Ace@{Ace}}
\subsubsection[{Is\+Empty(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Empty (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2f5cb4c89dff665ea2c0e1fd16fefd90}


Searches a given string to see if it is all empty. 

In other words, is the string provided all whitespace.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsEmpty(\textcolor{stringliteral}{"    "}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & String to search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if every character in str is whitespace; false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Empty@{Is\+Empty}}
\index{Is\+Empty@{Is\+Empty}!Ace@{Ace}}
\subsubsection[{Is\+Empty(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Empty (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abdfef27ea8065e456ad40cc31df5d66a}


Searches a given wide string to see if it is all empty. 

In other words, is the string provided all whitespace.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsEmpty(L\textcolor{stringliteral}{"    "}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & Wide String to search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if every wide character in str is whitespace; false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Number@{Is\+Number}}
\index{Is\+Number@{Is\+Number}!Ace@{Ace}}
\subsubsection[{Is\+Number(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Number (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abf209e3f71042eefd2091b990f0fc6f6}


Returns true if all characters are a digit. 

A\+S\+C\+II chart\+: {\tt http\+://www.\+asciitable.\+com/index/asciifull.\+gif}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsNumber(\textcolor{stringliteral}{"01234"}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & A string to test if all characters are digits.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the string is all digits. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Number@{Is\+Number}}
\index{Is\+Number@{Is\+Number}!Ace@{Ace}}
\subsubsection[{Is\+Number(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Number (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a78e3339b16bfe5d33d54e8a1f8961016}


Returns true if all characters are a digit. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsNumber(L\textcolor{stringliteral}{"01234"}) == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & A wide string to test if all characters are digits.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the wide string is all digits. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Path\+A\+Device@{Is\+Path\+A\+Device}}
\index{Is\+Path\+A\+Device@{Is\+Path\+A\+Device}!Ace@{Ace}}
\subsubsection[{Is\+Path\+A\+Device(const char $\ast$path)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Path\+A\+Device (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a14d72992e536c2a370f5c779cc3b1f5a}


Returns true if the provided path leads to a device rather than a file. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/14/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{bool} retVal = Ace::IsPathADevice(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)dicks.txt"});
\textcolor{keywordflow}{if} (retVal == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+: false


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & The file path to test.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the path leads to a device, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Path\+A\+Device@{Is\+Path\+A\+Device}}
\index{Is\+Path\+A\+Device@{Is\+Path\+A\+Device}!Ace@{Ace}}
\subsubsection[{Is\+Path\+A\+Device(const wchar\+\_\+t $\ast$path)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Path\+A\+Device (
\begin{DoxyParamCaption}
\item[{const wchar\+\_\+t $\ast$}]{path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2428e78c087c5582b690452ff0ace6e3}


Returns true if the provided path leads to a device rather than a file. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/14/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{bool} retVal = Ace::IsPathADevice(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)dicks.txt"});
\textcolor{keywordflow}{if} (retVal == \textcolor{keyword}{true})
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, L\textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+: false


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path} & The file path to test.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the path leads to a device, false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Whitespace@{Is\+Whitespace}}
\index{Is\+Whitespace@{Is\+Whitespace}!Ace@{Ace}}
\subsubsection[{Is\+Whitespace(char character)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Whitespace (
\begin{DoxyParamCaption}
\item[{char}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a66a594470f47320362a57ae4a4a556aa}


Returns true if a character is whitespace. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsWhitespace(\textcolor{charliteral}{' '}) == \textcolor{keyword}{true})
\{
      printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
      printf(\textcolor{stringliteral}{"%s"}, \textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & Character to test to see if it is whitespace.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the character is a space, tab or newline; false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Is\+Whitespace@{Is\+Whitespace}}
\index{Is\+Whitespace@{Is\+Whitespace}!Ace@{Ace}}
\subsubsection[{Is\+Whitespace(wchar\+\_\+t character)}]{\setlength{\rightskip}{0pt plus 5cm}bool Ace\+::\+Is\+Whitespace (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t}]{character}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7923870bcd0a10fedf5d809421eabcd2}


Returns true if a wide character is whitespace. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordflow}{if} (Ace::IsWhitespace(L\textcolor{charliteral}{' '}) == \textcolor{keyword}{true})
\{
  printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"true"});
\}
\textcolor{keywordflow}{else}
\{
  printf(\textcolor{stringliteral}{"%S"}, L\textcolor{stringliteral}{"false"});
\}
\end{DoxyCode}
 Output\+:true


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em character} & Character to test to see if it is whitespace.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the wide character is a space, tab or newline; false otherwise. 
\end{DoxyReturn}
\index{Ace@{Ace}!Largest@{Largest}}
\index{Largest@{Largest}!Ace@{Ace}}
\subsubsection[{Largest(double num1, double num2)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Largest (
\begin{DoxyParamCaption}
\item[{double}]{num1, }
\item[{double}]{num2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8eae4684d32fec1d237da49b0ad57da9}


Returns the larger of the two values. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} retVal = Ace::Largest(2.0, 2.01);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 2.\+010000


\begin{DoxyParams}{Parameters}
{\em num1} & number to compare against. \\
\hline
{\em num1} & other number to compare against.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The larger of the two values. 
\end{DoxyReturn}
\index{Ace@{Ace}!Largest@{Largest}}
\index{Largest@{Largest}!Ace@{Ace}}
\subsubsection[{Largest(float num1, float num2)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Largest (
\begin{DoxyParamCaption}
\item[{float}]{num1, }
\item[{float}]{num2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a02b6e67c430dd5750862a6ed3356c8ed}


Returns the larger of the two values. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} retVal = Ace::Largest(2.0f, 2.01f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 2.\+010000


\begin{DoxyParams}{Parameters}
{\em num1} & number to compare against. \\
\hline
{\em num1} & other number to compare against.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The larger of the two values. 
\end{DoxyReturn}
\index{Ace@{Ace}!Last\+Char@{Last\+Char}}
\index{Last\+Char@{Last\+Char}!Ace@{Ace}}
\subsubsection[{Last\+Char(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}char Ace\+::\+Last\+Char (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae0d85e7e3e82f46a0227b85f7112458c}


Returns the last character in str. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{char} temp = Ace::LastChar(data);
printf(\textcolor{stringliteral}{"%c"}, temp);
\end{DoxyCode}
 Output\+:?


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str} & String to search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The last character in str. 
\end{DoxyReturn}
\index{Ace@{Ace}!Last\+Char@{Last\+Char}}
\index{Last\+Char@{Last\+Char}!Ace@{Ace}}
\subsubsection[{Last\+Char(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t Ace\+::\+Last\+Char (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad265da6c7c28b05d19489da9398302aa}


Returns the last character in str. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{wchar\_t} temp = Ace::LastChar(data);
printf(\textcolor{stringliteral}{"%c"}, temp);
\end{DoxyCode}
 Output\+:?


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str} & Wide String to search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The last character in str. 
\end{DoxyReturn}
\index{Ace@{Ace}!Last\+Index\+Of@{Last\+Index\+Of}}
\index{Last\+Index\+Of@{Last\+Index\+Of}!Ace@{Ace}}
\subsubsection[{Last\+Index\+Of(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Last\+Index\+Of (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_acf5ed5e07611ea7cc31b21d808b20e4d}


Searches str\+To\+Search for the last occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{int} temp = Ace::LastIndexOf(data, \textcolor{stringliteral}{"th"});
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, temp);
\end{DoxyCode}
 Output\+:55


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & String to search starting from right to left. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. 
\end{DoxyReturn}
\index{Ace@{Ace}!Last\+Index\+Of@{Last\+Index\+Of}}
\index{Last\+Index\+Of@{Last\+Index\+Of}!Ace@{Ace}}
\subsubsection[{Last\+Index\+Of(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Last\+Index\+Of (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae0a414c4d05e32a3a1a93fdd9e2faf64}


Searches str\+To\+Search for the last occurrence of str\+To\+Look\+For and returns the (0 based) index of its location. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{int} temp = Ace::LastIndexOf(data, L\textcolor{stringliteral}{"th"});
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, temp);
\end{DoxyCode}
 Output\+:55


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & Wide String to search starting from right to left. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & Wide String to look for inside of str\+To\+Search.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The (0 based) index of where str\+To\+Look\+For is located. 
\end{DoxyReturn}
\index{Ace@{Ace}!Log\+Base\+Ten@{Log\+Base\+Ten}}
\index{Log\+Base\+Ten@{Log\+Base\+Ten}!Ace@{Ace}}
\subsubsection[{Log\+Base\+Ten(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Log\+Base\+Ten (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a278ffeb56149bc1cc75617d639b63468}


Calculates the logarithm (log) base 10 of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} retVal = Ace::LogBaseTen(69.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 1.\+838849


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its logarithm base 10.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The logarithm base 10 of num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Log\+Base\+Ten@{Log\+Base\+Ten}}
\index{Log\+Base\+Ten@{Log\+Base\+Ten}!Ace@{Ace}}
\subsubsection[{Log\+Base\+Ten(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Log\+Base\+Ten (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae49751bb233954e6d17505e1089d9f0c}


Calculates the logarithm (log) base 10 of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} retVal = Ace::LogBaseTen(69.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 1.\+838849


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its logarithm base 10.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The logarithm base 10 of num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Log\+Base\+Two@{Log\+Base\+Two}}
\index{Log\+Base\+Two@{Log\+Base\+Two}!Ace@{Ace}}
\subsubsection[{Log\+Base\+Two(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Log\+Base\+Two (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af2bfc128e37911cda7a8af0b9a3a06b9}


Calculates the logarithm (log) base 2 of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} retVal = Ace::LogBaseTwo(69.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 6.\+108524


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its logarithm base 2.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The logarithm base 2 of num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Log\+Base\+Two@{Log\+Base\+Two}}
\index{Log\+Base\+Two@{Log\+Base\+Two}!Ace@{Ace}}
\subsubsection[{Log\+Base\+Two(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Log\+Base\+Two (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6a2fa76e6de2cc82a2eb64bd07053f68}


Calculates the logarithm (log) base 2 of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} retVal = Ace::LogBaseTwo(69.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 6.\+108524


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its logarithm base 2.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The logarithm base 2 of num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Mod@{Mod}}
\index{Mod@{Mod}!Ace@{Ace}}
\subsubsection[{Mod(double numerator, double denominator)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Mod (
\begin{DoxyParamCaption}
\item[{double}]{numerator, }
\item[{double}]{denominator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a6529499a01bc16109f19ebcb719019f7}


Computes the floating-\/point remainder of the division operation numerator/denominator in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::Mod(9.0, 5.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 4.\+000000


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The remainder of the division operation. If a mathematical error occurs or if denominator equals 0, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Mod@{Mod}}
\index{Mod@{Mod}!Ace@{Ace}}
\subsubsection[{Mod(float numerator, float denominator)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Mod (
\begin{DoxyParamCaption}
\item[{float}]{numerator, }
\item[{float}]{denominator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac623f8d6f81e2b1725ca7039815a94c7}


Computes the floating-\/point remainder of the division operation numerator/denominator in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::Mod(9.0f, 5.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 4.\+000000


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The remainder of the division operation. If a mathematical error occurs or if denominator equals 0, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Multiply\+Then\+Add@{Multiply\+Then\+Add}}
\index{Multiply\+Then\+Add@{Multiply\+Then\+Add}!Ace@{Ace}}
\subsubsection[{Multiply\+Then\+Add(double mult\+One, double mult\+Two, double add)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Multiply\+Then\+Add (
\begin{DoxyParamCaption}
\item[{double}]{mult\+One, }
\item[{double}]{mult\+Two, }
\item[{double}]{add}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9521670cd2b0a4f90f58ee430e26a44c}


Calculates the product of mult\+One $\ast$ mult\+Two, then adds add to that product (i.\+e. 

(mult\+One $\ast$ mult\+Two) + add). Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::MultiplyThenAdd(9.0, 3.0, 15.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 42.\+000000


\begin{DoxyParams}{Parameters}
{\em mult\+One} & Number to multiply. \\
\hline
{\em mult\+Two} & Other number to multiply. \\
\hline
{\em add} & Number to add to the product of mult\+One $\ast$ mult\+Two.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of (mult\+One $\ast$ mult\+Two) + add. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Multiply\+Then\+Add@{Multiply\+Then\+Add}}
\index{Multiply\+Then\+Add@{Multiply\+Then\+Add}!Ace@{Ace}}
\subsubsection[{Multiply\+Then\+Add(float mult\+One, float mult\+Two, float add)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Multiply\+Then\+Add (
\begin{DoxyParamCaption}
\item[{float}]{mult\+One, }
\item[{float}]{mult\+Two, }
\item[{float}]{add}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a934487848d6a37fef098f48d77473849}


Calculates the product of mult\+One $\ast$ mult\+Two, then adds add to that product (i.\+e. 

(mult\+One $\ast$ mult\+Two) + add). Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::MultiplyThenAdd(9.0f, 3.0f, 15.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 42.\+000000


\begin{DoxyParams}{Parameters}
{\em mult\+One} & Number to multiply. \\
\hline
{\em mult\+Two} & Other number to multiply. \\
\hline
{\em add} & Number to add to the product of mult\+One $\ast$ mult\+Two.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of (mult\+One $\ast$ mult\+Two) + add. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Natural\+Log@{Natural\+Log}}
\index{Natural\+Log@{Natural\+Log}!Ace@{Ace}}
\subsubsection[{Natural\+Log(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Natural\+Log (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a69ddb0ab24047c5175b3dc4fb3e8f3c6}


Calculates the Natural Logarithm (ln) of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} retVal = Ace::NaturalLog(69.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 4.\+234107


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its Natural Logarithm.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Natural Logarithm of num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Natural\+Log@{Natural\+Log}}
\index{Natural\+Log@{Natural\+Log}!Ace@{Ace}}
\subsubsection[{Natural\+Log(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Natural\+Log (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae5ac7b240b43c5af775695af889c1734}


Calculates the Natural Logarithm (ln) of num in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} retVal = Ace::NaturalLog(69.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 4.\+234107


\begin{DoxyParams}{Parameters}
{\em num} & Number to use to calculate its Natural Logarithm.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Natural Logarithm of num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Natural\+Log\+Gamma\+Function@{Natural\+Log\+Gamma\+Function}}
\index{Natural\+Log\+Gamma\+Function@{Natural\+Log\+Gamma\+Function}!Ace@{Ace}}
\subsubsection[{Natural\+Log\+Gamma\+Function(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Natural\+Log\+Gamma\+Function (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a2a3aa781cdf81480b5e1ce5075649ed4}


Calculates The Natural Log (ln) of The Gamma Function (ln $\vert$ (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] $\vert$). 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::NaturalLogGammaFunction(5.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 3.\+178054


\begin{DoxyParams}{Parameters}
{\em num} & Number to use for t$^\wedge$num-\/1 in the equation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of calculating The Gamma Function for t$^\wedge$num-\/1. If a mathematical error occurs or if num is less than or equal to 0.\+0, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Natural\+Log\+Gamma\+Function@{Natural\+Log\+Gamma\+Function}}
\index{Natural\+Log\+Gamma\+Function@{Natural\+Log\+Gamma\+Function}!Ace@{Ace}}
\subsubsection[{Natural\+Log\+Gamma\+Function(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Natural\+Log\+Gamma\+Function (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a698a0b446107e5226c61faa3f3922277}


Calculates The Natural Log (ln) of The Gamma Function (ln $\vert$ (0)integral(\+Inf)[t$^\wedge$num-\/1 $\ast$ e$^\wedge$-\/t dt] $\vert$). 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::NaturalLogGammaFunction(5.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 3.\+178054


\begin{DoxyParams}{Parameters}
{\em num} & Number to use for t$^\wedge$num-\/1 in the equation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of calculating The Gamma Function for t$^\wedge$num-\/1. If a mathematical error occurs or if num is less than or equal to 0.\+0, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Next\+Index\+Of@{Next\+Index\+Of}}
\index{Next\+Index\+Of@{Next\+Index\+Of}!Ace@{Ace}}
\subsubsection[{Next\+Index\+Of(char $\ast$str\+To\+Search, char char\+To\+Look\+For, int start\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Next\+Index\+Of (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char}]{char\+To\+Look\+For, }
\item[{int}]{start\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a12241a4abf6a86ad707789cbe9979dd7}


Retrieves the first occurrence of char\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/10/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} retVal = Ace::NextIndexOf(\textcolor{stringliteral}{"I wish I blew it up instead...wicked."}, \textcolor{charliteral}{'I'}, 1);
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 7


\begin{DoxyParams}{Parameters}
{\em str\+To\+Search} & String to search through. \\
\hline
{\em char\+To\+Look\+For} & Character to look for in str\+To\+Search. \\
\hline
{\em start\+Index} & Index to start looking.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The index of the first occurrence of char\+To\+Look\+For starting from start\+Index. If not found, -\/1 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Next\+Index\+Of@{Next\+Index\+Of}}
\index{Next\+Index\+Of@{Next\+Index\+Of}!Ace@{Ace}}
\subsubsection[{Next\+Index\+Of(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t char\+To\+Look\+For, int start\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Next\+Index\+Of (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t}]{char\+To\+Look\+For, }
\item[{int}]{start\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aeb1c9d5abc5fca76246008bada3bc55d}


Retrieves the first occurrence of char\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/10/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} retVal = Ace::NextIndexOf(L\textcolor{stringliteral}{"I wish I blew it up instead...wicked."}, L\textcolor{charliteral}{'I'}, 1);
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 7


\begin{DoxyParams}{Parameters}
{\em str\+To\+Search} & Wide String to search through. \\
\hline
{\em char\+To\+Look\+For} & Wide Character to look for in str\+To\+Search. \\
\hline
{\em start\+Index} & Index to start looking.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The index of the first occurrence of char\+To\+Look\+For starting from start\+Index. If not found, -\/1 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Next\+Index\+Of@{Next\+Index\+Of}}
\index{Next\+Index\+Of@{Next\+Index\+Of}!Ace@{Ace}}
\subsubsection[{Next\+Index\+Of(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For, int start\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Next\+Index\+Of (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For, }
\item[{int}]{start\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aeb3c690712a0eb95f5dd60ebb6ea0120}


Retrieves the first occurrence of str\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/10/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} retVal = Ace::NextIndexOf(\textcolor{stringliteral}{"I wish I blew it up instead...wicked."}, \textcolor{stringliteral}{"I "}, 1);
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 7


\begin{DoxyParams}{Parameters}
{\em str\+To\+Search} & String to search through. \\
\hline
{\em str\+To\+Look\+For} & String to look for in str\+To\+Search. \\
\hline
{\em start\+Index} & Index to start looking.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The index of the first occurrence of str\+To\+Look\+For starting from start\+Index. If not found, -\/1 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Next\+Index\+Of@{Next\+Index\+Of}}
\index{Next\+Index\+Of@{Next\+Index\+Of}!Ace@{Ace}}
\subsubsection[{Next\+Index\+Of(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For, int start\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}int Ace\+::\+Next\+Index\+Of (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For, }
\item[{int}]{start\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0af0979cd0675ebeff6ff99621593f3d}


Retrieves the first occurrence of str\+To\+Look\+For in str\+To\+Search starting at start\+Index onward. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/10/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} retVal = Ace::NextIndexOf(L\textcolor{stringliteral}{"I wish I blew it up instead...wicked."}, L\textcolor{stringliteral}{"I "}, 1);
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 7


\begin{DoxyParams}{Parameters}
{\em str\+To\+Search} & Wide String to search through. \\
\hline
{\em str\+To\+Look\+For} & Wide String to look for in str\+To\+Search. \\
\hline
{\em start\+Index} & Index to start looking.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The index of the first occurrence of str\+To\+Look\+For starting from start\+Index. If not found, -\/1 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Num\+Times\+Two\+To\+The\+X\+Power@{Num\+Times\+Two\+To\+The\+X\+Power}}
\index{Num\+Times\+Two\+To\+The\+X\+Power@{Num\+Times\+Two\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{Num\+Times\+Two\+To\+The\+X\+Power(double num, double power)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Num\+Times\+Two\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{double}]{num, }
\item[{double}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9beab58661041127b9073ec5ff8a275a}


Calculates num $\ast$ 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::NumTimesTwoToTheXPower(1.0/3.0, 5.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 10.\+666667


\begin{DoxyParams}{Parameters}
{\em num} & Number to multiply 2$^\wedge$power by. \\
\hline
{\em power} & Number to raise 2 to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of num $\ast$ 2$^\wedge$power. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Num\+Times\+Two\+To\+The\+X\+Power@{Num\+Times\+Two\+To\+The\+X\+Power}}
\index{Num\+Times\+Two\+To\+The\+X\+Power@{Num\+Times\+Two\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{Num\+Times\+Two\+To\+The\+X\+Power(float num, float power)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Num\+Times\+Two\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{float}]{num, }
\item[{float}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a432c3d7cf654920eb21e72f0711db3d5}


Calculates num $\ast$ 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::NumTimesTwoToTheXPower(1.0f/3.0f, 5.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 10.\+666667


\begin{DoxyParams}{Parameters}
{\em num} & Number to multiply 2$^\wedge$power by. \\
\hline
{\em power} & Number to raise 2 to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The result of num $\ast$ 2$^\wedge$power. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Positive\+Difference@{Positive\+Difference}}
\index{Positive\+Difference@{Positive\+Difference}!Ace@{Ace}}
\subsubsection[{Positive\+Difference(double num\+One, double num\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Positive\+Difference (
\begin{DoxyParamCaption}
\item[{double}]{num\+One, }
\item[{double}]{num\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5a64e64344fe2e67ba61a945d29ac95a}


Calculates the difference between num\+One and num\+Two only if num\+One $>$ num\+Two. 

If num\+One $<$= num\+Two then 0 is returned. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::PositiveDifference(6.3, 2.7);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 3.\+600000


\begin{DoxyParams}{Parameters}
{\em num\+One} & Number to use for subtraction. \\
\hline
{\em num\+Two} & Other number to use for subtraction.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If num\+One is larger then num\+Two; then num\+One -\/ num\+Two is returned, else 0 is returned. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Positive\+Difference@{Positive\+Difference}}
\index{Positive\+Difference@{Positive\+Difference}!Ace@{Ace}}
\subsubsection[{Positive\+Difference(float num\+One, float num\+Two)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Positive\+Difference (
\begin{DoxyParamCaption}
\item[{float}]{num\+One, }
\item[{float}]{num\+Two}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a94ec5e1a6548f4dc778e26c4049dc6e0}


Calculates the difference between num\+One and num\+Two only if num\+One $>$ num\+Two. 

If num\+One $<$= num\+Two then 0 is returned. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::PositiveDifference(6.3f, 2.7f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 3.\+600000


\begin{DoxyParams}{Parameters}
{\em num\+One} & Number to use for subtraction. \\
\hline
{\em num\+Two} & Other number to use for subtraction.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If num\+One is larger then num\+Two; then num\+One -\/ num\+Two is returned, else 0 is returned. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Power@{Power}}
\index{Power@{Power}!Ace@{Ace}}
\subsubsection[{Power(double base, double exponent)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Power (
\begin{DoxyParamCaption}
\item[{double}]{base, }
\item[{double}]{exponent}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_adbcb9f24f9c412d29d7b671a3aa16c42}


Takes the provided base and raises it to the exponent (power). 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/29/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} powResult = Ace::Power(2.0, 5.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, powResult);
\end{DoxyCode}
 Output\+: 32.\+000000


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em base} & Number to raise. \\
\hline
\mbox{\tt in}  & {\em exponent} & Number of times to multiply base by itself.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The base raised to the exponent is returned. If a mathematical error occurs or base is 0.\+0 and exponent is less than or equal to 0.\+0 OR base is negative, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Power@{Power}}
\index{Power@{Power}!Ace@{Ace}}
\subsubsection[{Power(float base, float exponent)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Power (
\begin{DoxyParamCaption}
\item[{float}]{base, }
\item[{float}]{exponent}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abd44bbcb8b34e13bf23013af2522839d}


Takes the provided base and raises it to the exponent (power). 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} powResult = Ace::Power(2.0f, 5.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, powResult);
\end{DoxyCode}
 Output\+: 32.\+000000


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em base} & Number to raise. \\
\hline
\mbox{\tt in}  & {\em exponent} & Number of times to multiply base by itself.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The base raised to the exponent is returned. If a mathematical error occurs or base is 0.\+0 and exponent is less than or equal to 0.\+0 OR base is negative, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Radians\+To\+Degrees@{Radians\+To\+Degrees}}
\index{Radians\+To\+Degrees@{Radians\+To\+Degrees}!Ace@{Ace}}
\subsubsection[{Radians\+To\+Degrees(double radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Radians\+To\+Degrees (
\begin{DoxyParamCaption}
\item[{double}]{radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4acd795a7bf9c65be8e4c4f5d5647ba0}


Converts a number from radians to degrees. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/16/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} rad = 1.570796;
\textcolor{keywordtype}{double} deg = Ace::RadiansToDegrees(rad);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, deg);
\end{DoxyCode}
 Output\+:89.\+999981


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em radians} & Radians to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Degrees. 
\end{DoxyReturn}
\index{Ace@{Ace}!Radians\+To\+Degrees@{Radians\+To\+Degrees}}
\index{Radians\+To\+Degrees@{Radians\+To\+Degrees}!Ace@{Ace}}
\subsubsection[{Radians\+To\+Degrees(float radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Radians\+To\+Degrees (
\begin{DoxyParamCaption}
\item[{float}]{radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a38a090d5bd7b5b5cff8650f259ee35ce}


Converts a number from radians to degrees. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/16/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} rad = 1.570796f;
\textcolor{keywordtype}{float} deg = Ace::RadiansToDegrees(rad);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, deg);
\end{DoxyCode}
 Output\+:89.\+999981


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em radians} & Radians to convert.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Degrees. 
\end{DoxyReturn}
\index{Ace@{Ace}!Read\+Binary\+File@{Read\+Binary\+File}}
\index{Read\+Binary\+File@{Read\+Binary\+File}!Ace@{Ace}}
\subsubsection[{Read\+Binary\+File(char $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size=\+M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+Z\+E, const char $\ast$mode=""rb"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Read\+Binary\+File (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Path, }
\item[{size\+\_\+t}]{num\+Bytes\+To\+Read = {\ttfamily 0}, }
\item[{size\+\_\+t}]{max\+Buffer\+Size = {\ttfamily {\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}}, }
\item[{const char $\ast$}]{mode = {\ttfamily \char`\"{}rb\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9700d7264c30af90d9787a82c77170bb}


Opens a file for reading and returns a char buffer containing some or all of the data in the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* retVal = Ace::ReadBinaryFile(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)lookupdata.bin"});
printf(\textcolor{stringliteral}{"%x\(\backslash\)0"}, retVal);
\_aligned\_free(retVal)
\end{DoxyCode}
 Output\+: (binary file data can\textquotesingle{}t be displayed).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
 & {\em num\+Bytes\+To\+Read} & The size of the buffer (the number bytes read in). If 0; num\+Bytes\+To\+Read = max\+Buffer\+Size. \\
\hline
 & {\em max\+Buffer\+Size} & Maximum number of bytes to read. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}r\char`\"{} for read, \char`\"{}r+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Number of bytes to offset from origin. \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The buffer containing the file data of size num\+Bytes\+To\+Read. 
\end{DoxyReturn}
\index{Ace@{Ace}!Read\+Binary\+FileW@{Read\+Binary\+FileW}}
\index{Read\+Binary\+FileW@{Read\+Binary\+FileW}!Ace@{Ace}}
\subsubsection[{Read\+Binary\+File\+W(wchar\+\_\+t $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size=\+M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+Z\+E, const wchar\+\_\+t $\ast$mode=L""rb, ccs=\+U\+T\+F-\/8"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Read\+Binary\+FileW (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Path, }
\item[{size\+\_\+t}]{num\+Bytes\+To\+Read = {\ttfamily 0}, }
\item[{size\+\_\+t}]{max\+Buffer\+Size = {\ttfamily {\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}}, }
\item[{const wchar\+\_\+t $\ast$}]{mode = {\ttfamily L\char`\"{}rb,~ccs=UTF-\/8\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a38223fc1f30e753afb34313ce190fc09}


Opens a file for reading and returns a wide char buffer containing some or all of the data in the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{comment}{//By default, read mode is set to "r, ccs=UTF-8".}
\textcolor{keywordtype}{wchar\_t}* retVal = Ace::ReadBinaryFileW(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)lookupdata.bin"});
printf(\textcolor{stringliteral}{"%x\(\backslash\)0"}, retVal);
\_aligned\_free(retVal);
\end{DoxyCode}
 Output\+: (binary file data can\textquotesingle{}t be displayed).


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
 & {\em num\+Bytes\+To\+Read} & The size of the buffer (the number bytes read in). If 0; num\+Bytes\+To\+Read = max\+Buffer\+Size. \\
\hline
 & {\em max\+Buffer\+Size} & Maximum number of bytes to read. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}r\char`\"{} for read, \char`\"{}r, ccs=\+U\+T\+F-\/8\char`\"{} for read unicode, \char`\"{}r+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Number of bytes to offset from origin. \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The buffer containing the file data of size num\+Bytes\+To\+Read. 
\end{DoxyReturn}
\index{Ace@{Ace}!Read\+Text\+File@{Read\+Text\+File}}
\index{Read\+Text\+File@{Read\+Text\+File}!Ace@{Ace}}
\subsubsection[{Read\+Text\+File(char $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size=\+M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+Z\+E, const char $\ast$mode=""r"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Read\+Text\+File (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Path, }
\item[{size\+\_\+t}]{num\+Bytes\+To\+Read = {\ttfamily 0}, }
\item[{size\+\_\+t}]{max\+Buffer\+Size = {\ttfamily {\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}}, }
\item[{const char $\ast$}]{mode = {\ttfamily \char`\"{}r\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a66dfff3d59c12f04d7d45841ad8a1e85}


Opens a file for reading and returns a char buffer containing some or all of the data in the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/12/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* retVal = Ace::ReadTextFile(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)dicks.txt"});
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, retVal);
\_aligned\_free(retVal);
\end{DoxyCode}
 Output\+: dicksdicksdicksdicksdicksdicksdick8=$>$


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
 & {\em num\+Bytes\+To\+Read} & The size of the buffer (the number bytes read in). If 0; num\+Bytes\+To\+Read = max\+Buffer\+Size. \\
\hline
 & {\em max\+Buffer\+Size} & Maximum number of bytes to read. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}r\char`\"{} for read, \char`\"{}r+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Either zero, or a value returned by ftell(). \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The buffer containing the file data of size num\+Bytes\+To\+Read. 
\end{DoxyReturn}
\index{Ace@{Ace}!Read\+Text\+FileW@{Read\+Text\+FileW}}
\index{Read\+Text\+FileW@{Read\+Text\+FileW}!Ace@{Ace}}
\subsubsection[{Read\+Text\+File\+W(wchar\+\_\+t $\ast$file\+Path, size\+\_\+t num\+Bytes\+To\+Read=0, size\+\_\+t max\+Buffer\+Size=\+M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+Z\+E, const wchar\+\_\+t $\ast$mode=L""r, ccs=\+U\+T\+F-\/8"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Read\+Text\+FileW (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Path, }
\item[{size\+\_\+t}]{num\+Bytes\+To\+Read = {\ttfamily 0}, }
\item[{size\+\_\+t}]{max\+Buffer\+Size = {\ttfamily {\bf M\+A\+X\+\_\+\+S\+T\+R\+I\+N\+G\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+S\+I\+ZE}}, }
\item[{const wchar\+\_\+t $\ast$}]{mode = {\ttfamily L\char`\"{}r,~ccs=UTF-\/8\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a66aaa5acfe5830750b2c1d0658ac281b}


Opens a file for reading and returns a wide char buffer containing some or all of the data in the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{comment}{//By default, read mode is set to "r, ccs=UTF-8".}
\textcolor{keywordtype}{wchar\_t}* retVal = Ace::ReadTextFileW(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)jap.txt"});
MessageBoxW(NULL, retVal, NULL, 0);
\_aligned\_free(retVal);
\end{DoxyCode}
 Output\+: わたし　わ　エドワド　オ’ハゲン　です。　これ　は　なん　です　か？


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
 & {\em num\+Bytes\+To\+Read} & The size of the buffer (the number bytes read in). If 0; num\+Bytes\+To\+Read = max\+Buffer\+Size. \\
\hline
 & {\em max\+Buffer\+Size} & Maximum number of bytes to read. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}r\char`\"{} for read, \char`\"{}r, ccs=\+U\+T\+F-\/8\char`\"{} for read unicode, \char`\"{}r+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Either zero, or a value returned by ftell(). \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The buffer containing the file data of size num\+Bytes\+To\+Read. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remainder@{Remainder}}
\index{Remainder@{Remainder}!Ace@{Ace}}
\subsubsection[{Remainder(double numerator, double denominator)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Remainder (
\begin{DoxyParamCaption}
\item[{double}]{numerator, }
\item[{double}]{denominator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0f05443f499ce94d53c3a5e584460d52}


Calculates the Computes The I\+E\+EE remainder of the floating point division operation numerator/denominator. 

In contrast to \doxyref{Mod()}{p.}{class_ace_a6529499a01bc16109f19ebcb719019f7}; the returned value is not guaranteed to have the same sign as the numerator. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::Remainder(-5.1, 3.2);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 1.\+300000


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The I\+E\+EE remainder of the floating point division. If a mathematical error occurs or denominator equals 0, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remainder@{Remainder}}
\index{Remainder@{Remainder}!Ace@{Ace}}
\subsubsection[{Remainder(float numerator, float denominator)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Remainder (
\begin{DoxyParamCaption}
\item[{float}]{numerator, }
\item[{float}]{denominator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af4dcc33bb8d85f3b654edbcb0912f88b}


Calculates the Computes The I\+E\+EE remainder of the floating point division operation numerator/denominator. 

In contrast to \doxyref{Mod()}{p.}{class_ace_a6529499a01bc16109f19ebcb719019f7}; the returned value is not guaranteed to have the same sign as the numerator. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::Remainder(-5.1f, 3.2f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 1.\+300000


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The I\+E\+EE remainder of the floating point division. If a mathematical error occurs or denominator equals 0, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remainder\+With\+Quadrant@{Remainder\+With\+Quadrant}}
\index{Remainder\+With\+Quadrant@{Remainder\+With\+Quadrant}!Ace@{Ace}}
\subsubsection[{Remainder\+With\+Quadrant(double numerator, double denominator, int $\ast$out\+Quadrant)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Remainder\+With\+Quadrant (
\begin{DoxyParamCaption}
\item[{double}]{numerator, }
\item[{double}]{denominator, }
\item[{int $\ast$}]{out\+Quadrant}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a83c9c251b60c0becf2ff3b5f6fc3f0ab}


Calculates the floating-\/point remainder of the division operation numerator/denominator the same way the \doxyref{Remainder()}{p.}{class_ace_a0f05443f499ce94d53c3a5e584460d52} function does. 

Additionally, the sign and at least the three of the last bits of numerator/denominator will be stored in out\+Quadrant, sufficient to determine the quadrant of the result within a period. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} quadrant;
\textcolor{keywordtype}{double} result = Ace::RemainderWithQuadrant(-5.1, 3.2, &quadrant);
quadrant = (\textcolor{keywordtype}{unsigned} int)quadrant % 4;
printf(\textcolor{stringliteral}{"%f Quadrant:%d\(\backslash\)n"}, result, quadrant);
\end{DoxyCode}
 Output\+: 1.\+300000 Quadrant\+:2


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by. \\
\hline
{\em out\+Quadrant} & Sign to indicate the quadrant.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The I\+E\+EE remainder of the floating point division and the quadrant data. If a mathematical error occurs or denominator equals 0, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remainder\+With\+Quadrant@{Remainder\+With\+Quadrant}}
\index{Remainder\+With\+Quadrant@{Remainder\+With\+Quadrant}!Ace@{Ace}}
\subsubsection[{Remainder\+With\+Quadrant(float numerator, float denominator, int $\ast$out\+Quadrant)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Remainder\+With\+Quadrant (
\begin{DoxyParamCaption}
\item[{float}]{numerator, }
\item[{float}]{denominator, }
\item[{int $\ast$}]{out\+Quadrant}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9aeabf43c45659c6024a4dce1ae2a1cc}


Calculates the floating-\/point remainder of the division operation numerator/denominator the same way the \doxyref{Remainder()}{p.}{class_ace_a0f05443f499ce94d53c3a5e584460d52} function does. 

Additionally, the sign and at least the three of the last bits of numerator/denominator will be stored in out\+Quadrant, sufficient to determine the quadrant of the result within a period. Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} quadrant;
\textcolor{keywordtype}{float} result = Ace::RemainderWithQuadrant(-5.1f, 3.2f, &quadrant);
quadrant = (\textcolor{keywordtype}{unsigned} int)quadrant % 4;
printf(\textcolor{stringliteral}{"%f Quadrant:%d\(\backslash\)n"}, result, quadrant);
\end{DoxyCode}
 Output\+: 1.\+300000 Quadrant\+:2


\begin{DoxyParams}{Parameters}
{\em numerator} & Number to be divided. \\
\hline
{\em denominator} & Number to divide the numerator by. \\
\hline
{\em out\+Quadrant} & Sign to indicate the quadrant.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The I\+E\+EE remainder of the floating point division and the quadrant data. If a mathematical error occurs or denominator equals 0, then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+All\+Whitespace@{Remove\+All\+Whitespace}}
\index{Remove\+All\+Whitespace@{Remove\+All\+Whitespace}!Ace@{Ace}}
\subsubsection[{Remove\+All\+Whitespace(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Remove\+All\+Whitespace (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae41b2d2f89451e9659550845170d328a}


Removes all whitespace from a given string. 

A newly allocated string is returned that has all whitespace removed from it.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* temp = Ace::RemoveAllWhitespace(\textcolor{stringliteral}{"E dd\(\backslash\)t i  e "});
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, temp);
\_aligned\_free(temp);
\end{DoxyCode}
 Output\+:Eddie


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to remove whitespace from.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string containing no whitespace. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+All\+Whitespace@{Remove\+All\+Whitespace}}
\index{Remove\+All\+Whitespace@{Remove\+All\+Whitespace}!Ace@{Ace}}
\subsubsection[{Remove\+All\+Whitespace(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Remove\+All\+Whitespace (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a869247b2abaeca31aff7e12d030e0872}


Removes all whitespace from a given wide string. 

A newly allocated string is returned that has all whitespace removed from it.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* temp = Ace::RemoveAllWhitespace(L\textcolor{stringliteral}{"E dd\(\backslash\)t i  e "});
printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, temp);
\_aligned\_free(temp);
\end{DoxyCode}
 Output\+:Eddie


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to remove whitespace from.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string containing no whitespace. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+All\+Whitespace\+In\+Place@{Remove\+All\+Whitespace\+In\+Place}}
\index{Remove\+All\+Whitespace\+In\+Place@{Remove\+All\+Whitespace\+In\+Place}!Ace@{Ace}}
\subsubsection[{Remove\+All\+Whitespace\+In\+Place(char $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Remove\+All\+Whitespace\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a916dc3ddc85c0c5ad3840dfab4962f9e}


Removes all whitespace from a given string in place. 

This means That str is modified directly and as a result, no return value is needed. Assumes str is an allocated string and not a string literal.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* temp = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"E dd\(\backslash\)t i  e "});
Ace::RemoveAllWhitespaceInPlace(temp);
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, temp);
\_aligned\_free(temp);
\end{DoxyCode}
 Output\+:Eddie


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str} & The string to directly modify and delete whitespace from. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Remove\+All\+Whitespace\+In\+Place@{Remove\+All\+Whitespace\+In\+Place}}
\index{Remove\+All\+Whitespace\+In\+Place@{Remove\+All\+Whitespace\+In\+Place}!Ace@{Ace}}
\subsubsection[{Remove\+All\+Whitespace\+In\+Place(wchar\+\_\+t $\ast$str)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Remove\+All\+Whitespace\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aef98302ca6ffca2bf6ed13fd0f887a5d}


Removes all whitespace from a given wide string in place. 

This means That str is modified directly and as a result, no return value is needed. Assumes str is an allocated string and not a string literal.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* temp = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"E dd\(\backslash\)t i  e "});
Ace::RemoveAllWhitespaceInPlace(temp);
printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, temp);
\_aligned\_free(temp);
\end{DoxyCode}
 Output\+:Eddie


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str} & The wide string to directly modify and delete whitespace from. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Remove\+Characters\+From\+String@{Remove\+Characters\+From\+String}}
\index{Remove\+Characters\+From\+String@{Remove\+Characters\+From\+String}!Ace@{Ace}}
\subsubsection[{Remove\+Characters\+From\+String(char $\ast$str\+To\+Remove\+From, char char\+To\+Remove)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Remove\+Characters\+From\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Remove\+From, }
\item[{char}]{char\+To\+Remove}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac4f88cf4ac3842c748ed4222bf885660}


Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/12/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{char}* removedCharData = Ace::RemoveCharactersFromString(data, \textcolor{charliteral}{'a'});
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, removedCharData);
\_aligned\_free(removedCharData);
\end{DoxyCode}
 Output\+:Hs nyone ever been s fr s decided to be there nd then look more like?


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Remove\+From} & If non-\/null, to remove from. \\
\hline
 & {\em char\+To\+Remove} & The character to remove.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string with every occurrence of char\+To\+Remove removed. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+Characters\+From\+String@{Remove\+Characters\+From\+String}}
\index{Remove\+Characters\+From\+String@{Remove\+Characters\+From\+String}!Ace@{Ace}}
\subsubsection[{Remove\+Characters\+From\+String(wchar\+\_\+t $\ast$str\+To\+Remove\+From, wchar\+\_\+t char\+To\+Remove)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Remove\+Characters\+From\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Remove\+From, }
\item[{wchar\+\_\+t}]{char\+To\+Remove}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a517caf5b3abb9d9480f654afa2e9c121}


Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and then look more like?"};
\textcolor{keywordtype}{wchar\_t}* removedCharData = Ace::RemoveCharactersFromString(data, L\textcolor{charliteral}{'a'});
printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, removedCharData);
\_aligned\_free(removedCharData);
\end{DoxyCode}
 Output\+:Hs nyone ever been s fr s decided to be there nd then look more like?


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Remove\+From} & If non-\/null, to remove from. \\
\hline
 & {\em char\+To\+Remove} & The character to remove.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string with every occurrence of char\+To\+Remove removed. 
\end{DoxyReturn}
\index{Ace@{Ace}!Remove\+Characters\+From\+String\+In\+Place@{Remove\+Characters\+From\+String\+In\+Place}}
\index{Remove\+Characters\+From\+String\+In\+Place@{Remove\+Characters\+From\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Remove\+Characters\+From\+String\+In\+Place(char $\ast$str\+To\+Remove\+From, char char\+To\+Remove)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Remove\+Characters\+From\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Remove\+From, }
\item[{char}]{char\+To\+Remove}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7a4f21e66792a5813fc50775ae75091c}


Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. 

str\+To\+Remove\+From must be an allocated string since this function works directly on it.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/12/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* removedCharData = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there and
       then look more like?"});
Ace::RemoveCharactersFromStringInPlace(removedCharData, \textcolor{charliteral}{'a'});
printf(\textcolor{stringliteral}{"%s"}, removedCharData);
\_aligned\_free(removedCharData);
\end{DoxyCode}
 Output\+:Hs nyone ever been s fr s decided to be there nd then look more like?


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Remove\+From} & If non-\/null, to remove from. \\
\hline
 & {\em char\+To\+Remove} & The character to remove. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Remove\+Characters\+From\+String\+In\+Place@{Remove\+Characters\+From\+String\+In\+Place}}
\index{Remove\+Characters\+From\+String\+In\+Place@{Remove\+Characters\+From\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Remove\+Characters\+From\+String\+In\+Place(wchar\+\_\+t $\ast$str\+To\+Remove\+From, wchar\+\_\+t char\+To\+Remove)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Remove\+Characters\+From\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Remove\+From, }
\item[{wchar\+\_\+t}]{char\+To\+Remove}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8b4630bd6fd620f1f9724a100f28acad}


Removes any occurrence of char\+To\+Remove from str\+To\+Remove\+From. 

str\+To\+Remove\+From must be an allocated string since this function works directly on it.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* removedCharData = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"Has anyone ever been as far as decided to be there
       and then look more like?"});
Ace::RemoveCharactersFromStringInPlace(removedCharData, L\textcolor{charliteral}{'a'});
printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, removedCharData);
\_aligned\_free(removedCharData);
\end{DoxyCode}
 Output\+:Hs nyone ever been s fr s decided to be there nd then look more like?


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Remove\+From} & If non-\/null, to remove from. \\
\hline
 & {\em char\+To\+Remove} & The character to remove. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Replace\+String@{Replace\+String}}
\index{Replace\+String@{Replace\+String}!Ace@{Ace}}
\subsubsection[{Replace\+String(char $\ast$str\+To\+Search, char $\ast$str\+To\+Look\+For, char $\ast$str\+To\+Replace\+With)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Replace\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For, }
\item[{char $\ast$}]{str\+To\+Replace\+With}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aefcffafee15c9948c5bb0bac1173f770}


Inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. 

A newly allocated string is then returned.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = Ace::ReplaceString(\textcolor{stringliteral}{"Eddie is cool."}, \textcolor{stringliteral}{"is"}, \textcolor{stringliteral}{"is not"});
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:Eddie is not cool.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & The string to look through. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & The substring to look for. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Replace\+With} & The substring to replace with.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string with the change. 
\end{DoxyReturn}
\index{Ace@{Ace}!Replace\+String@{Replace\+String}}
\index{Replace\+String@{Replace\+String}!Ace@{Ace}}
\subsubsection[{Replace\+String(wchar\+\_\+t $\ast$str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For, wchar\+\_\+t $\ast$str\+To\+Replace\+With)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Replace\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Replace\+With}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a1dd586fdf352bde19e0d3c2e72eecac8}


Inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. 

A newly allocated wide string is then returned.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = Ace::ReplaceString(L\textcolor{stringliteral}{"Eddie is cool."}, L\textcolor{stringliteral}{"is"}, L\textcolor{stringliteral}{"is not"});
printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:Eddie is not cool.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Search} & The wide string to look through. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & The substring to look for. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Replace\+With} & The substring to replace with.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created wide string with the change. 
\end{DoxyReturn}
\index{Ace@{Ace}!Replace\+String\+In\+Place@{Replace\+String\+In\+Place}}
\index{Replace\+String\+In\+Place@{Replace\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Replace\+String\+In\+Place(char $\ast$\&str\+To\+Search, char $\ast$str\+To\+Look\+For, char $\ast$str\+To\+Replace\+With)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Replace\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$\&}]{str\+To\+Search, }
\item[{char $\ast$}]{str\+To\+Look\+For, }
\item[{char $\ast$}]{str\+To\+Replace\+With}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a4f524383b4ee4eadd4263824ed189790}


Directly modifies and inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. 

Since str\+To\+Search is modified directly, there is no return value. data is re-\/allocated in order to hold the replacement string.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"Eddie is cool."});
Ace::ReplaceStringInPlace(data, \textcolor{stringliteral}{"is"}, \textcolor{stringliteral}{"is not"});
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:Eddie is not cool.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Search} & The string to directly parse and modify. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & The substring to look for. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Replace\+With} & The substring to replace with. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Replace\+String\+In\+Place@{Replace\+String\+In\+Place}}
\index{Replace\+String\+In\+Place@{Replace\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Replace\+String\+In\+Place(wchar\+\_\+t $\ast$\&str\+To\+Search, wchar\+\_\+t $\ast$str\+To\+Look\+For, wchar\+\_\+t $\ast$str\+To\+Replace\+With)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Replace\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$\&}]{str\+To\+Search, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Look\+For, }
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Replace\+With}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8445bd902361e3c05edf04cce65949fe}


Directly modifies and inserts str\+To\+Replace\+With in the position str\+To\+Look\+For is located, then str\+To\+Look\+For is removed. 

Since str\+To\+Search is modified directly, there is no return value. data is re-\/allocated in order to hold the replacement wide string.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"Eddie is cool."});
Ace::ReplaceStringInPlace(data, L\textcolor{stringliteral}{"is"}, L\textcolor{stringliteral}{"is not"});
printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:Eddie is not cool.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Search} & The wide string to directly parse and modify. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Look\+For} & The substring to look for. \\
\hline
\mbox{\tt in}  & {\em str\+To\+Replace\+With} & The substring to replace with. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}}
\index{Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}!Ace@{Ace}}
\subsubsection[{Retrieve\+Data\+Between\+Tags(char $\ast$file\+Data, char $\ast$start\+Tag, char $\ast$end\+Tag)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Retrieve\+Data\+Between\+Tags (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Data, }
\item[{char $\ast$}]{start\+Tag, }
\item[{char $\ast$}]{end\+Tag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a15c42f6a53a7eaaf7a33b62d0cf3d015}


Finds the X\+ML data between the start\+Tag and end\+Tag and returns it. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = Ace::RetrieveFileData(C:\(\backslash\)\(\backslash\)Config.xml, \textcolor{keyword}{false});
\textcolor{keywordtype}{char}* tagData = Ace::RetrieveDataBetweenTags(data, \textcolor{stringliteral}{"<position>"}, \textcolor{stringliteral}{"</position>"});
printf(\textcolor{stringliteral}{"Data between tags:%s\(\backslash\)n"}, tagData);
\_aligned\_free(tagData);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:0.\+1, 2.\+3, 2.\+2


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Data} & A string containing the data to be parsed. \\
\hline
\mbox{\tt in}  & {\em start\+Tag} & A string representing the tag to start from. \\
\hline
\mbox{\tt in}  & {\em end\+Tag} & A string representing the tag to end on.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A Buffer containing the data between start\+Tag + start\+Tag.\+length() and end\+Tag. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}}
\index{Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}!Ace@{Ace}}
\subsubsection[{Retrieve\+Data\+Between\+Tags(wchar\+\_\+t $\ast$file\+Data, wchar\+\_\+t $\ast$start\+Tag, wchar\+\_\+t $\ast$end\+Tag)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Retrieve\+Data\+Between\+Tags (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Data, }
\item[{wchar\+\_\+t $\ast$}]{start\+Tag, }
\item[{wchar\+\_\+t $\ast$}]{end\+Tag}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad3a908a447d305f769bd40af461e48e5}


Finds the X\+ML data between the start\+Tag and end\+Tag and returns it. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = Ace::RetrieveFileData(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Config.xml"}, \textcolor{keyword}{false});
\textcolor{keywordtype}{wchar\_t}* tagData = Ace::RetrieveDataBetweenTags(data, L\textcolor{stringliteral}{"<position>"}, L\textcolor{stringliteral}{"</position>"});
printf(\textcolor{stringliteral}{"Data between tags:%S\(\backslash\)n"}, tagData);
\_aligned\_free(tagData);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:0.\+1, 2.\+3, 2.\+2


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Data} & A string containing the data to be parsed. \\
\hline
\mbox{\tt in}  & {\em start\+Tag} & A string representing the tag to start from. \\
\hline
\mbox{\tt in}  & {\em end\+Tag} & A string representing the tag to end on.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A Buffer containing the data between start\+Tag + start\+Tag.\+length() and end\+Tag. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}}
\index{Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}!Ace@{Ace}}
\subsubsection[{Retrieve\+Data\+Between\+Tags(char $\ast$file\+Data, int start\+Tag\+Index, int end\+Tag\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Retrieve\+Data\+Between\+Tags (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Data, }
\item[{int}]{start\+Tag\+Index, }
\item[{int}]{end\+Tag\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac7c2687eabb6302150a0ef33dcc1e6c1}


Finds the X\+ML data between the start\+Tag\+Index and end\+Tag\+Index and returns it. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = Ace::RetrieveFileData(vertShaderPath, \textcolor{keyword}{false});
\textcolor{keywordtype}{int} startIndex = Ace::IndexOf(data, \textcolor{stringliteral}{"<position>"}) + strlen(\textcolor{stringliteral}{"<position>"});
\textcolor{keywordtype}{int} endIndex = Ace::IndexOf(data, \textcolor{stringliteral}{"</position>"});
\textcolor{keywordtype}{char}* tagData = Ace::RetrieveDataBetweenTags(data, startIndex, endIndex);
printf(\textcolor{stringliteral}{"Data between tags:%s\(\backslash\)n"}, tagData);
\_aligned\_free(tagData);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:0.\+1, 2.\+3, 2.\+2


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Data} & A string containing the data to be parsed. \\
\hline
\mbox{\tt in}  & {\em start\+Tag\+Index} & Index of where to start reading in. \\
\hline
\mbox{\tt in}  & {\em end\+Tag\+Index} & Index of where to end reading data.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A Buffer containing the data between start\+Tag\+Index and end\+Tag\+Index. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}}
\index{Retrieve\+Data\+Between\+Tags@{Retrieve\+Data\+Between\+Tags}!Ace@{Ace}}
\subsubsection[{Retrieve\+Data\+Between\+Tags(wchar\+\_\+t $\ast$file\+Data, int start\+Tag\+Index, int end\+Tag\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Retrieve\+Data\+Between\+Tags (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Data, }
\item[{int}]{start\+Tag\+Index, }
\item[{int}]{end\+Tag\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac33be815c3d923b322217d9822471680}


Finds the X\+ML data between the start\+Tag\+Index and end\+Tag\+Index and returns it. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* filePath = L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Config.xml"};
\textcolor{keywordtype}{wchar\_t}* data = Ace::RetrieveFileData(filePath, \textcolor{keyword}{false});
\textcolor{keywordtype}{int} startIndex = Ace::IndexOf(data, L\textcolor{stringliteral}{"<position>"}) + wcslen(L\textcolor{stringliteral}{"<position>"});
\textcolor{keywordtype}{int} endIndex = Ace::IndexOf(data, L\textcolor{stringliteral}{"</position>"});
\textcolor{keywordtype}{wchar\_t}* tagData = Ace::RetrieveDataBetweenTags(data, startIndex, endIndex);
printf(\textcolor{stringliteral}{"Data between tags:%S\(\backslash\)n"}, tagData);
\_aligned\_free(tagData);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:0.\+1, 2.\+3, 2.\+2


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Data} & A wide string containing the data to be parsed. \\
\hline
\mbox{\tt in}  & {\em start\+Tag\+Index} & Index of where to start reading in. \\
\hline
\mbox{\tt in}  & {\em end\+Tag\+Index} & Index of where to end reading data.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A Buffer containing the data between start\+Tag\+Index and end\+Tag\+Index. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Data\+Chunks\+Between\+Tags@{Retrieve\+Data\+Chunks\+Between\+Tags}}
\index{Retrieve\+Data\+Chunks\+Between\+Tags@{Retrieve\+Data\+Chunks\+Between\+Tags}!Ace@{Ace}}
\subsubsection[{Retrieve\+Data\+Chunks\+Between\+Tags(char $\ast$file\+Data, char $\ast$start\+Tag, char $\ast$end\+Tag, int \&out\+Final\+Buffer\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$$\ast$ Ace\+::\+Retrieve\+Data\+Chunks\+Between\+Tags (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Data, }
\item[{char $\ast$}]{start\+Tag, }
\item[{char $\ast$}]{end\+Tag, }
\item[{int \&}]{out\+Final\+Buffer\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a639fcb40de735847ee36b09ebaf58243}


Finds a series of X\+ML data between start\+Tag and end\+Tag. 

For example, if we were reading in an X\+ML file that looked like this\+: $<$\+Models$>$ $<$\+Model$>$ $<$position$>$0.\+1, 2.\+3, 2.\+2$<$/position$>$ $<$rotation$>$20.\+0, 0.\+0, 0.\+0, 1.\+0$<$/rotation$>$ $<$/\+Model$>$ $<$\+Model$>$ $<$position$>$3.\+0, 4.\+0, 5.\+0$<$/position$>$ $<$rotation$>$0.\+0, 30.\+0, 0.\+0, 1.\+0$<$/rotation$>$ $<$/\+Model$>$ $<$/\+Models$>$

And the start and end tags were \char`\"{}$<$\+Model$>$\char`\"{} and \char`\"{}$<$/\+Model$>$\char`\"{} respectively; then the function will return an array containing\+: Array[0]=\char`\"{}$<$position$>$0.\+1, 2.\+3, 2.\+2$<$/position$>$
          $<$rotation$>$20.\+0, 0.\+0, 0.\+0, 1.\+0$<$/rotation$>$\char`\"{}

Array[1]=\char`\"{}$<$position$>$1.\+0, 2.\+0, 0.\+0$<$/position$>$
          $<$rotation$>$20.\+0, 0.\+0, 0.\+0, 1.\+0$<$/rotation$>$\char`\"{}

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = Ace::RetrieveFileData(vertShaderPath, \textcolor{keyword}{false});
\textcolor{keywordtype}{int} tagDataSize = 0;
\textcolor{keywordtype}{char}** tagData = Ace::RetrieveDataChunksBetweenTags(data, \textcolor{stringliteral}{"<Model>"}, \textcolor{stringliteral}{"</Model>"}, tagDataSize);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < tagDataSize; currIndex++)
\{
    printf(\textcolor{stringliteral}{"Array[%d]:%s\(\backslash\)n"}, currIndex, tagData[currIndex]);
    \_aligned\_free(tagData[currIndex]);
\}
\_aligned\_free(tagData);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:(\+Displayed Above)


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Data} & A string containing the data to be parsed. \\
\hline
\mbox{\tt in}  & {\em start\+Tag} & A string representing the tag to start from. \\
\hline
\mbox{\tt in}  & {\em end\+Tag} & A string representing the tag to end on. \\
\hline
\mbox{\tt out}  & {\em out\+Final\+Buffer\+Size} & Size of the out final buffer.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly allocated string array containing the data between each start\+Tag and end\+Tag found. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Data\+Chunks\+Between\+Tags@{Retrieve\+Data\+Chunks\+Between\+Tags}}
\index{Retrieve\+Data\+Chunks\+Between\+Tags@{Retrieve\+Data\+Chunks\+Between\+Tags}!Ace@{Ace}}
\subsubsection[{Retrieve\+Data\+Chunks\+Between\+Tags(wchar\+\_\+t $\ast$file\+Data, wchar\+\_\+t $\ast$start\+Tag, wchar\+\_\+t $\ast$end\+Tag, int \&out\+Final\+Buffer\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$$\ast$ Ace\+::\+Retrieve\+Data\+Chunks\+Between\+Tags (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Data, }
\item[{wchar\+\_\+t $\ast$}]{start\+Tag, }
\item[{wchar\+\_\+t $\ast$}]{end\+Tag, }
\item[{int \&}]{out\+Final\+Buffer\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_afc8d972571ec5b22f6a8553ac324fc3f}


Finds a series of X\+ML data between start\+Tag and end\+Tag. 

For example, if we were reading in an X\+ML file that looked like this\+: $<$\+Models$>$ $<$\+Model$>$ $<$position$>$0.\+1, 2.\+3, 2.\+2$<$/position$>$ $<$rotation$>$20.\+0, 0.\+0, 0.\+0, 1.\+0$<$/rotation$>$ $<$/\+Model$>$ $<$\+Model$>$ $<$position$>$3.\+0, 4.\+0, 5.\+0$<$/position$>$ $<$rotation$>$0.\+0, 30.\+0, 0.\+0, 1.\+0$<$/rotation$>$ $<$/\+Model$>$ $<$/\+Models$>$

And the start and end tags were \char`\"{}$<$\+Model$>$\char`\"{} and \char`\"{}$<$/\+Model$>$\char`\"{} respectively; then the function will return an array containing\+: Array[0]=\char`\"{}$<$position$>$0.\+1, 2.\+3, 2.\+2$<$/position$>$
          $<$rotation$>$20.\+0, 0.\+0, 0.\+0, 1.\+0$<$/rotation$>$\char`\"{}

Array[1]=\char`\"{}$<$position$>$1.\+0, 2.\+0, 0.\+0$<$/position$>$
          $<$rotation$>$20.\+0, 0.\+0, 0.\+0, 1.\+0$<$/rotation$>$\char`\"{}

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* filePath = L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Config.xml"};
\textcolor{keywordtype}{wchar\_t}* data = Ace::RetrieveFileData(filePath, \textcolor{keyword}{false});
\textcolor{keywordtype}{int} tagDataSize = 0;
\textcolor{keywordtype}{wchar\_t}** tagData = Ace::RetrieveDataChunksBetweenTags(data, L\textcolor{stringliteral}{"<Model>"}, L\textcolor{stringliteral}{"</Model>"}, tagDataSize);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < tagDataSize; currIndex++)
\{
    printf(\textcolor{stringliteral}{"Array[%d]:%S\(\backslash\)n"}, currIndex, tagData[currIndex]);
    \_aligned\_free(tagData[currIndex]);
\}
\_aligned\_free(tagData);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:(\+Displayed Above)


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Data} & A wide string containing the data to be parsed. \\
\hline
\mbox{\tt in}  & {\em start\+Tag} & A wide string representing the tag to start from. \\
\hline
\mbox{\tt in}  & {\em end\+Tag} & A wide string representing the tag to end on. \\
\hline
\mbox{\tt out}  & {\em out\+Final\+Buffer\+Size} & Size of the out final buffer.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly allocated wide string array containing the data between each start\+Tag and end\+Tag found. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+File\+Names@{Retrieve\+File\+Names}}
\index{Retrieve\+File\+Names@{Retrieve\+File\+Names}!Ace@{Ace}}
\subsubsection[{Retrieve\+File\+Names(char $\ast$full\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ char $\ast$ $>$ Ace\+::\+Retrieve\+File\+Names (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{full\+File\+Path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a1126579b6ddd052f90e987ef056fad70}


Returns all the names of the files inside a folder, Ignores non files like folders. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
7/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* imageFilePath = \textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Images\(\backslash\)\(\backslash\)180Panoramic"};
vector<char*> fileNames = Ace::RetrieveFileNames(imageFilePath);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < fileNames.size(); i++)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, fileNames[i]);
    \_aligned\_free(fileNames[i]);
\}
\end{DoxyCode}
 Output\+:sky.\+jpg mountans.\+png tits.\+gtfo dontread.\+txt


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em full\+File\+Path} & Directory to look inside.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector array containing all the file names in the folder. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+File\+Names@{Retrieve\+File\+Names}}
\index{Retrieve\+File\+Names@{Retrieve\+File\+Names}!Ace@{Ace}}
\subsubsection[{Retrieve\+File\+Names(wchar\+\_\+t $\ast$full\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ wchar\+\_\+t $\ast$ $>$ Ace\+::\+Retrieve\+File\+Names (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{full\+File\+Path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5ade52ee2c4a73cb571a27f71cd91028}


Returns all the names of the files inside a folder, Ignores non files like folders. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* imageFilePath = L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Users\(\backslash\)\(\backslash\)Eddie\(\backslash\)\(\backslash\)Desktop\(\backslash\)\(\backslash\)KatianieWorkspace\(\backslash\)\(\backslash\)PanoramicVR\(\backslash\)\(\backslash\)Images\(\backslash\)\(\backslash\)180Panoramic"}
      ;
vector<wchar\_t*> fileNames = Ace::RetrieveFileNames(imageFilePath);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < fileNames.size(); i++)
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, fileNames[i]);
    \_aligned\_free(fileNames[i]);
\}
\end{DoxyCode}
 Output\+:sky.\+jpg mountans.\+png tits.\+gtfo dontread.\+txt


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em full\+File\+Path} & Directory to look inside.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector array containing all the file names in the folder. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Folder\+Names@{Retrieve\+Folder\+Names}}
\index{Retrieve\+Folder\+Names@{Retrieve\+Folder\+Names}!Ace@{Ace}}
\subsubsection[{Retrieve\+Folder\+Names(char $\ast$full\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ char $\ast$ $>$ Ace\+::\+Retrieve\+Folder\+Names (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{full\+File\+Path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5336deec9aeb39d6239b5ce09a396e80}


Returns all the names of the sub-\/folder(s) in a folder. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
6/1/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* imageFilePath = \textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Images\(\backslash\)\(\backslash\)"};
vector<char*> folderNames = Ace::RetrieveFolderNames(imageFilePath);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < folderNames.size(); i++)
\{
    printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, folderNames[i]);
    \_aligned\_free(folderNames[i]);
\}
\end{DoxyCode}
 Output\+:180 panoramics 360 panoramics photospheres


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em full\+File\+Path} & Directory to look inside.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector array containing all the sub-\/folder names in the folder. 
\end{DoxyReturn}
\index{Ace@{Ace}!Retrieve\+Folder\+Names@{Retrieve\+Folder\+Names}}
\index{Retrieve\+Folder\+Names@{Retrieve\+Folder\+Names}!Ace@{Ace}}
\subsubsection[{Retrieve\+Folder\+Names(wchar\+\_\+t $\ast$full\+File\+Path)}]{\setlength{\rightskip}{0pt plus 5cm}vector$<$ wchar\+\_\+t $\ast$ $>$ Ace\+::\+Retrieve\+Folder\+Names (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{full\+File\+Path}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0d676a65bbb1f524cd6b0d0ac3f99013}


Returns all the names of the sub-\/folder(s) in a folder. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* imageFilePath = L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)Users\(\backslash\)\(\backslash\)Eddie\(\backslash\)\(\backslash\)Desktop\(\backslash\)\(\backslash\)KatianieWorkspace\(\backslash\)\(\backslash\)PanoramicVR\(\backslash\)\(\backslash\)Images\(\backslash\)\(\backslash\)"};
vector<wchar\_t*> folderNames = Ace::RetrieveFolderNames(imageFilePath);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < folderNames.size(); i++)
\{
    printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, folderNames[i]);
    \_aligned\_free(folderNames[i]);
\}
\end{DoxyCode}
 Output\+:180 panoramics 360 panoramics photospheres


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em full\+File\+Path} & Directory to look inside.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A vector array containing all the sub-\/folder names in the folder. 
\end{DoxyReturn}
\index{Ace@{Ace}!Reverse\+String@{Reverse\+String}}
\index{Reverse\+String@{Reverse\+String}!Ace@{Ace}}
\subsubsection[{Reverse\+String(char $\ast$str\+To\+Reverse)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Reverse\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Reverse}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_acebc93fbbb2ead1c7177b42b64826b00}


Creates a new string containing all the characters from str\+To\+Reverse in reverse order. 

For example\+: \char`\"{}\+A\+B\+C\+D\+E\+F\char`\"{} will return \char`\"{}\+F\+E\+D\+C\+B\+A\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = Ace::ReverseString(\textcolor{stringliteral}{"ABCDEF"});
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:F\+E\+D\+C\+BA


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Reverse} & A string to reverse.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string containing the reverse of str\+To\+Reverse. 
\end{DoxyReturn}
\index{Ace@{Ace}!Reverse\+String@{Reverse\+String}}
\index{Reverse\+String@{Reverse\+String}!Ace@{Ace}}
\subsubsection[{Reverse\+String(wchar\+\_\+t $\ast$str\+To\+Reverse)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Reverse\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Reverse}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a310c25048fb63e5c43134c894eb71369}


Creates a new wide string containing all the characters from str\+To\+Reverse in reverse order. 

For example\+: \char`\"{}\+A\+B\+C\+D\+E\+F\char`\"{} will return \char`\"{}\+F\+E\+D\+C\+B\+A\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = Ace::ReverseString(L\textcolor{stringliteral}{"ABCDEF"});
printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:F\+E\+D\+C\+BA


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str\+To\+Reverse} & A wide string to reverse.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created wide string containing the reverse of str\+To\+Reverse. 
\end{DoxyReturn}
\index{Ace@{Ace}!Reverse\+String\+In\+Place@{Reverse\+String\+In\+Place}}
\index{Reverse\+String\+In\+Place@{Reverse\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Reverse\+String\+In\+Place(char $\ast$str\+To\+Reverse)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Reverse\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Reverse}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9bd246903778d20a982765bea54ec8f4}


Directly modifies str\+To\+Reverse to have all its characters in reverse order. 

For example\+: \char`\"{}\+A\+B\+C\+D\+E\+F\char`\"{} will return \char`\"{}\+F\+E\+D\+C\+B\+A\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* data = (\textcolor{keywordtype}{char}*)Ace::AllocateAndCopyString(\textcolor{stringliteral}{"ABCDEF"});
Ace::ReverseStringInPlace(data);
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:(\+Displayed above)


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Reverse} & A preallocated string to reverse. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Reverse\+String\+In\+Place@{Reverse\+String\+In\+Place}}
\index{Reverse\+String\+In\+Place@{Reverse\+String\+In\+Place}!Ace@{Ace}}
\subsubsection[{Reverse\+String\+In\+Place(wchar\+\_\+t $\ast$str\+To\+Reverse)}]{\setlength{\rightskip}{0pt plus 5cm}void Ace\+::\+Reverse\+String\+In\+Place (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Reverse}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a1b0e0afa5c975cc03845b6a79331f228}


Directly modifies str\+To\+Reverse to have all its characters in reverse order. 

For example\+: \char`\"{}\+A\+B\+C\+D\+E\+F\char`\"{} will return \char`\"{}\+F\+E\+D\+C\+B\+A\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* data = (\textcolor{keywordtype}{wchar\_t}*)Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"ABCDEF"});
Ace::ReverseStringInPlace(data);
printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, data);
\_aligned\_free(data);
\end{DoxyCode}
 Output\+:(\+Displayed above)


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Reverse} & A preallocated string to reverse. \\
\hline
\end{DoxyParams}
\index{Ace@{Ace}!Round\+To\+Nearest\+Integer@{Round\+To\+Nearest\+Integer}}
\index{Round\+To\+Nearest\+Integer@{Round\+To\+Nearest\+Integer}!Ace@{Ace}}
\subsubsection[{Round\+To\+Nearest\+Integer(double num)}]{\setlength{\rightskip}{0pt plus 5cm}long Ace\+::\+Round\+To\+Nearest\+Integer (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7bf2286843651fe1cd72b037a1030320}


Rounds the floating-\/point argument num to an integer value, using the current rounding mode. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{long} result = Ace::RoundToNearestInteger(3.5);
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 4


\begin{DoxyParams}{Parameters}
{\em num} & Number to round.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The num rounded using the current rounding mode. If a mathematical error occurs then -\/1 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Round\+To\+Nearest\+Integer@{Round\+To\+Nearest\+Integer}}
\index{Round\+To\+Nearest\+Integer@{Round\+To\+Nearest\+Integer}!Ace@{Ace}}
\subsubsection[{Round\+To\+Nearest\+Integer(float num)}]{\setlength{\rightskip}{0pt plus 5cm}long Ace\+::\+Round\+To\+Nearest\+Integer (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a892854a0074451f70c0bfa9568b7c7eb}


Rounds the floating-\/point argument num to an integer value, using the current rounding mode. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{long} result = Ace::RoundToNearestInteger(3.5f);
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 4


\begin{DoxyParams}{Parameters}
{\em num} & Number to round.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The num rounded using the current rounding mode. If a mathematical error occurs then -\/1 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Round\+Up@{Round\+Up}}
\index{Round\+Up@{Round\+Up}!Ace@{Ace}}
\subsubsection[{Round\+Up(double num)}]{\setlength{\rightskip}{0pt plus 5cm}long Ace\+::\+Round\+Up (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a020fc7df33dce4679ed8a392da725b8b}


Calculates the nearest integer value to num (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{long} result = Ace::RoundUp(3.5);
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 4


\begin{DoxyParams}{Parameters}
{\em num} & Number to round.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The nearest integer value to num, rounding halfway cases away from zero. If a mathematical error occurs then -\/1 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Round\+Up@{Round\+Up}}
\index{Round\+Up@{Round\+Up}!Ace@{Ace}}
\subsubsection[{Round\+Up(float num)}]{\setlength{\rightskip}{0pt plus 5cm}long Ace\+::\+Round\+Up (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5feb3de75f4f946d79f4ff56389f93cd}


Calculates the nearest integer value to num (in integer format), rounding halfway cases away from zero, regardless of the current rounding mode. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{long} result = Ace::RoundUp(3.5f);
printf(\textcolor{stringliteral}{"%d\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 4


\begin{DoxyParams}{Parameters}
{\em num} & Number to round.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The nearest integer value to num, rounding halfway cases away from zero. If a mathematical error occurs then -\/1 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!SinH@{SinH}}
\index{SinH@{SinH}!Ace@{Ace}}
\subsubsection[{Sin\+H(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+SinH (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab20988efdaa2f4ad09ee73c6ce108e19}


Calculates the SinH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/4/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265;
\textcolor{keywordtype}{double} result = Ace::SinH(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 0.\+868671


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate SinH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The SinH of num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!SinH@{SinH}}
\index{SinH@{SinH}!Ace@{Ace}}
\subsubsection[{Sin\+H(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+SinH (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a3e7c3e005fd8cb91de75cbf911766bf3}


Calculates the SinH in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265f;
\textcolor{keywordtype}{float} result = Ace::SinH(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 0.\+868671


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number in radians to calculate SinH for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The SinH of num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Smallest@{Smallest}}
\index{Smallest@{Smallest}!Ace@{Ace}}
\subsubsection[{Smallest(double num1, double num2)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Smallest (
\begin{DoxyParamCaption}
\item[{double}]{num1, }
\item[{double}]{num2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a43a41e4cedf8be5164b3938a010028c8}


Calculates the smaller of the two values and returns the smaller one. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} retVal = Ace::Smallest(5.002, 5.01);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 5.\+002000


\begin{DoxyParams}{Parameters}
{\em num1} & Number to compare. \\
\hline
{\em num2} & Other number to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The smaller of the two values. 
\end{DoxyReturn}
\index{Ace@{Ace}!Smallest@{Smallest}}
\index{Smallest@{Smallest}!Ace@{Ace}}
\subsubsection[{Smallest(float num1, float num2)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Smallest (
\begin{DoxyParamCaption}
\item[{float}]{num1, }
\item[{float}]{num2}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad07c864576d94daac736fe121ae87a02}


Calculates the smaller of the two values and returns the smaller one. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} retVal = Ace::Smallest(5.002f, 5.01f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 5.\+002000


\begin{DoxyParams}{Parameters}
{\em num1} & Number to compare. \\
\hline
{\em num2} & Other number to compare.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The smaller of the two values. 
\end{DoxyReturn}
\index{Ace@{Ace}!Square\+Root@{Square\+Root}}
\index{Square\+Root@{Square\+Root}!Ace@{Ace}}
\subsubsection[{Square\+Root(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Square\+Root (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a29179fe6de4ef729c5922aeafbde9821}


Returns the Square Root of the provided number. 

If the number provided is negative, -\/1 is returned.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/29/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} squareRoot = Ace::SquareRoot(144.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, squareRoot);
\end{DoxyCode}
 Output\+: 12.\+000000000


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num} & The number to take the Square Root of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If num is negative; -\/1 is returned, else the Square Root is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Square\+Root@{Square\+Root}}
\index{Square\+Root@{Square\+Root}!Ace@{Ace}}
\subsubsection[{Square\+Root(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Square\+Root (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ad29221122ff5bc838ed5741cef72364b}


Returns the Square Root of the provided number. 

If the number provided is negative, -\/1 is returned.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} squareRoot = Ace::SquareRoot(144.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, squareRoot);
\end{DoxyCode}
 Output\+: 12.\+000000000


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em num} & The number to take the Square Root of.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
If num is negative; -\/1 is returned, else the Square Root is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Sub\+String@{Sub\+String}}
\index{Sub\+String@{Sub\+String}!Ace@{Ace}}
\subsubsection[{Sub\+String(char $\ast$str, int start\+Index, int up\+To\+But\+Not\+Including\+Index=\+I\+N\+T\+\_\+\+M\+A\+X)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$ Ace\+::\+Sub\+String (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str, }
\item[{int}]{start\+Index, }
\item[{int}]{up\+To\+But\+Not\+Including\+Index = {\ttfamily INT\+\_\+MAX}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ab94f6a0b50f95846b20a921c1c48cbbd}


Returns a string containing the characters between start\+Index and up\+To\+But\+Not\+Including\+Index. 

Unlike strstr(), this function creates a new string and returns it. If up\+To\+But\+Not\+Including\+Index is not provided, then the string returned is everything from start\+Index to the end of the string.

Here\textquotesingle{}s an example\+: str = \char`\"{}\+Happiness\char`\"{} start\+Index = 3 up\+To\+But\+Not\+Including\+Index = 8 then the output would be \char`\"{}pines\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* substr = Ace::SubString(\textcolor{stringliteral}{"Happiness"}, 3, 8);
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, substr);
\_aligned\_free(substr);
\end{DoxyCode}
 Output\+:pines


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The string to parse. \\
\hline
\mbox{\tt in}  & {\em start\+Index} & The (0 based) index of where to start parsing str. \\
\hline
\mbox{\tt in}  & {\em up\+To\+But\+Not\+Including\+Index} & The (0 based) index of where to stop.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created string containing the characters from start\+Index to up\+To\+But\+Not\+Including\+Index. 
\end{DoxyReturn}
\index{Ace@{Ace}!Sub\+String@{Sub\+String}}
\index{Sub\+String@{Sub\+String}!Ace@{Ace}}
\subsubsection[{Sub\+String(wchar\+\_\+t $\ast$str, int start\+Index, int up\+To\+But\+Not\+Including\+Index=\+I\+N\+T\+\_\+\+M\+A\+X)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$ Ace\+::\+Sub\+String (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str, }
\item[{int}]{start\+Index, }
\item[{int}]{up\+To\+But\+Not\+Including\+Index = {\ttfamily INT\+\_\+MAX}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7d4131741f469b7220631088526e12ee}


Returns a wide string containing the characters between start\+Index and up\+To\+But\+Not\+Including\+Index. 

Unlike strstr(), this function creates a new string and returns it. If up\+To\+But\+Not\+Including\+Index is not provided, then the string returned is everything from start\+Index to the end of the string.

Here\textquotesingle{}s an example\+: str = \char`\"{}\+Happiness\char`\"{} start\+Index = 3 up\+To\+But\+Not\+Including\+Index = 8 then the output would be \char`\"{}pines\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* substr = Ace::SubString(L\textcolor{stringliteral}{"Happiness"}, 3, 8);
printf(\textcolor{stringliteral}{"%S\(\backslash\)n"}, substr);
\_aligned\_free(substr);
\end{DoxyCode}
 Output\+:pines


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & The wide string to parse. \\
\hline
\mbox{\tt in}  & {\em start\+Index} & The (0 based) index of where to start parsing str. \\
\hline
\mbox{\tt in}  & {\em up\+To\+But\+Not\+Including\+Index} & The (0 based) index of where to stop.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A newly created wide string containing the characters from start\+Index to up\+To\+But\+Not\+Including\+Index. 
\end{DoxyReturn}
\index{Ace@{Ace}!Tan@{Tan}}
\index{Tan@{Tan}!Ace@{Ace}}
\subsubsection[{Tan(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Tan (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8434cb3dc1700eb767a393087cf35ade}


Calculates the Tangent (Tan) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265358979;
\textcolor{keywordtype}{double} retVal = Ace::Tan(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 1.\+000000


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number to use to calculate its tangent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Tangent (tan) of num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Tan@{Tan}}
\index{Tan@{Tan}!Ace@{Ace}}
\subsubsection[{Tan(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Tan (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8733891f27eea8b6725acd6ef81c123e}


Calculates the Tangent (Tan) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265358979f;
\textcolor{keywordtype}{float} retVal = Ace::Tan(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 1.\+000000


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number to use to calculate its tangent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Tangent (tan) of num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!TanH@{TanH}}
\index{TanH@{TanH}!Ace@{Ace}}
\subsubsection[{Tan\+H(double num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+TanH (
\begin{DoxyParamCaption}
\item[{double}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_abeaf6de454adb6cbec71470d9c290631}


Calculates The Hyperbolic Tangent (TanH) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{double} PI = 3.14159265358979;
\textcolor{keywordtype}{double} retVal = Ace::TanH(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 0.\+655794


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number to use to calculate its hyperbolic tangent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Hyperbolic Tangent (tan) of num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!TanH@{TanH}}
\index{TanH@{TanH}!Ace@{Ace}}
\subsubsection[{Tan\+H(float num\+In\+Radians)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+TanH (
\begin{DoxyParamCaption}
\item[{float}]{num\+In\+Radians}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ac035088ac628b78d0af94c801211dae8}


Calculates The Hyperbolic Tangent (TanH) of num\+In\+Radians in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keyword}{const} \textcolor{keywordtype}{float} PI = 3.14159265358979f;
\textcolor{keywordtype}{float} retVal = Ace::TanH(PI / 4);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 0.\+655794


\begin{DoxyParams}{Parameters}
{\em num\+In\+Radians} & Number to use to calculate its hyperbolic tangent.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The Hyperbolic Tangent (tan) of num\+In\+Radians. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Tokenize@{Tokenize}}
\index{Tokenize@{Tokenize}!Ace@{Ace}}
\subsubsection[{Tokenize(char $\ast$str\+To\+Tokenize, char $\ast$delimiter, int \&out\+Num\+Tokens\+Found)}]{\setlength{\rightskip}{0pt plus 5cm}char $\ast$$\ast$ Ace\+::\+Tokenize (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str\+To\+Tokenize, }
\item[{char $\ast$}]{delimiter, }
\item[{int \&}]{out\+Num\+Tokens\+Found}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a8e948c04ce26696ede60e70c5f70c361}


Breaks up a string and returns an array of all the strings between each delimiter. 

For example\+: \char`\"{}\+Shit,\+Piss, Cunt,\+Cock-\/sucker,\+Mother\+\_\+\+Fucker,and tits\char`\"{} And the delimiter was \char`\"{},\char`\"{} then the function would return\+: Array[0] = \char`\"{}\+Shit\char`\"{} Array[1] = \char`\"{}\+Piss\char`\"{} Array[2] = \char`\"{} Cunt\char`\"{} Array[3] = \char`\"{}\+Cock-\/sucker\char`\"{} Array[4] = \char`\"{}\+Mother\+\_\+\+Fucker\char`\"{} Array[5] = \char`\"{}and tits\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
5/7/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} numItems = 0;
\textcolor{keywordtype}{char}* data = \textcolor{stringliteral}{"Shit, Piss, Cunt, Cock - sucker, Mother\_Fucker, and tits"};
\textcolor{keywordtype}{char}** items = Ace::Tokenize(data, \textcolor{stringliteral}{","}, numItems);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < numItems; currIndex++)
\{
    printf(\textcolor{stringliteral}{"Array[%d]:%s\(\backslash\)n"}, currIndex, items[currIndex]);
    \_aligned\_free(items[currIndex]);
\}
\_aligned\_free(items);
\end{DoxyCode}
 Output\+:Array[0] = \char`\"{}\+Shit\char`\"{} Array[1] = \char`\"{}\+Piss\char`\"{} Array[2] = \char`\"{} Cunt\char`\"{} Array[3] = \char`\"{}\+Cock-\/sucker\char`\"{} Array[4] = \char`\"{}\+Mother\+\_\+\+Fucker\char`\"{} Array[5] = \char`\"{}and tits\char`\"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Tokenize} & A string to break up into an array. \\
\hline
\mbox{\tt in,out}  & {\em delimiter} & A string/character used to separate each string in str\+To\+Tokenize. \\
\hline
\mbox{\tt in,out}  & {\em out\+Num\+Tokens\+Found} & Number of strings added to the final array.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of strings broken up from str\+To\+Tokenize. 
\end{DoxyReturn}
\index{Ace@{Ace}!Tokenize@{Tokenize}}
\index{Tokenize@{Tokenize}!Ace@{Ace}}
\subsubsection[{Tokenize(wchar\+\_\+t $\ast$str\+To\+Tokenize, wchar\+\_\+t $\ast$delimiter, int \&out\+Num\+Tokens\+Found)}]{\setlength{\rightskip}{0pt plus 5cm}wchar\+\_\+t $\ast$$\ast$ Ace\+::\+Tokenize (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{str\+To\+Tokenize, }
\item[{wchar\+\_\+t $\ast$}]{delimiter, }
\item[{int \&}]{out\+Num\+Tokens\+Found}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a31130831d9560838ac2a2cb54cd6f876}


Breaks up a wide string and returns an array of all the wide strings between each delimiter. 

For example\+: \char`\"{}\+Shit,\+Piss, Cunt,\+Cock-\/sucker,\+Mother\+\_\+\+Fucker,and tits\char`\"{} And the delimiter was \char`\"{},\char`\"{} then the function would return\+: Array[0] = \char`\"{}\+Shit\char`\"{} Array[1] = \char`\"{}\+Piss\char`\"{} Array[2] = \char`\"{} Cunt\char`\"{} Array[3] = \char`\"{}\+Cock-\/sucker\char`\"{} Array[4] = \char`\"{}\+Mother\+\_\+\+Fucker\char`\"{} Array[5] = \char`\"{}and tits\char`\"{}.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
9/8/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{int} numItems = 0;
\textcolor{keywordtype}{wchar\_t}* data = L\textcolor{stringliteral}{"Shit, Piss, Cunt, Cock - sucker, Mother\_Fucker, and tits"};
\textcolor{keywordtype}{wchar\_t}** items = Ace::Tokenize(data, L\textcolor{stringliteral}{","}, numItems);
\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} currIndex = 0; currIndex < numItems; currIndex++)
\{
    printf(\textcolor{stringliteral}{"Array[%d]:%S\(\backslash\)n"}, currIndex, items[currIndex]);
    \_aligned\_free(items[currIndex]);
\}
\_aligned\_free(items);
\end{DoxyCode}
 Output\+:Array[0] = \char`\"{}\+Shit\char`\"{} Array[1] = \char`\"{}\+Piss\char`\"{} Array[2] = \char`\"{} Cunt\char`\"{} Array[3] = \char`\"{}\+Cock-\/sucker\char`\"{} Array[4] = \char`\"{}\+Mother\+\_\+\+Fucker\char`\"{} Array[5] = \char`\"{}and tits\char`\"{}


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em str\+To\+Tokenize} & A wide string to break up into an array. \\
\hline
\mbox{\tt in,out}  & {\em delimiter} & A wide string/character used to separate each wide string in str\+To\+Tokenize. \\
\hline
\mbox{\tt in,out}  & {\em out\+Num\+Tokens\+Found} & Number of wide strings added to the final array.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An array of strings broken up from str\+To\+Tokenize. 
\end{DoxyReturn}
\index{Ace@{Ace}!Truncate@{Truncate}}
\index{Truncate@{Truncate}!Ace@{Ace}}
\subsubsection[{Truncate(double num)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Truncate (
\begin{DoxyParamCaption}
\item[{double}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_aa10aa03639439fc61b99fa44d5f611ea}


Removes everything after the decimal point. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} retVal = Ace::Truncate(2.849543);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 2.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & Number to truncate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The truncated version of num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Truncate@{Truncate}}
\index{Truncate@{Truncate}!Ace@{Ace}}
\subsubsection[{Truncate(float num)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Truncate (
\begin{DoxyParamCaption}
\item[{float}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_ae512b20c30e74f66fef6c9d7fb14e331}


Removes everything after the decimal point. 

Created in compliance with C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/9/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} retVal = Ace::Truncate(2.849543f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, retVal);
\end{DoxyCode}
 Output\+: 2.\+000000


\begin{DoxyParams}{Parameters}
{\em num} & Number to truncate.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The truncated version of num. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Two\+To\+The\+X\+Power@{Two\+To\+The\+X\+Power}}
\index{Two\+To\+The\+X\+Power@{Two\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{Two\+To\+The\+X\+Power(double power)}]{\setlength{\rightskip}{0pt plus 5cm}double Ace\+::\+Two\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{double}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a9c69db829c926e09d728f6f793414fc2}


Calculates 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/5/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{double} result = Ace::TwoToTheXPower(6.0);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 64.\+000000


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise 2 to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of 2$^\wedge$power. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Two\+To\+The\+X\+Power@{Two\+To\+The\+X\+Power}}
\index{Two\+To\+The\+X\+Power@{Two\+To\+The\+X\+Power}!Ace@{Ace}}
\subsubsection[{Two\+To\+The\+X\+Power(float power)}]{\setlength{\rightskip}{0pt plus 5cm}float Ace\+::\+Two\+To\+The\+X\+Power (
\begin{DoxyParamCaption}
\item[{float}]{power}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a0cb2b7227bece54575fd0cb20d5f8234}


Calculates 2$^\wedge$power in compliance with C\+E\+RT Coding Standard. 

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/6/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{float} result = Ace::TwoToTheXPower(6.0f);
printf(\textcolor{stringliteral}{"%f\(\backslash\)n"}, result);
\end{DoxyCode}
 Output\+: 64.\+000000


\begin{DoxyParams}{Parameters}
{\em power} & Number to raise 2 to.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The value of 2$^\wedge$power. If a mathematical error occurs then -\/1.\+0 is returned. 
\end{DoxyReturn}
\index{Ace@{Ace}!Write\+Binary\+File@{Write\+Binary\+File}}
\index{Write\+Binary\+File@{Write\+Binary\+File}!Ace@{Ace}}
\subsubsection[{Write\+Binary\+File(char $\ast$file\+Path, char $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const char $\ast$mode=""wb"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t Ace\+::\+Write\+Binary\+File (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Path, }
\item[{char $\ast$}]{buffer\+To\+Write, }
\item[{size\+\_\+t}]{buffer\+Size, }
\item[{const char $\ast$}]{mode = {\ttfamily \char`\"{}wb\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a5796438df275d4868eda8e1d72991350}


Opens a file for writing and returns the number of items/elements written to the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{size\_t} numItemsWritten = Ace::WriteBinaryFile(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)lookupdata.bin"}, \textcolor{stringliteral}{"0xFFFFFFFF"}, 11);
printf(\textcolor{stringliteral}{"%d\(\backslash\)0"}, numItemsWritten);
\end{DoxyCode}
 Output\+: 11


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
 & {\em buffer\+To\+Write} & The data to be written. \\
\hline
 & {\em buffer\+Size} & Maximum number of bytes to read. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}w\char`\"{} for write, \char`\"{}w+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Number of bytes to offset from origin. \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The buffer containing the file data of size num\+Bytes\+To\+Read. 
\end{DoxyReturn}
\index{Ace@{Ace}!Write\+Binary\+FileW@{Write\+Binary\+FileW}}
\index{Write\+Binary\+FileW@{Write\+Binary\+FileW}!Ace@{Ace}}
\subsubsection[{Write\+Binary\+File\+W(wchar\+\_\+t $\ast$file\+Path, wchar\+\_\+t $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const wchar\+\_\+t $\ast$mode=L""wb, ccs=\+U\+T\+F-\/8"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t Ace\+::\+Write\+Binary\+FileW (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Path, }
\item[{wchar\+\_\+t $\ast$}]{buffer\+To\+Write, }
\item[{size\+\_\+t}]{buffer\+Size, }
\item[{const wchar\+\_\+t $\ast$}]{mode = {\ttfamily L\char`\"{}wb,~ccs=UTF-\/8\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a3dd67050348d7bd1838b2a85e53a93f3}


Opens a file for writing and returns the number of items/elements written to the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{size\_t} numItemsWritten = Ace::WriteBinaryFile(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)lookupdata.bin"}, L\textcolor{stringliteral}{"0xFFFFFFFF"}, 11);
printf(\textcolor{stringliteral}{"%d\(\backslash\)0"}, numItemsWritten);
\end{DoxyCode}
 Output\+: 11


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
 & {\em buffer\+To\+Write} & The data to be written. \\
\hline
 & {\em buffer\+Size} & Maximum number of bytes to read. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}w\char`\"{} for write, \char`\"{}w+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Number of bytes to offset from origin. \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The buffer containing the file data of size num\+Bytes\+To\+Read. 
\end{DoxyReturn}
\index{Ace@{Ace}!Write\+Text\+File@{Write\+Text\+File}}
\index{Write\+Text\+File@{Write\+Text\+File}!Ace@{Ace}}
\subsubsection[{Write\+Text\+File(char $\ast$file\+Path, char $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const char $\ast$mode=""w"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t Ace\+::\+Write\+Text\+File (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{file\+Path, }
\item[{char $\ast$}]{buffer\+To\+Write, }
\item[{size\+\_\+t}]{buffer\+Size, }
\item[{const char $\ast$}]{mode = {\ttfamily \char`\"{}w\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_af96ec8733f6e776aa2296afd79dfe38c}


Opens a file for writing and returns the number of items/elements written to the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{char}* buffer = Ace::AllocateAndCopyString(\textcolor{stringliteral}{"In a row?!"});
\textcolor{keywordtype}{size\_t} bufferSize = strlen(buffer) * \textcolor{keyword}{sizeof}(char);
\textcolor{keywordtype}{size\_t} retVal = Ace::WriteTextFile(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)dicks.txt"}, buffer, bufferSize, \textcolor{stringliteral}{"a"});
\_aligned\_free(buffer);
buffer = Ace::ReadTextFile(\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)dicks.txt"});
printf(\textcolor{stringliteral}{"%s\(\backslash\)n"}, buffer);
\_aligned\_free(buffer);
\end{DoxyCode}
 Output\+: dicksdicksdicksdicksdicksdicksdick8=$>$In a row?!


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
\mbox{\tt in}  & {\em buffer\+To\+Write} & The data to be written. \\
\hline
 & {\em buffer\+Size} & Size of the buffer in bytes. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}w\char`\"{} for write, \char`\"{}w+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Either zero, or a value returned by ftell(). \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of items/elements written to the file. 
\end{DoxyReturn}
\index{Ace@{Ace}!Write\+Text\+FileW@{Write\+Text\+FileW}}
\index{Write\+Text\+FileW@{Write\+Text\+FileW}!Ace@{Ace}}
\subsubsection[{Write\+Text\+File\+W(wchar\+\_\+t $\ast$file\+Path, wchar\+\_\+t $\ast$buffer\+To\+Write, size\+\_\+t buffer\+Size, const wchar\+\_\+t $\ast$mode=L""w, ccs=\+U\+T\+F-\/8"", int seek\+Offset=0, int seek\+Origin=\+S\+E\+E\+K\+\_\+\+S\+E\+T, long $\ast$out\+End\+Cursor\+Pos=\+N\+U\+L\+L)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t Ace\+::\+Write\+Text\+FileW (
\begin{DoxyParamCaption}
\item[{wchar\+\_\+t $\ast$}]{file\+Path, }
\item[{wchar\+\_\+t $\ast$}]{buffer\+To\+Write, }
\item[{size\+\_\+t}]{buffer\+Size, }
\item[{const wchar\+\_\+t $\ast$}]{mode = {\ttfamily L\char`\"{}w,~ccs=UTF-\/8\char`\"{}}, }
\item[{int}]{seek\+Offset = {\ttfamily 0}, }
\item[{int}]{seek\+Origin = {\ttfamily SEEK\+\_\+SET}, }
\item[{long $\ast$}]{out\+End\+Cursor\+Pos = {\ttfamily NULL}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{class_ace_a7a200d3c2e606619c3044ea50904f632}


Opens a file for writing and returns the number of items/elements written to the file. 

Created in compliance with the C\+E\+RT Coding Standard.

\begin{DoxyAuthor}{Author}
Katianie 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
10/13/2016
\end{DoxyDate}

\begin{DoxyCode}
\textcolor{keywordtype}{wchar\_t}* buffer = Ace::AllocateAndCopyString(L\textcolor{stringliteral}{"いい　ですよ。"});
\textcolor{keywordtype}{size\_t} bufferSize = wcslen(buffer) * \textcolor{keyword}{sizeof}(wchar\_t);
\textcolor{keywordtype}{size\_t} retVal = Ace::WriteTextFileW(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)jap.txt"}, buffer, bufferSize, L\textcolor{stringliteral}{"a, ccs=UTF-8"});
\_aligned\_free(buffer);
buffer = Ace::ReadTextFileW(L\textcolor{stringliteral}{"C:\(\backslash\)\(\backslash\)jap.txt"});
MessageBoxW(NULL, buffer, NULL, 0);
\_aligned\_free(buffer);
\end{DoxyCode}
 Output\+: わたし　わ　エドワド　オ’ハゲン　です。　これ　は　なん　です　か？いい　ですよ。


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path} & The path to the file. \\
\hline
\mbox{\tt in}  & {\em buffer\+To\+Write} & The data to be written. \\
\hline
 & {\em buffer\+Size} & Size of the buffer in bytes. \\
\hline
\mbox{\tt in}  & {\em mode} & The mode for fopen\+\_\+s (\char`\"{}w\char`\"{} for write, \char`\"{}w+\char`\"{} for read/write, etc). \\
\hline
 & {\em seek\+Offset} & Either zero, or a value returned by ftell(). \\
\hline
 & {\em seek\+Origin} & Position used as reference for the offset (S\+E\+E\+K\+\_\+\+S\+ET represents beginning of file). \\
\hline
\mbox{\tt out}  & {\em out\+End\+Cursor\+Pos} & The value returned by ftell() after doing the read.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of items/elements written to the file. 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
{\bf Ace.\+h}\item 
{\bf Ace.\+cpp}\end{DoxyCompactItemize}
